## ⏱️ Timestamp-Based Protocols

### • 개요
- 각 트랜잭션 Ti는 고유한 타임스탬프 `TS(Ti)`를 가짐
- 타임스탬프는 트랜잭션 시작 시 부여됨
- 새로운 트랜잭션은 더 큰 TS 값을 가짐
- **논리적 카운터** 또는 **물리적 시간** 기반으로 생성 가능

### • 목적
- **Timestamp order = serializability order** 를 만족하도록 동시성 제어

---

## 🔁 Timestamp-Ordering (TSO) Protocol

### • 데이터 항목 Q에 대해 두 개의 타임스탬프를 유지
- `W-timestamp(Q)`: Q에 대해 **성공적으로 쓰기**한 트랜잭션 중 가장 큰 TS
- `R-timestamp(Q)`: Q에 대해 **성공적으로 읽기**한 트랜잭션 중 가장 큰 TS

### • 동작 원칙
- Read/Write 연산 시 타임스탬프를 기반으로 허용 또는 Rollback 결정

---

## 📖 Read(Q) 수행 시 규칙

트랜잭션 Ti가 `read(Q)`를 수행할 때:

1. `TS(Ti) ≥ W-timestamp(Q)` → **정상 실행**
   - `R-timestamp(Q) ← max(R-timestamp(Q), TS(Ti))`

2. `TS(Ti) < W-timestamp(Q)` → **Rollback**
   - 이미 더 최신 데이터로 덮어씀 → 이전 값 읽기 불가

### • 예시
- T₁: W(Q), TS=5
- T₂: R(Q), TS=6 → 가능 (W < TS)
- T₂: W(Q), 이후 T₁이 R(Q) 시도 → Rollback (TS₁ < W-timestamp(Q₂))

---

## ✍️ Write(Q) 수행 시 규칙

트랜잭션 Ti가 `write(Q)`를 수행할 때:

1. `TS(Ti) < R-timestamp(Q)` → **Rollback**
   - 시스템은 이미 그 값이 필요 없다고 간주했음

2. `TS(Ti) < W-timestamp(Q)` → **Rollback**
   - 이미 더 최신 값 존재 → 덮어쓰면 안 됨

3. 그 외 → **정상 실행**
   - `W-timestamp(Q) ← TS(Ti)`

### • 예시
- T₂: R(Q), TS=6 → R-timestamp(Q)=6
- T₁: W(Q), TS=5 → `TS(T₁) < R-timestamp(Q)` → Rollback

---

## ❗ TSO Protocol의 특징 요약

| 상황                           | 조건                              | 결과           |
|--------------------------------|-----------------------------------|----------------|
| `read(Q)`                     | TS ≥ W-timestamp(Q)               | 허용           |
|                               | TS < W-timestamp(Q)               | Rollback       |
| `write(Q)`                    | TS ≥ max(R-timestamp(Q), W-timestamp(Q)) | 허용   |
|                               | TS < R-timestamp(Q) or W-timestamp(Q)   | Rollback |

---

## ⚠️ 참고 사항
- **Rollback**이 빈번할 수 있음
- **No locks 사용** → 교착상태(deadlock) 없음
- **Cascading aborts** 발생 가능 → 복구 기법과 함께 사용 권장

## 🧭 Example of Schedule Under TSO

### ✅ Schedule 유효성 판별 조건
- 초기 조건: `R-TS(A)=W-TS(A)=0`, `R-TS(B)=W-TS(B)=0`
- 예: T25(TS=25), T26(TS=26)
  - T25: read(B), read(A) → R-TS 갱신
  - T26: read(B), write(B) → W-TS 갱신
  - T25가 read한 후 T26이 write → 유효
  - 이후 T26이 write(A) 하는 것도 T25보다 TS가 큼 → 유효

---

## 🔄 또 다른 예시: read(Q), write(Q) 간 상호작용
- 두 트랜잭션 T27, T28 이 서로 다른 시점에 read/write 수행
- timestamp 비교를 통해 serializability 보장 여부 확인

---

## ⚖️ Another Example Under TSO

- 다수 트랜잭션(T1~T5) 간 Y/Z/X에 대한 연산
- 초기 R-TS, W-TS = 0
- T3의 read(Z) 직후 T2의 write(Z)가 과거 TS로 수행되어 abort됨
- 과거 값에 대한 write는 reject → rollback 발생

---

## ✅ Correctness of Timestamp-Ordering Protocol

- **순서 그래프(Precedence Graph)**는 cycle이 없음
  - 항상 "작은 timestamp → 큰 timestamp" 방향의 간선만 존재
- 따라서 TSO는 **serializability 보장**
- Deadlock 없음 (트랜잭션은 wait하지 않음)
- 단, **Recoverable**하거나 **Cascade-free**는 아님

### 📌 Recoverable 정의:
- T1이 commit하기 전 T2가 commit하면 안 됨 (T2가 T1 결과를 참조한 경우)

---

## ♻️ Recoverability and Cascade Freedom

### ✅ 해결 방안
1. **트랜잭션의 모든 write는 끝에 수행되도록** → atomic commit
2. **lock을 이용하여 commit 전까지 읽기 지연**
3. **commit dependency 이용** → commit 순서 제약 설정

---

## ✍️ Thomas’ Write Rule

- **TSO의 확장(수정) 버전**
- **핵심 아이디어**: 쓰기 연산 중 오래된 값(`TS(Ti) < W-TS(Q)`)은 **무시 가능**
  - 기존 TSO는 rollback
  - Thomas는 **write 무시만** 하고 rollback 없음

### ✨ 장점
- 더 많은 동시성 허용 (view-serializable 스케줄 포함 가능)
- 단, conflict-serializability는 보장하지 않을 수 있음

---

## 🔚 전체 요약

| 항목                      | TSO Protocol                      | Thomas' Write Rule                       |
|---------------------------|------------------------------------|------------------------------------------|
| Serializability 보장     | ✅ Conflict-serializable           | ❌ (View-serializable 허용)              |
| Deadlock 방지            | ✅ (No wait)                       | ✅                                       |
| Cascade rollback 방지     | ❌                                 | ❌                                       |
| 동시성 수준              | 중간 (rollback 있음)              | 높음 (write 무시로 rollback 줄임)        |

## Validation-Based Protocol (OCC)

- **아이디어**: commit 시점을 직렬화 순서로 사용할 수 있는가?
- **방법**:
  - 트랜잭션 종료 시까지 write 연산을 지연
  - 각 트랜잭션이 읽거나 쓴 데이터 항목을 추적
  - commit 시점에 validation 수행 → 직렬화 순서와 어긋나는 읽기/쓰기 여부 확인
- **다른 이름**: optimistic concurrency control

---

## OCC의 세 단계

1. **Read and Execution Phase**
   - 트랜잭션 Ti는 임시 저장소에만 기록
2. **Validation Phase**
   - 트랜잭션 Ti가 직렬성 위반 없이 쓸 수 있는지 검사
3. **Write Phase**
   - 유효성 검사 통과 시, 데이터베이스에 반영
   - 실패 시 rollback

- 가정: validation과 write는 원자적으로 직렬 실행
- 실제로는 세 단계가 상호 교차될 수 있음

---

## OCC 타임스탬프 및 테스트

- 각 트랜잭션 Ti는 아래 세 타임스탬프를 가짐
  - `StartTS(Ti)`: 실행 시작 시각
  - `ValidationTS(Ti)`: validation phase 시작 시각
  - `FinishTS(Ti)`: write phase 종료 시각
- 직렬화 순서는 `ValidationTS`로 정해짐

### Validation Test for Tj
- 모든 Ti (TS(Ti) < TS(Tj))에 대해 다음 중 하나 충족 시 유효:
  1. `FinishTS(Ti) < StartTS(Tj)`
  2. `StartTS(Tj) < FinishTS(Ti) < ValidationTS(Tj)` 이고 Tj는 Ti가 쓴 항목을 읽지 않음

---

## 예시: Schedule Produced by Validation

- 초기 상태:
  - T25: `read(B)`, `read(A)`, `validate`, `display(A+B)`
  - T26: `read(B)`, `B := B – 50`, `read(A)`, `A := A + 50`, `validate`, `write(B)`, `write(A)`
- 조건:
  - `startTS(T26) < finishTS(T25) < validationTS(T26)`
  - T25는 읽기 전용 → validation 성공

## Validation-Based Protocol (OCC)

### 기본 아이디어
- 커밋 시간을 직렬화 순서로 사용할 수 있는지 확인
- **Optimistic Concurrency Control**이라고도 하며, 트랜잭션은 충돌이 없을 것이라 가정하고 실행 후 검증함

### 실행 방식
1. **Read 및 실행 단계**
   - 트랜잭션 `Ti`는 로컬 변수에만 쓰고, 데이터 항목을 읽음
2. **검증 단계**
   - 직렬 가능성을 보장하기 위해 검증(Validation Test) 수행
3. **쓰기 단계**
   - 검증 통과 시 데이터베이스에 적용
   - 실패 시 트랜잭션 롤백

### 타임스탬프
- `StartTS(Ti)`: 실행 시작 시점
- `ValidationTS(Ti)`: 검증 시작 시점
- `FinishTS(Ti)`: 쓰기 완료 시점
- 직렬화 순서는 `ValidationTS` 기준

---

## Validation Test for Transaction `Tj`

`∀ Ti` such that `TS(Ti) < TS(Tj)`, 다음 중 하나를 만족해야 함:
1. `finishTS(Ti) < startTS(Tj)`  
   → 실행이 겹치지 않음 (concurrent 아님)
2. `startTS(Tj) < finishTS(Ti) < validationTS(Tj)`  
   그리고 `Tj`는 `Ti`가 쓴 데이터를 읽지 않음  
   → 데이터 종속성 없음

이 조건들을 만족하면 `Tj` 커밋 가능, 그렇지 않으면 **abort**

---

## 예시: Schedule Produced by Validation
T25: read(B)  
read(A)  
<validate>  
display(A + B)

T26: read(B)  
B := B - 50  
read(A)  
A := A + 50  
<validate>  
write(B)  
write(A)

조건:  
`startTS(T26) < finishTS(T25) < validationTS(T26)`  
→ `T25`는 커밋되었고, 읽기 전용이므로 `T26`은 검증 통과
