## 📌 Write Optimized Indices & LSM Tree

### 🔹 Write Optimized Indices
- B⁺-트리는 **쓰기 중심 워크로드에 비효율적**임
  - 내부 노드가 메모리에 있는 경우에도 한 번의 삽입마다 평균 1회 디스크 I/O 필요
  - 자기 디스크 기준: 초당 100개 미만의 삽입 처리
  - 플래시 메모리의 경우: 삽입 1건당 전체 페이지를 덮어쓰기 해야 함

- 이러한 비용을 줄이기 위한 대표적인 대안:  
  - **Log-structured merge tree (LSM Tree)**

### 🔹 Log Structured Merge (LSM) Tree
- **쓰기 집약적 환경**에 최적화된 구조
  - 메모리에 먼저 데이터를 쓰고, 이후 배치로 디스크에 병합하여 기록
  - **쓰기 속도는 매우 빠름**, 검색 성능은 B⁺-트리보다는 떨어짐 (중간 수준)

- 주요 사용 사례:
  - **Key-value store** 기반 시스템에서 광범위하게 사용됨
    - 예: BigTable, HBase, Cassandra, RocksDB, WiredTiger, InfluxDB, ScyllaDB 등

- **동작 구조**:
  - `MemTable`: 메모리 상의 변경 가능한 구조
  - `Immutable MemTable`: 플러시 대기 상태의 메모리 구조
  - `SSTable`: 디스크 상의 불변 구조로 병합되어 저장됨
  - **Background Compaction**: 메모리-디스크 간의 병합 및 정렬 작업 수행

## 📌 Log Structured Merge (LSM) Tree – 구조적 동작 과정
### 🔹 MemTable이 가득 찬 경우
- INSERT 작업은 처음에는 DRAM 내의 `MemTable`에 저장됨
- `MemTable`이 가득 차면 더 이상 새로운 삽입을 수용할 수 없음
- 이 시점에서 전체 `MemTable`은 **Immutable MemTable**로 전환되고, 새로운 `MemTable`이 생성되어 삽입을 계속 처리함

### 🔹 Immutable MemTable로 전환
- `MemTable`이 가득 차면 내부적으로 **불변 상태(immutable)**로 전환되어 `Immutable MemTable`로 복사됨
- 이 구조는 읽기 전용 상태가 되며, 더 이상 삽입이나 갱신이 발생하지 않음
- 동시에 새로운 `MemTable`이 생성되어 삽입 작업은 중단 없이 계속 가능함

### 🔹 Background Compaction: 디스크로 병합
- `Immutable MemTable`은 백그라운드에서 디스크로 병합됨
- 이 과정에서 메모리 상의 데이터를 정렬된 배열(Sorted Array) 형태로 변환하여 **SSTable**이라는 디스크 기반 불변 구조로 저장
- 변환된 SSTable은 디스크에 계층 구조로 유지되며, 추후 병합(compaction) 대상이 될 수 있음

### 🔹 디스크 내 SSTable 구조
- 디스크에는 다수의 SSTable이 생성되어 존재할 수 있음
- 예:  
  - SSTable 1: 10, 15, 20, 25  
  - SSTable 2: 45, 55, 65, 75  
  - SSTable 3: 60, 80, 90, 100  
- 각 SSTable은 정렬된 키/값 쌍을 포함하며, 검색은 메모리의 인덱스를 기반으로 블룸 필터 또는 메타 정보를 통해 탐색 최적화됨

## 📌 Log Structured Merge (LSM) Tree – 디스크 구조와 병목 문제

### 🔹 디스크 병합 구조와 Write Amplification
- Level 0에는 정렬되지 않은 여러 개의 SSTable이 쌓이며, 중복된 key-value들이 포함될 수 있음
- 일정 수준 이상 쌓이면 Level 1로 **병합(compaction)**됨
  - 병합은 정렬 기반이며, 기존 데이터를 여러 번 다시 쓰는 과정이 발생
  - 이로 인해 **Write Amplification Problem**이 발생함  
    → 동일한 데이터가 여러 번 디스크에 기록되는 문제

### 🔹 이상적인 LSM-Tree의 구조
- 상위 Level에서 하위 Level로 점진적으로 병합되어 SSTable이 정리됨
- 각 Level에 존재하는 SSTable의 개수도 병합을 통해 일정하게 유지됨
- 메모리와 디스크 간 쓰기 흐름이 원활하게 순환됨

### 🔹 현실의 LSM-Tree: 병목 현상
- 현실에서는 다음과 같은 문제가 발생함:
  1. **Memory write는 매우 빠름**: MemTable과 Immutable MemTable은 빠르게 가득 참
  2. **디스크 병합 속도는 느림**: Level 0의 SSTable 병합이 지연됨
- 그 결과, Level 0에 SSTable이 과도하게 쌓임  
  → **디스크 정렬 정체** 발생

### 🔹 Write Stall 문제
- 병합이 지연되어 Immutable MemTable이 디스크로 flush되지 못하면,
  → 새로운 `MemTable`로의 쓰기도 중단됨
  → **Write Stall** 발생

- 이는 전체 시스템 성능을 심각하게 저하시키는 병목으로,
  LSM 구조가 병합을 제때 수행하지 못할 경우 **쓰기 처리 중단**으로 이어짐

### 🔹 요약: LSM의 병목 구조적 원인
- 빠른 메모리 쓰기 속도와 느린 디스크 병합 속도의 불균형
- 이로 인한 `Level 0` SSTable 과다 적체 → 병합 정체 → 쓰기 중단

## 📌 Skip List: Randomized Data Structure

### 🔹 기본 구조
- **Linked List**: 각 노드가 오직 다음 노드만을 가리키는 선형 구조  
  → 탐색 시간 O(n)

- **Skip List**: 여러 수준의 연결 리스트 계층으로 구성된 자료구조  
  - 각 노드는 1개 이상의 수준에 존재할 수 있음
  - 상위 레벨일수록 적은 수의 노드만 존재 → 이진 탐색처럼 빠르게 건너뛰며 탐색 가능
  - 기대 탐색 시간: **O(log n)**

---

### 🔹 Lookup 예시: key 27
- 탐색 시작은 최상위 레벨에서 진행
- 오른쪽 노드의 키가 27보다 크거나 같아질 때까지 이동
- 내려가기를 반복하면서 **27에 도달**하면 탐색 완료

---

### 🔹 Insert 예시: key 20 (level 3)
- 키 20을 삽입할 위치를 탐색한 후, **3개 레벨에 걸쳐 삽입**
- 레벨 3에서부터 아래로 연결하며 기존 링크를 수정
- 삽입된 위치: 14과 27 사이, 각 레벨의 링크 업데이트

---

### 🔹 Delete 예시: key 14
- 키 14가 존재하는 모든 레벨에서 **해당 노드의 링크를 제거**
- 삭제 후에도 다른 노드들의 구조는 그대로 유지되며, skip list는 연결 리스트 특성을 계속 유지함

- 삽입/삭제 시 **포인터 업데이트만 수행**하므로 연산이 효율적이고 단순함

---

### 🔹 요약
- Skip List는 **균형 이진 탐색 트리와 유사한 성능**을 갖는 동시에,
  - 삽입, 삭제, 탐색이 단순한 포인터 조작만으로 구현 가능
  - **LSM-Tree의 MemTable 구현**에 자주 사용됨
