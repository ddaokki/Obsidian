# Storage Access
- Block
	- 저장 및 데이터 전송의 기본 단위
	- 디스크와 메모리 간 전송은 블록 단위로 이루어짐
- 디스크 접근 최소화
	- 디스크 I/O는 비용이 크므로, 최대한 많은 블록을 메모리에 유지함으로써 **디스크 접근 횟수를 줄이는 것**이 중요
- Buffer
	- 메인 메모리의 일부로, 디스크 블록의 복사본을 저장하는 공간
- Buffer Manager
	- 메모리 내의 버퍼 공관을 관리하는 서브시스템
	- 주로 **해시 테이블**을 사용하여 어떤 블록이 메모리에 있는지 추적

![[Structure_of_buffer_and_Disk.png]]

# Buffer Manager
프로그램이 디스크로부터 블록을 필요로 할 때, **Buffer Manager**가 그 요청을 처리함
1. 블록이 이미 버퍼에 있는경우
	- 버퍼 매니저는 **메인 메모리 내 블록의 주소를 반환**함
	- 디스크 접근이 **필요 없음** (성능적으로 유리)
2.  블록이 버퍼에 없는 경우
	1.  버퍼 공간 할당
		- 새 블록을 위한 공간이 필요한 경우,
			- **다른 블록을 제거**(eviction)하여 공간 확보.
			- **제거되는 블록이 수정되었을 경우**에만 디스크에 다시 저장(write-back)함
	2. 디스크로부터 블록을 읽어옴
		- 블록을 디스크에서 버퍼로 로드한 후,
		- 메인 메모리 내 해당 블록의 주소를 요청자에게 반환함


### Buffer Manager - Read
![[BufferManager-Read.png]]

1. **Query -> Buffer manager** (Read Request) 
	- 사용자의 쿼리가 특정 페이지(블록)를 읽기 위해 **버퍼 매니저에게 요청**함
2. **Buffer Manager -> Check Buffer** (If not found in Buffer)
	- 요청된 페이지가 **버퍼에 있는지 확인**
3. **페이지가 버퍼에 없는 경우 (Buffer Miss)**
	- 디스크에서 페이지를 읽어 오기 전에, 버퍼에 빈 공간이 없다면, **교체 정책**에 따라 기존 페이지 하나를 제거 해야함 (Replacement) 
4. **Dirty 여부 확인**
	- 교체 대상 페이지가 **변경된(dirty)** 경우 -> 디스크에 **다시 저장**하고 제거함
	- 변경되지 않은 경우 -> **그냥 버림**
5.  **디스크 -> Buffer Manager** (get Page)
	- 디스크로부터 요청한 페이지를 읽어와 **버퍼에 적재**
6. **Buffer Manager -> Query** (Get Page)
	- 버퍼에 적재된 페이지를 쿼리에 **전달**


### Buffer Manager - Write
![[BufferManager-Write.png]]
1. **Query -> Buffer manager** (Read Request) 
	- 사용자의 쿼리가 데이터 수정/삽입을 위해 **Write Request**를 전송
2. **Buffer Manager -> Check Buffer** (If not found in Buffer)
	- 요청된 페이지가 **버퍼에 있는지 확인**
3. **페이지가 버퍼에 없는 경우 (Buffer Miss)**
	- 디스크에서 페이지를 읽어 오기 전에, 버퍼에 빈 공간이 없다면, **교체 정책**에 따라 기존 페이지 하나를 제거 해야함 (Replacement) 
4. **Dirty 여부 확인**
	- 교체 대상 페이지가 **변경된(dirty)** 경우 -> 디스크에 **다시 저장**하고 제거함
	- 변경되지 않은 경우 -> **그냥 버림**
5.  **디스크 -> Buffer Manager** (get Page)
	- 대상 페이지를 버퍼에 올린 후, **쓰기 작업 수행**
	- 해당 페이지는 이제 **Dirty 상태**로 변경됨

- **Write-back vs Write-through**
	- 이 슬라이드는 **Write-back** 방식에 기반
	- **Write-through**는 수정 시 바로 디스크에 기록(오버헤드 큼)
- **Dirty Bit**: 해당 페이지가 메모리에서 수정되었음을 나타내는 플래그
- **Replacement Policy** 적용 시기
	- 새 페이지를 버퍼에 넣기 전 -> 공간 확보가 필요할 때마다 적용

### Buffer Manager - Transaction Commit
![[BufferManager-Transaction_Commit.png]]
1. **Commit Request**
	- 사용자의 쿼리가 **트랜잭션 커밋 요청**을 보냄
	- 이 요청은 메모리에만 반영되어 있던 변경 내용을 **영구 저장장치(디스크)에 반영하라**는 의미
2. **Flush Dirty Pages**
	- 버퍼 매니저는 **Dirty 상태인 페이지들**을 디스크에 **반영(flush)**함
	- Dirty Page란, 메모리에서 수정되었지만 아직 디스크에 기록되지 않은 페이지
	- 이 단계에서 **실제 데이터 파일에 쓰기 작업이 일어남**



### Buffer Replacement Strategy
#### Pinned Block
- 디스크로 **퇴출(evict)** **될수 없는 블록**
- 이유: 해당 블록을 현재 사용중이거나, 작업 중인 프로세스가 있어서 **삭제하거나 덮어쓰면 안 되기 때문**
	- **Pin**: 읽기 또는 쓰기 작업 전에 블록을 고정시킴
	- **Unpin**: 작업이 끝나면 블록을 해제함
	- 버퍼는 **pin count**를 유지하며, 이 수가 **0이 아닌 경우에는 해당 블록을 교체할 수 없음**

#### Shared and Exclusive Locks on Buffer
버퍼 접근 시 동시성 제어를 위한 잠금 방식
- **Shared Lock**: 다수 읽기 가능(read lock) - 조건: 여러 트랜잭션이 동시에 획득 가능
- **Exclusive Lock**: 쓰기 접근(write lock) - 조건: 단 하나의 트랜잭션만 접근 가능
- **Exclusive Lock**은 동시에 하나만 허용됨
- **Shared Lock**은 여러개 허용되지만, **Exclusive**와는 공존 불가


# Buffer-Replacement Policies
#### LRU (Least Recently Used)
- **가장 오랫동안 사용되지 않은 블록**을 교체 대상으로 선택
- 일반적으로 운영체제(OS)에서 널리 사용되는 방식
- 기본 아이디어: 최근에 사용된 블록은 앞으로도 사용될 가능성이 높다
#### DBMS에서의 LRU 한계
- 데이터베이스 쿼리는 **순차적이고 반복적인 접근 패턴**이 많음
- ex) for each tuple tr of r do
	  for each tuple ts of s do
	    if the tuples tr and ts match ...
- 위와 같은 쿼리는 모든 r 튜플마다 s를 반복 스캔 ->
- **LRU에 의해 s 튜플 페이지가 불필요하게 제거되고 재로딩 되는 문제** 발생
- 결과적으로 **디스크 I/O 증가, 성능 저하**
#### DBMS의 대안: 쿼리 기반 전략
- 쿼리는 디스크를 **예측 가능한 방식(ex. 순차스캔)** 으로 접근함
- DBMS는 이 패턴을 이용하여 **더 적절한 교체 전략**을 사용할 수 있음(MRU, Scan-resistant algorithms, Query Optimizer에 의한 전략적 제어..)

#### Toss-immediate strategy
- 블록이 **처리되자마자 즉시 제거**함
- 캐시효과를 **전혀 기대하지 않음**
- 사용 사례:
	- 일회성 스캔(one-time scan)
	- 다시 사용될 가능성이 거의 없다고 판단되는 블록
- 장점: 버퍼 낭비 없음
- 단점: 필요시 다시 디스크 I/O 발생

#### Most Recently Used(MRU) strategy
- **가장 최근에 사용된 블록을 우선 제거** 대상으로 선택
- **LRU와 정반대**되는 방식
- 사용 사례:
	- 반복 스캔보다 순차적 접근이 많을 때
	- Nested Loop Join처럼 과거 페이지가 더 오래 남아야 하는 경우

#### 통계 기반 전략
- 버퍼 매니저는 **특정 테이블의 접근 확률을 통계적으로 학습**할 수 있음
- 예: 데이터 사전(data dictionary)은 자주 접근되므로 버퍼에 상주시키는 것이 유리
- 휴리스틱 적용 가능:
	- 이 테이블은 자주 쓰이니까 항상 메모리에 유지하자
	- 쿼리 최적화기(Query Optimizer)와 연계 가능

#### Filesystem may reorder writes
- 파일 시스템은 성능 향상을 위해 **쓰기 순서를 변경**할 수 있음
- 그러나 이로 인해 디스크 구조(예: 블록 연결 리스트)가 **손상될 수 있음**
- 예: 한 블록이 디스크에 쓰이기 전에 다음 블록이 먼저 쓰이면 링크가 끊긴 상태가 됨
- 해결 방법:
	- **쓰기 순서 보장**
	- 로그 기반 시스템(WAL, journaling 등)


# Indexing
**Indexing의 목적**
- 데이터 접근 속도 향상(예: 도서관에서 저자 카탈로그로 책을 빠르게 찾는 것)

#### 주요 용어
**Search Key**
- 검색을 위해 사용하는 속성들의 집합 (예: 학번, ISBN 등)
- 인덱스 항목의 기준이 되는 키 값
**Index File**
- 인덱스 정보가 저장된 파일
- 각 레코드는 **index entry(인덱스 항목)** 이라고 하며, 다음 구조를 가진다
- ![[Structure_of_Index_File.png]]
- **Search-key**: 검색키
- **Pointer**: 실제 데이터 레코드의 주소 (또는 페이지 ID)

#### 인덱스의 특징
- **원본 테이블보다 크기가 훨씬 작음**
- 검색 전용 데이터 구조이므로 저장 공간과 접근 속도 측면에서 효율적임

#### 인덱스의 두 가지 유형
- **Ordered Indices**
	- 키들이 정렬된 순서대로 저장됨
	- 범위 검색(BETWEEN, < , >)에 유리
- **Hash Indices
	- 해시 함수를 통해 키를 버킷에 분산 저장
	- 정확한 키 검색(=)에 매우 빠름, 정렬/범위 검색에는 부적합

### Index Evaluation Metrics (인덱스 평가 지표)
#### Access types supported efficiently
- 인덱스가 어떤 유형의 쿼리를 빠르게 지원하는지를 평가
- **Point Query**
	- 특정 키 값 검색: key = value
	- 예: 학번 = 202111306
- **Range Query**
	- 범위 기반 검색: low < key < high
	- 예: 가격 BETWEEN 1000 AND 2000

#### Access Time
- 인덱스를 통해 실제 데이터를 찾는 데 걸리는 시간
- 일반적으로 **검색 효율성**을 나타냄

#### Insertion Time
- 새로운 인덱스 항목을 삽입하는 데 소요되는 시간
- 트리 구조의 경우 재구성(rebalancing) 비용 포함

#### Deletion Time
- 기존 인덱스 항목을 제거하는 데 걸리는 시간
- 역시 자료구조의 특성(재정렬, 포인터 갱신 등)이 영향을 줌

#### Space Overhead
- 인덱스 자체가 차지하는 **추가적인 저장 공간**
- 해시 인덱스는 버킷 배열 공간, 트리 인덱스는 노드 구조와 포인터로 인한 공간 사용


### Ordered Indices
**Ordered Index란?**
- **인덱스 항목들이 검색 키(serach key)의 값에 따라 정렬되어 저장**된 인덱스
- 정렬되어 있으므로 **범위 검색(range query)** 에 매우 유리


#### Ordered Index의 세 가지 주요 유형
1. **Clustered Index (Primary Index)
	- **파일 내 레코드들의 실제 순서와 인덱스의 키 순서가 동일**함
	- 즉, 인덱스 순서대로 데이터가 **물리적으로 저장**
	- 특징:
		- 테이블당 **하나만 존재** 가능 (왜냐하면 데이터는 한 가지 정렬 순서만 가질 수 있음)
		- 데이터 접근이 빠르고 효율적
	- 예시:
		- 학번 순으로 저장된 학생 테이블 + 학번 기반 인덱스
2. **Secondary Index (Nonclustered Index)
	- 인덱스의 정렬 순서와 **데이터의 물리적 순서가 일치하지 않음**
	- 즉, 인덱스는 정렬되어 있어도 **데이터 파일은 다른 순서**로 존재
	- 특징:
		- 테이블당 **여러 개 생성 가능**
		- 포인터를 통해 레코드를 간접적으로 접근 (따라서 다소 비효율)
	- 예시:
		- 이름, 전공, 이메일 등 여러 속성에 대해 부가적으로 인덱스 설정 가능
3. **Indexed-Sequential File (ISAM: Indexed Sequential Access Method)
	- **클러스터드 인덱스를 사용하는 순차 파일 구조**
	- 즉, 검색 키 기준으로 정렬된 순차 파일에 대해 인덱스를 붙여 효율적으로 접근
	- 고정된 구조로 인해 업데이트에 유연하지 않음 -> B+ Tree와는 대비됨


### Dense Index Files
**Dense Index란?**
- **모든 검색 키 값에 대해 인덱스 항목이 존재하는 인덱스 구조**
- 즉, 테이블의 **각 레코드마다 인덱스 엔트리가 하나씩 존재**
- ![[Dense_Index_1.png]]
- ![[Dense_Index_2.png]]

#### Dense Index의 특징
|항목|내용|
|---|---|
|**장점**|검색 정확도 높음, 특정 레코드 빠르게 접근 가능|
|**단점**|인덱스 파일 크기가 큼 (레코드 수만큼 인덱스 생성됨)|
|**사용 시기**|검색 효율이 매우 중요한 경우, 또는 키가 유일할 때|
|**성능 특성**|삽입·삭제 시 인덱스도 함께 수정해야 하므로 비용 발생|
### Sparse Index Files
**Sparse Index란?**
- **일부 검색 키 값에 대해서만 인덱스 항목을 유지**하는 인덱스
- 주로 **레코드들이 검색 키 기준으로 정렬되어 있을 때 사용**
- 각 인덱스 항목은 **하나의 블록(또는 페이지)** 의 첫 번째 레코드를 가리키는 것이 일반적

#### 검색 동작 방식
레코드 키 값 k를 찾고자 할 떄:
1. 인덱스에서 k보다 **작거나 같은 가장 큰 키 값**을 찾음
	- 예: k = 46656 라면 인덱스에서 32343을 찾음
2. 해당 인덱스가 가리키는 레코드에서 시작해 **순차적으로 검색**
#### Sparse Index의 특징
| 항목        | 내용                             |
| --------- | ------------------------------ |
| **장점**    | 인덱스 파일 크기가 작음 (공간 효율적)         |
| **단점**    | 정확한 키를 찾을 때 **추가적인 순차 탐색**이 필요 |
| **전제 조건** | 테이블이 **검색 키 기준으로 정렬되어 있어야 함**  |
| **적용 예시** | 클러스터드 인덱스, ISAM 구조 등           |
![[Sparse_Index.png]]


### Secondary Indices
**Secondary Index란?**
- **데이터 파일의 물리적 정렬 순서와는 다른 필드에 대해 만들어진 인덱스**
- 즉, **검색 키 순서 ≠ 실제 레코드 저장 순서**
- 예, 테이블은 ID 기준으로 정렬되어 있으나, 인덱스는 salary 기준으로 생성됨
![[Secondary_index.png]]

### Multilevel Index
#### Multilevel Index란?
- **인덱스가 너무 커서 메모리에 적재되지 못할 때,** 그 인덱스를 다시 인덱싱하여 계층적 구조를 만든 것

#### 기본 구성
1. **Inner Index (기본 인덱스)**
    - 실제 레코드들에 대한 인덱스
    - Dense 또는 Sparse 가능
2. **Outer Index (외부 인덱스)**
    - Inner Index에 대한 **Sparse Index**
    - 각 블록의 첫 번째 엔트리만 추출하여 인덱스 구성
    - 보통 이 외부 인덱스는 메모리에 올릴 수 있도록 작게 만듦
3. 필요 시 **Outer of Outer Index**도 생성 가능  
    → 다단 트리 구조
    
---
#### 적용 상황
- **기본 인덱스조차 메모리에 적재 불가할 때**
- 디스크 접근을 최소화하여 **검색 시간 단축**이 목적
---
#### 유지보수 고려사항
- **모든 수준의 인덱스가 삽입/삭제 시 함께 업데이트되어야 함**
    - 예: 새로운 값이 Inner Index에 추가되면 Outer Index도 수정 가능성 있음
    - 구조 변경이 빈번하면 성능 저하 가능
![[Multilevel_index.png]]