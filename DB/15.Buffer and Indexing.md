# Storage Access
- Block
	- 저장 및 데이터 전송의 기본 단위
	- 디스크와 메모리 간 전송은 블록 단위로 이루어짐
- 디스크 접근 최소화
	- 디스크 I/O는 비용이 크므로, 최대한 많은 블록을 메모리에 유지함으로써 **디스크 접근 횟수를 줄이는 것**이 중요
- Buffer
	- 메인 메모리의 일부로, 디스크 블록의 복사본을 저장하는 공간
- Buffer Manager
	- 메모리 내의 버퍼 공관을 관리하는 서브시스템
	- 주로 **해시 테이블**을 사용하여 어떤 블록이 메모리에 있는지 추적

![[Structure_of_buffer_and_Disk.png]]

# Buffer Manager
프로그램이 디스크로부터 블록을 필요로 할 때, **Buffer Manager**가 그 요청을 처리함
1. 블록이 이미 버퍼에 있는경우
	- 버퍼 매니저는 **메인 메모리 내 블록의 주소를 반환**함
	- 디스크 접근이 **필요 없음** (성능적으로 유리)
2.  블록이 버퍼에 없는 경우
	1.  버퍼 공간 할당
		- 새 블록을 위한 공간이 필요한 경우,
			- **다른 블록을 제거**(eviction)하여 공간 확보.
			- **제거되는 블록이 수정되었을 경우**에만 디스크에 다시 저장(write-back)함
	2. 디스크로부터 블록을 읽어옴
		- 블록을 디스크에서 버퍼로 로드한 후,
		- 메인 메모리 내 해당 블록의 주소를 요청자에게 반환함


### Buffer Manager - Read
![[BufferManager-Read.png]]

1. **Query -> Buffer manager** (Read Request) 
	- 사용자의 쿼리가 특정 페이지(블록)를 읽기 위해 **버퍼 매니저에게 요청**함
2. **Buffer Manager -> Check Buffer** (If not found in Buffer)
	- 요청된 페이지가 **버퍼에 있는지 확인**
3. **페이지가 버퍼에 없는 경우 (Buffer Miss)**
	- 디스크에서 페이지를 읽어 오기 전에, 버퍼에 빈 공간이 없다면, **교체 정책**에 따라 기존 페이지 하나를 제거 해야함 (Replacement) 
4. **Dirty 여부 확인**
	- 교체 대상 페이지가 **변경된(dirty)** 경우 -> 디스크에 **다시 저장**하고 제거함
	- 변경되지 않은 경우 -> **그냥 버림**
5.  **디스크 -> Buffer Manager** (get Page)
	- 디스크로부터 요청한 페이지를 읽어와 **버퍼에 적재**
6. **Buffer Manager -> Query** (Get Page)
	- 버퍼에 적재된 페이지를 쿼리에 **전달**


### Buffer Manager - Write
![[BufferManager-Write.png]]
1. **Query -> Buffer manager** (Read Request) 
	- 사용자의 쿼리가 데이터 수정/삽입을 위해 **Write Request**를 전송
2. **Buffer Manager -> Check Buffer** (If not found in Buffer)
	- 요청된 페이지가 **버퍼에 있는지 확인**
3. **페이지가 버퍼에 없는 경우 (Buffer Miss)**
	- 디스크에서 페이지를 읽어 오기 전에, 버퍼에 빈 공간이 없다면, **교체 정책**에 따라 기존 페이지 하나를 제거 해야함 (Replacement) 
4. **Dirty 여부 확인**
	- 교체 대상 페이지가 **변경된(dirty)** 경우 -> 디스크에 **다시 저장**하고 제거함
	- 변경되지 않은 경우 -> **그냥 버림**
5.  **디스크 -> Buffer Manager** (get Page)
	- 대상 페이지를 버퍼에 올린 후, **쓰기 작업 수행**
	- 해당 페이지는 이제 **Dirty 상태**로 변경됨

- **Write-back vs Write-through**
	- 이 슬라이드는 **Write-back** 방식에 기반
	- **Write-through**는 수정 시 바로 디스크에 기록(오버헤드 큼)
- **Dirty Bit**: 해당 페이지가 메모리에서 수정되었음을 나타내는 플래그
- **Replacement Policy** 적용 시기
	- 새 페이지를 버퍼에 넣기 전 -> 공간 확보가 필요할 때마다 적용

### Buffer Manager - Transaction Commit
![[BufferManager-Transaction_Commit.png]]
1. **Commit Request**
	- 사용자의 쿼리가 **트랜잭션 커밋 요청**을 보냄
	- 이 요청은 메모리에만 반영되어 있던 변경 내용을 **영구 저장장치(디스크)에 반영하라**는 의미
2. **Flush Dirty Pages**
	- 버퍼 매니저는 **Dirty 상태인 페이지들**을 디스크에 **반영(flush)**함
	- Dirty Page란, 메모리에서 수정되었지만 아직 디스크에 기록되지 않은 페이지
	- 이 단계에서 **실제 데이터 파일에 쓰기 작업이 일어남**



### Buffer Replacement Strategy
#### Pinned Block
- 디스크로 **퇴출(evict)** **될수 없는 블록**
- 이유: 해당 블록을 현재 사용중이거나, 작업 중인 프로세스가 있어서 **삭제하거나 덮어쓰면 안 되기 때문**
	- **Pin**: 읽기 또는 쓰기 작업 전에 블록을 고정시킴
	- **Unpin**: 작업이 끝나면 블록을 해제함
	- 버퍼는 **pin count**를 유지하며, 이 수가 **0이 아닌 경우에는 해당 블록을 교체할 수 없음**

#### Shared and Exclusive Locks on Buffer
버퍼 접근 시 동시성 제어를 위한 잠금 방식
- **Shared Lock**: 다수 읽기 가능(read lock) - 조건: 여러 트랜잭션이 동시에 획득 가능
- **Exclusive Lock**: 쓰기 접근(write lock) - 조건: 단 하나의 트랜잭션만 접근 가능
- **Exclusive Lock**은 동시에 하나만 허용됨
- **Shared Lock**은 여러개 허용되지만, **Exclusive**와는 공존 불가


# Buffer-Replacement Policies
#### LRU (Least Recently Used)
- **가장 오랫동안 사용되지 않은 블록**을 교체 대상으로 선택
- 일반적으로 운영체제(OS)에서 널리 사용되는 방식
- 기본 아이디어: 최근에 사용된 블록은 앞으로도 사용될 가능성이 높다
#### DBMS에서의 LRU 한계
- 데이터베이스 쿼리는 **순차적이고 반복적인 접근 패턴**이 많음
- ex) for each tuple tr of r do
	  for each tuple ts of s do
	    if the tuples tr and ts match ...
- 위와 같은 쿼리는 모든 r 튜플마다 s를 반복 스캔 ->
- **LRU에 의해 s 튜플 페이지가 불필요하게 제거되고 재로딩 되는 문제** 발생
- 결과적으로 **디스크 I/O 증가, 성능 저하**
#### DBMS의 대안: 쿼리 기반 전략
- 쿼리는 디스크를 **예측 가능한 방식(ex. 순차스캔)** 으로 접근함
- DBMS는 이 패턴을 이용하여 **더 적절한 교체 전략**을 사용할 수 있음(MRU, Scan-resistant algorithms, Query Optimizer에 의한 전략적 제어..)

#### Toss-immediate strategy
- 블록이 **처리되자마자 즉시 제거**함
- 캐시효과를 **전혀 기대하지 않음**
- 사용 사례:
	- 일회성 스캔(one-time scan)
	- 다시 사용될 가능성이 거의 없다고 판단되는 블록
- 장점: 버퍼 낭비 없음
- 단점: 필요시 다시 디스크 I/O 발생

#### Most Recently Used(MRU) strategy
- **가장 최근에 사용된 블록을 우선 제거** 대상으로 선택
- **LRU와 정반대**되는 방식
- 사용 사례:
	- 반복 스캔보다 순차적 접근이 많을 때
	- Nested Loop Join처럼 과거 페이지가 더 오래 남아야 하는 경우

#### 통계 기반 전략
- 버퍼 매니저는 **특정 테이블의 접근 확률을 통계적으로 학습**할 수 있음
- 예: 데이터 사전(data dictionary)은 자주 접근되므로 버퍼에 상주시키는 것이 유리
- 휴리스틱 적용 가능:
	- 이 테이블은 자주 쓰이니까 항상 메모리에 유지하자
	- 쿼리 최적화기(Query Optimizer)와 연계 가능

#### Filesystem may reorder writes
- 파일 시스템은 성능 향상을 위해 **쓰기 순서를 변경**할 수 있음
- 그러나 이로 인해 디스크 구조(예: 블록 연결 리스트)가 **손상될 수 있음**
- 예: 한 블록이 디스크에 쓰이기 전에 다음 블록이 먼저 쓰이면 링크가 끊긴 상태가 됨
- 해결 방법:
	- **쓰기 순서 보장**
	- 로그 기반 시스템(WAL, journaling 등)


# Indexing
**Indexing의 목적**
- 데이터 접근 속도 향상(예: 도서관에서 저자 카탈로그로 책을 빠르게 찾는 것)

#### 주요 용어
**Search Key**
- 검색을 위해 사용하는 속성들의 집합 (예: 학번, ISBN 등)
- 인덱스 항목의 기준이 되는 키 값
**Index File**
- 인덱스 정보가 저장된 파일
- 각 레코드는 **index entry(인덱스 항목)** 이라고 하며, 다음 구조를 가진다
- ![[Pasted image 20250519221117.png]]
- **Search-key**: 검색키
- **Pointer**: 실제 데이터 레코드의 주소 (또는 페이지 ID)

#### 인덱스의 특징
- **원본 테이블보다 크기가 훨씬 작음**
- 검색 전용 데이터 구조이므로 저장 공간과 접근 속도 측면에서 효율적임

#### 인덱스의 두 가지 유형
- **Ordered Indices**
	- 키들이 정렬된 순서대로 저장됨
	- 범위 검색(BETWEEN, < , >)에 유리
- **Hash Indices
	- 해시 함수를 통해 키를 버킷에 분산 저장
	- 정확한 키 검색(=)에 매우 빠름, 정렬/범위 검색에는 부적합

### Index Evaluation Metrics (인덱스 평가 지표)
#### Access types supported efficiently
- 인덱스가 어떤 유형의 쿼리를 빠르게 지원하는지를 평가
- **Point Query**
	- 특정 키 값 검색: key = value
	- 예: 학번 = 202111306
- **Range Query**
	- 범위 기반 검색: low < key < high
	- 예: 가격 BETWEEN 1000 AND 2000

#### Access Time
- 인덱스를 통해 실제 데이터를 찾는 데 걸리는 시간
- 일반적으로 **검색 효율성**을 나타냄

#### Insertion Time
- 새로운 인덱스 항목을 삽입하는 데 소요되는 시간
- 트리 구조의 경우 재구성(rebalancing) 비용 포함

#### Deletion Time
- 기존 인덱스 항목을 제거하는 데 걸리는 시간
- 역시 자료구조의 특성(재정렬, 포인터 갱신 등)이 영향을 줌

#### Space Overhead
- 인덱스 자체가 차지하는 **추가적인 저장 공간**
- 해시 인덱스는 버킷 배열 공간, 트리 인덱스는 노드 구조와 포인터로 인한 공간 사용
