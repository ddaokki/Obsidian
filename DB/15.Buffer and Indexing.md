# Storage Access
- Block
	- 저장 및 데이터 전송의 기본 단위
	- 디스크와 메모리 간 전송은 블록 단위로 이루어짐
- 디스크 접근 최소화
	- 디스크 I/O는 비용이 크므로, 최대한 많은 블록을 메모리에 유지함으로써 **디스크 접근 횟수를 줄이는 것**이 중요
- Buffer
	- 메인 메모리의 일부로, 디스크 블록의 복사본을 저장하는 공간
- Buffer Manager
	- 메모리 내의 버퍼 공관을 관리하는 서브시스템
	- 주로 **해시 테이블**을 사용하여 어떤 블록이 메모리에 있는지 추적

![[Pasted image 20250519212524.png]]

# Buffer Manager
프로그램이 디스크로부터 블록을 필요로 할 때, **Buffer Manager**가 그 요청을 처리함
1. 블록이 이미 버퍼에 있는경우
	- 버퍼 매니저는 **메인 메모리 내 블록의 주소를 반환**함
	- 디스크 접근이 **필요 없음** (성능적으로 유리)
2.  블록이 버퍼에 없는 경우
	1.  버퍼 공간 할당
		- 새 블록을 위한 공간이 필요한 경우,
			- **다른 블록을 제거**(eviction)하여 공간 확보.
			- **제거되는 블록이 수정되었을 경우**에만 디스크에 다시 저장(write-back)함
	2. 디스크로부터 블록을 읽어옴
		- 블록을 디스크에서 버퍼로 로드한 후,
		- 메인 메모리 내 해당 블록의 주소를 요청자에게 반환함


### Buffer Manager - Read
![[Pasted image 20250519213337.png]]

1. **Query -> Buffer manager** (Read Request) 
	- 사용자의 쿼리가 특정 페이지(블록)를 읽기 위해 **버퍼 매니저에게 요청**함
2. **Buffer Manager -> Check Buffer** (If not found in Buffer)
	- 요청된 페이지가 **버퍼에 있는지 확인**
3. **페이지가 버퍼에 없는 경우 (Buffer Miss)**
	- 디스크에서 페이지를 읽어 오기 전에, 버퍼에 빈 공간이 없다면, **교체 정책**에 따라 기존 페이지 하나를 제거 해야함 (Replacement) 
4. **Dirty 여부 확인**
	- 교체 대상 페이지가 **변경된(dirty)** 경우 -> 디스크에 **다시 저장**하고 제거함
	- 변경되지 않은 경우 -> **그냥 버림**
5.  **디스크 -> Buffer Manager** (get Page)
	- 디스크로부터 요청한 페이지를 읽어와 **버퍼에 적재**
6. **Buffer Manager -> Query** (Get Page)
	- 버퍼에 적재된 페이지를 쿼리에 **전달**


### Buffer Manager - Write
![[Pasted image 20250519214053.png]]
1. **Query -> Buffer manager** (Read Request) 
	- 사용자의 쿼리가 데이터 수정/삽입을 위해 **Write Request**를 전송
2. **Buffer Manager -> Check Buffer** (If not found in Buffer)
	- 요청된 페이지가 **버퍼에 있는지 확인**
3. **페이지가 버퍼에 없는 경우 (Buffer Miss)**
	- 디스크에서 페이지를 읽어 오기 전에, 버퍼에 빈 공간이 없다면, **교체 정책**에 따라 기존 페이지 하나를 제거 해야함 (Replacement) 
4. **Dirty 여부 확인**
	- 교체 대상 페이지가 **변경된(dirty)** 경우 -> 디스크에 **다시 저장**하고 제거함
	- 변경되지 않은 경우 -> **그냥 버림**
5.  **디스크 -> Buffer Manager** (get Page)
	- 대상 페이지를 버퍼에 올린 후, **쓰기 작업 수행**
	- 해당 페이지는 이제 **Dirty 상태**로 변경됨

- **Write-back vs Write-through**
	- 이 슬라이드는 **Write-back** 방식에 기반
	- **Write-through**는 수정 시 바로 디스크에 기록(오버헤드 큼)
- **Dirty Bit**: 해당 페이지가 메모리에서 수정되었음을 나타내는 플래그
- **Replacement Policy** 적용 시기
	- 새 페이지를 버퍼에 넣기 전 -> 공간 확보가 필요할 때마다 적용

### Buffer Manager - Transaction Commit
![[Pasted image 20250519214724.png]]
1. **Commit Request**
	- 사용자의 쿼리가 **트랜잭션 커밋 요청**을 보냄
	- 이 요청은 메모리에만 반영되어 있던 변경 내용을 **영구 저장장치(디스크)에 반영하라**는 의미
2. **Flush Dirty Pages**
	- 버퍼 매니저는 **Dirty 상태인 페이지들**을 디스크에 **반영(flush)**함
	- Dirty Page란, 메모리에서 수정되었지만 아직 디스크에 기록되지 않은 페이지
	- 이 단계에서 **실제 데이터 파일에 쓰기 작업이 일어남**



### Buffer Replacement Strategy
#### Pinned Block
- 디스크로 **퇴출(evict)** **될수 없는 블록**
- 이유: 해당 블록을 현재 사용중이거나, 작업 중인 프로세스가 있어서 **삭제하거나 덮어쓰면 안 되기 때문**
	- **Pin**: 읽기 또는 쓰기 작업 전에 블록을 고정시킴
	- **Unpin**: 작업이 끝나면 블록을 해제함
	- 버퍼는 **pin count**를 유지하며, 이 수가 **0이 아닌 경우에는 해당 블록을 교체할 수 없음**

#### Shared and Exclusive Locks on Buffer
버퍼 접근 시 동시성 제어를 위한 잠금 방식
- **Shared Lock**: 다수 읽기 가능(read lock) - 조건: 여러 트랜잭션이 동시에 획득 가능
- **Exclusive Lock**: 쓰기 접근(write lock) - 조건: 단 하나의 트랜잭션만 접근 가능
- **Exclusive Lock**은 동시에 하나만 허용됨
- **Shared Lock**은 여러개 허용되지만, **Exclusive**와는 공존 불가


# Buffer-Replacement Policies
#### LRU (Least Recently Used)
- **가장 오랫동안 사용되지 않은 블록**을 교체 대상으로 선택
- 일반적으로 운영체제(OS)에서 널리 사용되는 방식
- 기본 아이디어: 최근에 사용된 블록은 앞으로도 사용될 가능성이 높다
#### DBMS에서의 LRU 한계
- 데이터베이스 쿼리는 **순차적이고 반복적인 접근 패턴**이 많음
- ex) for each tuple tr of r do
	  for each tuple ts of s do
	    if the tuples tr and ts match ...
- 위와 같은 쿼리는 모든 r 튜플마다 s를 반복 스캔 ->
- **LRU에 의해 s 튜플 페이지가 불필요하게 제거되고 재로딩 되는 문제** 발생
- 결과적으로 **디스크 I/O 증가, 성능 저하**
#### DBMS의 대안: 쿼리 기반 전력
- 쿼리는 디스크를 **예측 가능한 방식(ex. 순차스캔)** 으로 접근함
- DBMS는 이 패턴을 이용하여 **더 적절한 교체 전략**을 사용할 수 있음