## 🔁 Summary of Last Lecture

### • Locking Modes
1. `exclusive (X)` 모드: 읽기/쓰기 가능 → `lock-X`
2. `shared (S)` 모드: 읽기만 가능 → `lock-S`

### • 주요 개념
- `Deadlock`: 상호 대기 상태
- `Starvation`: 특정 트랜잭션이 영원히 실행되지 못하는 현상

---

## 🔄 Summary: Two-Phase Locking

- **Phase 1: Growing Phase**
  - lock 획득 가능
  - lock 해제는 불가

- **Phase 2: Shrinking Phase**
  - lock 해제 가능
  - lock 획득은 불가

### • Strict 2PL
- exclusive lock을 `commit/abort`까지 유지

### • Rigorous 2PL
- **모든 lock**을 commit/abort까지 유지
- 직렬화 순서 보장 + cascading rollback 방지

---

## ❌ Deadlock Handling

### • Deadlock 정의
- 트랜잭션 집합이 서로 상대방의 lock 해제를 기다리는 상태

### • 예시
- T₃: `lock-X(B)` → `write(B)` → `lock-X(A)`
- T₄: `lock-S(A)` → `read(A)` → `lock-S(B)`

→ T₃는 A를 기다림, T₄는 B를 기다림 → **Deadlock 발생**

---

## 🛡️ Deadlock Prevention

- 시스템이 deadlock 상태에 들어가지 않도록 미리 차단
- 대표적인 전략들:

### • Pre-declaration 방식
- 트랜잭션은 시작 전에 **모든 데이터 항목 lock**을 요청함

### • Graph-Based 방식
- **데이터 항목 간 partial ordering** 정의  
- 트랜잭션은 정의된 순서에 따라만 접근 가능

---

## 🔃 Deadlock Prevention: 타임스탬프 기반 기법

### • Wait-Die (비선점, non-preemptive)
- **오래된 트랜잭션**은 젊은 트랜잭션이 점유 중인 lock을 기다릴 수 있음
- 젊은 트랜잭션은 기다릴 수 없고 → **바로 rollback됨**
- → 여러 번 죽을 수 있음

### • Wound-Wait (선점, preemptive)
- 오래된 트랜잭션이 lock 요청 → **젊은 트랜잭션을 강제로 rollback**
- 젊은 트랜잭션은 기다릴 수 있음
- → Wait-Die보다 rollback 횟수 적음

※ 두 방식 모두 rollback된 트랜잭션은 **원래 타임스탬프 유지 후 재시도**
→ starvation 방지, 순서 보장

---

## ⏱️ Deadlock Prevention: Timeout-Based Schemes
- 트랜잭션은 lock을 일정 시간 동안만 기다림
- 시간이 초과되면 → rollback 처리됨

### • 장점
- Deadlock 발생 시 자동 해결
- 구현 단순

### • 단점
- **Deadlock이 없더라도 rollback 발생 가능**
- timeout 설정값 조정이 어려움
- starvation 가능성 존재

## 🕸️ Deadlock Detection

### • Wait-for Graph
- 각 트랜잭션은 `정점(vertex)`  
- `Ti → Tj`: Ti가 Tj가 보유한 lock을 기다리고 있음
- 이 그래프에 **사이클**이 존재하면 → deadlock 상태

### • 탐지 방법
- 주기적으로 **deadlock 탐지 알고리즘**을 실행하여 사이클 확인
- 예:
  - cycle 없음 → 정상
  - cycle 있음 → deadlock

---

## 🔁 Deadlock Recovery

- Deadlock 발생 시 **트랜잭션 일부를 rollback (victim 선정)** 하여 순환을 끊어야 함

### • Victim 선정 기준
- rollback 비용이 **최소**인 트랜잭션

### • Rollback 방법
- `Total rollback`: 트랜잭션 전체 중단 및 재시작
- `Partial rollback`: 필요한 lock만 해제할 만큼만 되돌림

### • Starvation 가능성
- 동일 트랜잭션이 반복적으로 victim으로 선정되는 경우  
→ **해결책**: 가장 오래된 트랜잭션은 victim으로 선정하지 않음

---

## 📐 Multiple Granularity Locking

- 데이터 항목들을 다양한 **크기 단위(granularity)**로 구성
- 예: `database > area > file > record`

→ 트리 형태로 표현 가능 (단, tree protocol과는 무관함)

### • 특징
- 트리 상의 노드에 lock 걸면 → **하위 노드도 암묵적으로 lock**됨
- Locking 위치에 따라 다음 특성 존재:

| Granularity | Locking Overhead | Concurrency |
|-------------|------------------|-------------|
| Fine        | 높음             | 높음        |
| Coarse      | 낮음             | 낮음        |

---

## 🧭 Example of Granularity Hierarchy
Hierarchy 예시:
- database (root)  
    └─ area  
    └─ file  
    └─ record
    
- 예: `DB → A₀ → F₀ → T₀`
  - T₀가 F₀를 `X` lock하면, 암묵적으로 F₀ 하위 레코드도 잠김

---

## 🧩 Intention Lock Modes

Multiple granularity 환경에서는 S/X 외에도 **추가적인 잠금 모드**가 필요함:

### • 추가 모드
- `IS (Intention-Shared)`  
  - 하위 노드에 shared lock을 명시적으로 걸 예정임

- `IX (Intention-Exclusive)`  
  - 하위 노드에 exclusive 또는 shared lock을 걸 예정임

- `SIX (Shared + Intention-Exclusive)`  
  - 해당 노드 자체는 shared로 잠기고  
    하위 노드에는 exclusive lock을 명시적으로 걸 예정

### • 역할
- 상위 노드에 S/X lock을 설정할 때 하위 모든 노드 상태를 검사할 필요 없음  
→ **잠금 호환성 판단을 효율화**함

## 🧩 Compatibility Matrix (Intention Lock 포함)

|     | IS   | IX   | S    | SIX  | X    |
|-----|------|------|------|------|------|
| IS  | true | true | true | true | false |
| IX  | true | true | false | false | false |
| S   | true | false | true | false | false |
| SIX | true | false | false | false | false |
| X   | false | false | false | false | false |

- 상위 노드에서 lock 모드의 **호환성 판단**에 사용
- `X`는 어떤 lock과도 **호환되지 않음**

---

## 🧱 Multiple Granularity Locking Scheme

### • Lock 규칙 (Ti가 노드 Q를 잠글 때):
1. **호환성 매트릭스** 만족해야 함
2. **트리의 루트**를 가장 먼저 잠금
3. `S`, `IS`는 상위 노드가 `IS`, `IX`인 경우에만 가능
4. `X`, `IX`, `SIX`는 상위 노드가 `IX`, `SIX`여야 가능
5. 이미 unlock한 경우 다시 lock 불가 (2PL 적용됨)
6. Q의 자식 노드가 lock되어 있으면 unlock 불가

### • Lock Granularity Escalation
- 특정 레벨에서 너무 많은 lock을 보유한 경우 → 상위 수준(S 또는 X)으로 **승격(escalation)**

---

## 🔐 Insert/Delete & Predicate Read 규칙

### • Insert/Delete Locking
- 튜플 삭제 전에는 **X-lock**이 필요
- 새로운 튜플 삽입 시 자동으로 **X-lock 획득**

### • 보장 사항
- 읽기/쓰기와 삭제 간 **충돌 방지**
- 커밋 전까지는 삽입된 튜플은 다른 트랜잭션에서 접근 불가

---

## 👻 Phantom Phenomenon

### • 예시
- T₁: `SELECT COUNT(*) FROM instructor WHERE dept = 'Physics'`
- T₂: 위 쿼리 이후 `'Physics'` 항목 삽입

→ **직접적인 튜플 충돌 없음에도** 논리적 충돌 발생

### • 발생 원인
- 단순 튜플 잠금만 사용 → **범위 기반 접근(Predicate read)** 보호 불가
- 같은 relation을 다루나 scan vs insert로 인해 phantom 발생 가능

---

## 🚫 Handling Phantoms

### • 해결책 1: Relation-Level Locking
- relation에 관련된 정보를 나타내는 **가상 데이터 항목**을 정의
- scan: 해당 항목에 `S-lock`, insert/delete: `X-lock`
- 단점: **낮은 동시성**

---

## 📚 Index Locking Protocol (to Prevent Phantoms)

- 인덱스 기반 접근을 전제로 함
- lookup 수행 시 **해당 인덱스 리프 노드를 S-lock으로 잠금**
- insert/update/delete는 관련된 모든 인덱스에 대해 **X-lock 필요**
- **2PL 규칙 준수 필요**
- ✅ phantom 방지 **보장**

---

## 🔐 Next-Key Locking Protocol

- 인덱스의 leaf 노드에서 **key 값과 그 다음 key 사이의 범위**를 잠금

### • 특징
- S-lock: lookup/scan
- X-lock: insert/delete/update
- 높은 동시성 허용
- lookup 값이 없어도 해당 범위를 잠금하여 phantom 방지

### • 예시
- B+ Tree leaf: 3, 5, 8, 11, 14, 18, 24 ...
- 쿼리: `WHERE 7 ≤ x ≤ 16`
  - → `S-lock`: [5,8], [8,11], [11,14]
  - → `X-lock`: [14,18] (insertion 위치 고려)

---

## ✅ 정리: Phantom 방지 기법 비교

| 기법                 | 설명                         | 동시성        | Phantom 방지 |
|----------------------|------------------------------|---------------|---------------|
| Tuple Locking        | 튜플 단위 잠금               | 높음          | ❌            |
| Relation Locking     | relation 단위 잠금           | 낮음          | ✅            |
| Index Locking        | 리프 노드 잠금               | 보통          | ✅            |
| Next-Key Locking     | 값 + 다음 값 사이 범위 잠금  | 높음          | ✅            |



