## Concurrency Control
- **목표**: DBMS는 다음 조건을 만족하는 스케줄링 결정을 내려야 함
  - conflict-serializable 또는 view-serializable
  - recoverable하고 가능한 경우 cascaded-free해야 함
- **DBMS 스케줄러의 역할**:
  - 한 번에 하나의 트랜잭션만 실행하는 정책은 직렬성과 안정성을 보장하지만 동시성은 낮음
  - 대부분의 concurrency-control 기법은 동시성과 오버헤드 사이의 trade-off를 가짐
  - 일부 기법은 conflict-serializable한 스케줄만 허용하고, 다른 기법은 view-serializable 스케줄도 허용함

## Weak Levels of Consistency
- **OLAP 애플리케이션**은 성능을 위해 일관성이 약한 스케줄(비직렬 가능)도 허용함
  - 정확도보다 성능을 중시하는 트레이드오프
- **OLTP (Online Transaction Processing)**:
  - 실제 엔터프라이즈 모델을 정확히 반영하는 데이터베이스를 유지함
  - 단순하고 짧은 트랜잭션
  - DB의 일부만 접근
- **OLAP (Online Analytic Processing)**:
  - 전략적 의사결정 지원을 위한 데이터 활용
  - 복잡한 쿼리 및 대용량 접근
  - 최신 데이터일 필요 없음 (예: CEO가 전체 잔고 추정 시점 파악)
  - 반드시 직렬 가능할 필요 없음

## Phenomena caused by Concurrent Transactions
- **dirty read**: 커밋되지 않은 다른 트랜잭션의 데이터를 읽음
- **nonrepeatable read**: 같은 쿼리를 두 번 실행했을 때 데이터가 변경되어 결과가 다름
- **phantom read**: 같은 쿼리를 실행했을 때 새로 삽입된 튜플로 인해 결과가 달라짐
- **serialization anomaly**: 일관성 있게 커밋된 트랜잭션 조합이 어떤 순서의 직렬 실행과도 일치하지 않음

## Phantom Phenomenon
- **예시**:
  - 트랜잭션 1 (T1):  
    `select ID, name from instructor where salary > 90000`
  - 트랜잭션 2 (T2):  
    `insert into instructor values ('11111', 'James', 'Marketing', 100000)`
- **상황**:
  - T1이 시작되어 salary > 90000 조건을 만족하는 튜플을 인덱스 기반으로 탐색하고 잠금
  - 이후 T2가 실행되어 새로운 튜플을 삽입
  - 이때 튜플 수준의 잠금으로는 삽입 충돌을 감지하지 못함 → phantom phenomenon 발생

## Transaction Isolation in SQL-92
- **Serializable** (기본값): 가장 높은 수준의 격리, 모든 이상 현상 방지
- **Repeatable read**: 커밋된 레코드만 읽으며, 같은 레코드는 항상 같은 값 반환
  - 단, 다른 트랜잭션이 새로운 레코드를 삽입하는 것은 방지하지 못함 (phantom read 가능)
- **Read committed**: 커밋된 레코드만 읽지만, 반복 조회 시 값이 달라질 수 있음
- **Read uncommitted**: 커밋되지 않은 데이터도 읽을 수 있음 (가장 낮은 수준)

### Isolation 수준별 현상 발생 여부

| Isolation Level      | Dirty Read | Nonrepeatable Read | Phantom Read | Serialization Anomaly |
|----------------------|------------|---------------------|---------------|------------------------|
| Read uncommitted     | 가능       | 가능                | 가능          | 가능                   |
| Read committed       | 불가능     | 가능                | 가능          | 가능                   |
| Repeatable read      | 불가능     | 불가능              | 가능          | 가능                   |
| Serializable         | 불가능     | 불가능              | 불가능        | 불가능                 |

## Transaction Definition in SQL
- SQL에서 트랜잭션은 암시적으로 시작됨
- 종료 방식:
  - `COMMIT`: 현재 트랜잭션을 커밋하고 새 트랜잭션 시작
  - `ROLLBACK`: 현재 트랜잭션을 중단하고 롤백
- 대부분 DBMS에서는 명시적 명령 없이도 성공 시 자동 커밋 수행
  - JDBC 예: `connection.setAutoCommit(false)`로 명시적 전환 가능
- 격리 수준 설정 방법:
  - SQL: `set transaction isolation level serializable`
  - JDBC: `connection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE)`

## Implementation of Isolation Levels
- **Locking**:
  - 전체 DB vs 개별 항목 단위 잠금
  - 잠금 유지 시간, 공유 잠금(S) vs 배타 잠금(X)
- **Timestamp**:
  - 트랜잭션 시작 시 타임스탬프 부여
  - 각 데이터 항목은 `read timestamp`, `write timestamp` 유지
  - 순서 위반 감지 가능
- **Multiple versions**:
  - 각 데이터 항목의 버전을 유지하여 snapshot 기반 읽기 가능

## Lock-Based Protocols
- **Lock**: 동시 접근 제어를 위한 메커니즘
- **잠금 모드**:
  1. `exclusive (X)` 잠금: 읽기/쓰기 모두 가능 (`lock-X`)
  2. `shared (S)` 잠금: 읽기만 가능 (`lock-S`)
- **요청은 concurrency-control manager를 통해 승인된 후 적용됨**

