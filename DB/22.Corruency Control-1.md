## Concurrency Control
- **목표**: DBMS는 다음 조건을 만족하는 스케줄링 결정을 내려야 함
  - conflict-serializable 또는 view-serializable
  - recoverable하고 가능한 경우 cascaded-free해야 함
- **DBMS 스케줄러의 역할**:
  - 한 번에 하나의 트랜잭션만 실행하는 정책은 직렬성과 안정성을 보장하지만 동시성은 낮음
  - 대부분의 concurrency-control 기법은 동시성과 오버헤드 사이의 trade-off를 가짐
  - 일부 기법은 conflict-serializable한 스케줄만 허용하고, 다른 기법은 view-serializable 스케줄도 허용함

## Weak Levels of Consistency
- **OLAP 애플리케이션**은 성능을 위해 일관성이 약한 스케줄(비직렬 가능)도 허용함
  - 정확도보다 성능을 중시하는 트레이드오프
- **OLTP (Online Transaction Processing)**:
  - 실제 엔터프라이즈 모델을 정확히 반영하는 데이터베이스를 유지함
  - 단순하고 짧은 트랜잭션
  - DB의 일부만 접근
- **OLAP (Online Analytic Processing)**:
  - 전략적 의사결정 지원을 위한 데이터 활용
  - 복잡한 쿼리 및 대용량 접근
  - 최신 데이터일 필요 없음 (예: CEO가 전체 잔고 추정 시점 파악)
  - 반드시 직렬 가능할 필요 없음

## Phenomena caused by Concurrent Transactions
- **dirty read**: 커밋되지 않은 다른 트랜잭션의 데이터를 읽음
- **nonrepeatable read**: 같은 쿼리를 두 번 실행했을 때 데이터가 변경되어 결과가 다름
- **phantom read**: 같은 쿼리를 실행했을 때 새로 삽입된 튜플로 인해 결과가 달라짐
- **serialization anomaly**: 일관성 있게 커밋된 트랜잭션 조합이 어떤 순서의 직렬 실행과도 일치하지 않음

## Phantom Phenomenon
- **예시**:
  - 트랜잭션 1 (T1):  
    `select ID, name from instructor where salary > 90000`
  - 트랜잭션 2 (T2):  
    `insert into instructor values ('11111', 'James', 'Marketing', 100000)`
- **상황**:
  - T1이 시작되어 salary > 90000 조건을 만족하는 튜플을 인덱스 기반으로 탐색하고 잠금
  - 이후 T2가 실행되어 새로운 튜플을 삽입
  - 이때 튜플 수준의 잠금으로는 삽입 충돌을 감지하지 못함 → phantom phenomenon 발생

## Transaction Isolation in SQL-92
- **Serializable** (기본값): 가장 높은 수준의 격리, 모든 이상 현상 방지
- **Repeatable read**: 커밋된 레코드만 읽으며, 같은 레코드는 항상 같은 값 반환
  - 단, 다른 트랜잭션이 새로운 레코드를 삽입하는 것은 방지하지 못함 (phantom read 가능)
- **Read committed**: 커밋된 레코드만 읽지만, 반복 조회 시 값이 달라질 수 있음
- **Read uncommitted**: 커밋되지 않은 데이터도 읽을 수 있음 (가장 낮은 수준)

### Isolation 수준별 현상 발생 여부

| Isolation Level      | Dirty Read | Nonrepeatable Read | Phantom Read | Serialization Anomaly |
|----------------------|------------|---------------------|---------------|------------------------|
| Read uncommitted     | 가능       | 가능                | 가능          | 가능                   |
| Read committed       | 불가능     | 가능                | 가능          | 가능                   |
| Repeatable read      | 불가능     | 불가능              | 가능          | 가능                   |
| Serializable         | 불가능     | 불가능              | 불가능        | 불가능                 |

## Transaction Definition in SQL
- SQL에서 트랜잭션은 암시적으로 시작됨
- 종료 방식:
  - `COMMIT`: 현재 트랜잭션을 커밋하고 새 트랜잭션 시작
  - `ROLLBACK`: 현재 트랜잭션을 중단하고 롤백
- 대부분 DBMS에서는 명시적 명령 없이도 성공 시 자동 커밋 수행
  - JDBC 예: `connection.setAutoCommit(false)`로 명시적 전환 가능
- 격리 수준 설정 방법:
  - SQL: `set transaction isolation level serializable`
  - JDBC: `connection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE)`

## Implementation of Isolation Levels
- **Locking**:
  - 전체 DB vs 개별 항목 단위 잠금
  - 잠금 유지 시간, 공유 잠금(S) vs 배타 잠금(X)
- **Timestamp**:
  - 트랜잭션 시작 시 타임스탬프 부여
  - 각 데이터 항목은 `read timestamp`, `write timestamp` 유지
  - 순서 위반 감지 가능
- **Multiple versions**:
  - 각 데이터 항목의 버전을 유지하여 snapshot 기반 읽기 가능

## Lock-Based Protocols
- **Lock**: 동시 접근 제어를 위한 메커니즘
- **잠금 모드**:
  1. `exclusive (X)` 잠금: 읽기/쓰기 모두 가능 (`lock-X`)
  2. `shared (S)` 잠금: 읽기만 가능 (`lock-S`)
- **요청은 concurrency-control manager를 통해 승인된 후 적용됨**

## 🔐 Lock-Based Protocols (계속)

### • Lock-compatibility matrix
|     | S     | X     |
|-----|-------|-------|
| S   | true  | false |
| X   | false | false |

- `Shared Lock (S)`: 여러 트랜잭션이 동시에 가능
- `Exclusive Lock (X)`: 독점적, 다른 어떤 lock도 허용하지 않음
- lock 부여는 요청한 lock이 이미 존재하는 lock과 **호환될 경우**에만 가능함

---

### • Locking 예시
T₂ 트랜잭션 실행 흐름:
`lock-S(A)`  
`read(A)`  
`unlock(A)`  
`lock-S(B)`  
`read(B)`  
`unlock(B)`  
`display(A + B)`

> 이런 방식의 locking만으로는 직렬 가능성(serializability)을 **보장할 수 없음**

---

## 🔄 Schedule With Lock Grants

- 슬라이드 예시에서는 lock 부여(grant)는 lock 요청 직후 발생한다고 가정함
- 주어진 스케줄은 직렬화 불가능함  
  → 트랜잭션 순서 간에 충돌(conflict)이 발생하지만 해결되지 않음

### • Locking Protocol
- 트랜잭션이 lock을 요청하고 해제하는 데 따라야 하는 규칙의 집합
- locking protocol은 **일정한 스케줄만 허용함으로써** 직렬화를 보장함

---

## ❌ Deadlock

### • 예시: partial schedule
- T₃: `lock-X(B)`, `write(B)`, `lock-X(A)`  
- T₄: `lock-S(A)`, `lock-S(B)`

→ 결과:
- T₃는 T₄의 A lock 해제를 기다림
- T₄는 T₃의 B lock 해제를 기다림

⇒ 두 트랜잭션 모두 **진행 불가 (wait-for cycle)**  
⇒ 이러한 상황을 **deadlock**이라고 함

### • 해결 방법
- 두 트랜잭션 중 하나(T₃ 또는 T₄)를 rollback하고 lock을 해제해야 함

---

## ❗ Deadlock (Cont.)

### • Deadlock의 일반적 특성
- 대부분의 locking 기반 프로토콜에서 **deadlock 가능성 존재**
- deadlock은 시스템 설계상 **불가피한 필요악**으로 간주됨

---

## 🚫 Starvation

- starvation도 발생 가능함 (concurrency control manager가 적절하지 않을 경우)

예시:
- 한 트랜잭션이 `X-lock`을 기다리는 동안, 다른 트랜잭션들이 계속 `S-lock`을 획득하며 대기 상태 유지
- 또는 deadlock 해제를 위해 **항상 동일한 트랜잭션이 rollback**될 경우

---

## ✅ 설계 방안
- Concurrency control manager는 starvation을 방지하도록 설계할 수 있음
  - 예: priority 설정, fairness policy, wait-die, wound-wait 등 적용


## 🔒 Two-Phase Locking Protocol (2PL)

- 충돌 직렬 가능성(conflict-serializability)을 **보장**하는 프로토콜
- 트랜잭션은 두 개의 단계로 나뉨:

### 1. Growing Phase
- `lock`은 획득 가능  
- `unlock`은 불가

### 2. Shrinking Phase
- `lock` 획득 불가  
- `unlock`만 가능

- 트랜잭션은 **마지막 lock을 획득한 시점 이후부터 unlock만 수행**
- 트랜잭션들은 **lock point** 순서대로 직렬화가 가능함

> ⚠️ 단, 2PL은 conflict-serializability의 **필요조건은 아님**

---

## 🔐 Extensions of 2PL

### • Strict Two-Phase Locking
- `exclusive lock`은 **commit 또는 abort 시점까지 유지**
- → **회복 가능성(recoverability)** 보장

### • Rigorous Two-Phase Locking
- **모든 lock (S, X)을 commit/abort까지 유지**
- 트랜잭션 커밋 순서대로 직렬화 가능
- **cascading rollback 방지**

> 대부분의 DB는 rigorous 2PL을 사용하지만 통칭해 2PL이라 부름  
> ❗ **2PL은 deadlock 방지는 보장하지 않음**

---

## 🔄 Lock Conversions (잠금 변환)

- 2PL과 lock 변환을 함께 사용하는 경우:

### • Growing Phase
- `lock-S`, `lock-X` 획득 가능
- `lock-S` → `lock-X` **upgrade** 가능

### • Shrinking Phase
- `lock-S`, `lock-X` 해제 가능
- `lock-X` → `lock-S` **downgrade** 가능

→ 이 프로토콜도 직렬 가능성 보장

---

## ⚙️ Automatic Acquisition of Locks

트랜잭션은 명시적으로 lock 요청 없이 read/write 수행  
시스템이 자동으로 lock 처리

### • read(D)
`python
if Tᵢ has lock on D:
    read(D)
else:
    wait until no X-lock on D
    grant Tᵢ a lock-S on D
    read(D)

### • write(D)
if Tᵢ has lock-X on D:
    write(D)
else:
    wait until no lock on D
    if Tᵢ has lock-S on D:
        upgrade to lock-X
    else:
        grant lock-X
    write(D)

- 모든 lock은 `commit` 또는 `abort` 시점에 해제됨
---

## 🧠 Implementation of Locking
- `lock manager`: 별도 프로세스로 구현 가능
- 트랜잭션은 lock 요청/해제 메시지를 전송함
### • 작동 방식
- lock 요청 시: grant 또는 rollback 메시지 응답
- **요청이 처리될 때까지 대기함**
    
### • 자료구조
- `lock table`: in-memory 구조로, granted locks와 대기 중인 요청 관리
→ 이는 deadlock 탐지 및 회피 전략에 사용됨

## 📋 Lock Table

- Lock manager는 데이터 항목별로 `lock table`을 유지
- 각 항목에 대해 granted/waiting 상태의 lock 요청들을 큐로 관리

### • 구성
- `파란색`: granted된 lock
- `밝은색`: waiting 상태의 lock

### • 동작 방식
- 새 요청은 큐의 끝에 추가됨
- 기존 lock들과 `호환 가능`하면 바로 grant됨
- unlock 요청 발생 시:
  - 해당 요청 제거
  - 이후 요청들이 grant 가능한지 재검사

- 트랜잭션이 `abort`되면:
  - 해당 트랜잭션의 모든 lock (granted + waiting)은 제거됨
  - → lock manager는 트랜잭션별 lock 목록도 별도로 유지함

---

## 🔗 Graph-Based Protocols

- **2PL의 대안**으로 사용되는 접근 방식
- 데이터 항목 집합 D에 대해 **partial order(부분 순서)** `→`를 정의

### • 규칙
- 만약 `dᵢ → dⱼ`라면, dᵢ와 dⱼ 모두 접근하는 트랜잭션은 반드시 **dᵢ를 먼저** 접근해야 함
- 이 조건은 집합 D를 **DAG(방향성 비순환 그래프)**로 만들며, 이를 **database graph**라 함

→ 대표적인 예: **Tree Protocol**

---

## 🌳 Tree Protocol

- **오직 exclusive lock만 허용**
- 트랜잭션 Tᵢ는 다음 규칙을 따라야 함:

### • 규칙
1. 첫 lock은 어떤 항목이든 가능
2. 그 이후 항목 Q는 **Q의 부모 항목이 이미 lock되어 있을 때만** lock 가능
3. lock은 언제든 해제 가능
4. 한 번 lock했다 해제한 항목은 **다시 lock 불가**

→ 트리 구조 내에서 상위 → 하위 순서로 접근하고, 이전 항목은 재접근 금지

---

## ✅ Tree Protocol의 특성

### • 장점
- **conflict-serializability 보장**
- **deadlock 발생 불가**
- unlock이 **더 빠르게 가능** (2PL보다 더 많은 동시성 허용)
- rollback 불필요 (deadlock이 없기 때문에)

### • 단점
- `recoverability` 또는 `cascade freedom`을 보장하지 않음
  - 커밋 종속성 도입 필요
- 트랜잭션이 **접근하지 않을 데이터까지 lock**해야 할 수 있음
  - → 오버헤드 및 동시성 저하 가능

---

## 📌 Tree Protocol vs 2PL

| 특징                  | Two-Phase Locking | Tree Protocol          |
|-----------------------|-------------------|------------------------|
| 직렬 가능성 보장      | ✅                | ✅                     |
| Deadlock 방지         | ❌                | ✅                     |
| 회복 가능성 보장      | ✅ (strict/rigorous 시) | ❌                     |
| unlock 시점 유연성    | ❌ (shrinking phase 이후만 가능) | ✅ (언제든 가능)    |
| 구조적 제한 필요 여부 | ❌                | ✅ (트리 상위 노드부터 접근 필요) |

→ 일부 스케줄은 2PL로만, 일부는 Tree Protocol로만 가능
