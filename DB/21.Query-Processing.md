## 📌 Basic Steps in Query Processing

### 🔹 세 단계 구성
1. **Parsing and Translation**  
   - SQL 질의를 파싱하고 문법 검사 및 릴레이션 이름 검증
   - 릴레이션 연산자로 구성된 **관계 대수 표현(relational-algebra expression)**으로 변환

2. **Optimization**  
   - 동일한 의미를 가지는 여러 관계 대수 표현 중 **가장 비용이 낮은 표현**을 선택
   - 최적화된 표현은 실행 계획(execution plan)으로 변환됨

3. **Evaluation**  
   - **Evaluation engine**이 실행 계획을 실행하고 결과를 반환함

---

## 📌 Optimization: Query Evaluation Plan

### 🔹 관계 대수 표현의 다양성
- 동일한 질의는 다양한 연산 조합으로 표현될 수 있음  
  예:  
  `σ_salary > 75000 (π_salary (instructor))` ≡ `π_salary (σ_salary > 75000 (instructor))`

- 각 연산자는 여러 평가 알고리즘을 가질 수 있음  
  → 이 중 하나를 선택하는 것이 **query-evaluation-plan**

- 예시:  
  - 인덱스를 사용하는 방법  
  - 전체 테이블 스캔 방식 등

---

## 📌 Query Optimization

### 🔹 최적화 기준
- 가능한 모든 실행 계획 중 **비용이 가장 낮은 것**을 선택
- 비용 추정에는 **통계 정보** 활용 (예: 릴레이션의 튜플 수, 블록 수 등)

### 🔹 최적화 내용
- 관계 연산자의 실행 비용 측정
- 실행 계획 간 비교 알고리즘
- 연산자 조합을 통한 실행 계획 생성 방식

---

## 📌 Measures of Query Cost

### 🔹 비용 요소
- 질의 수행 시간 = 디스크 접근 + CPU 연산 + 네트워크 지연 등
- 일반적으로는 **디스크 접근 비용이 지배적**

### 🔹 디스크 접근 비용 계산
- 다음 요소를 고려함:
  - 탐색 수(seeks) × 평균 탐색 비용
  - 블록 읽기 수 × 블록 읽기 비용
  - 블록 쓰기 수 × 블록 쓰기 비용 (쓰기 > 읽기 비용)

---

## 📌 Query Cost (계속)

### 🔹 단순화된 모델
- **블록 전송 수** `b`, **탐색 수** `S`만 고려
- 비용 계산식:  
  `b * t_r + S * t_s`  
  - `t_r`: 한 블록 전송 시간  
  - `t_s`: 한 번 탐색하는 데 걸리는 시간

- CPU 비용은 생략함 (실제 시스템에서는 포함)
- 디스크로의 **쓰기 출력 비용은 고려하지 않음**

## 📌 Basic Steps in Query Processing

### 🔹 세 단계 구성
1. **Parsing and Translation**  
   - SQL 질의를 파싱하고 문법 검사 및 릴레이션 이름 검증
   - 릴레이션 연산자로 구성된 **관계 대수 표현(relational-algebra expression)**으로 변환

2. **Optimization**  
   - 동일한 의미를 가지는 여러 관계 대수 표현 중 **가장 비용이 낮은 표현**을 선택
   - 최적화된 표현은 실행 계획(execution plan)으로 변환됨

3. **Evaluation**  
   - **Evaluation engine**이 실행 계획을 실행하고 결과를 반환함

---

## 📌 Optimization: Query Evaluation Plan

### 🔹 관계 대수 표현의 다양성
- 동일한 질의는 다양한 연산 조합으로 표현될 수 있음  
  예:  
  `σ_salary > 75000 (π_salary (instructor))` ≡ `π_salary (σ_salary > 75000 (instructor))`

- 각 연산자는 여러 평가 알고리즘을 가질 수 있음  
  → 이 중 하나를 선택하는 것이 **query-evaluation-plan**

- 예시:  
  - 인덱스를 사용하는 방법  
  - 전체 테이블 스캔 방식 등

---

## 📌 Query Optimization

### 🔹 최적화 기준
- 가능한 모든 실행 계획 중 **비용이 가장 낮은 것**을 선택
- 비용 추정에는 **통계 정보** 활용 (예: 릴레이션의 튜플 수, 블록 수 등)

### 🔹 최적화 내용
- 관계 연산자의 실행 비용 측정
- 실행 계획 간 비교 알고리즘
- 연산자 조합을 통한 실행 계획 생성 방식

---

## 📌 Measures of Query Cost

### 🔹 비용 요소
- 질의 수행 시간 = 디스크 접근 + CPU 연산 + 네트워크 지연 등
- 일반적으로는 **디스크 접근 비용이 지배적**

### 🔹 디스크 접근 비용 계산
- 다음 요소를 고려함:
  - 탐색 수(seeks) × 평균 탐색 비용
  - 블록 읽기 수 × 블록 읽기 비용
  - 블록 쓰기 수 × 블록 쓰기 비용 (쓰기 > 읽기 비용)

---

## 📌 Query Cost (계속)

### 🔹 단순화된 모델
- **블록 전송 수** `b`, **탐색 수** `S`만 고려
- 비용 계산식:  
  `b * t_r + S * t_s`  
  - `t_r`: 한 블록 전송 시간  
  - `t_s`: 한 번 탐색하는 데 걸리는 시간

- CPU 비용은 생략함 (실제 시스템에서는 포함)
- 디스크로의 **쓰기 출력 비용은 고려하지 않음**

## 📌 Selection Operation & Index Scan 방식

### 🔹 File Scan (선형 탐색)
- **가장 기본적인 연산 방식**으로, 파일 블록을 처음부터 끝까지 선형 탐색
- 알고리즘 A1 (linear search):  
  - 모든 블록을 순회하며 조건을 만족하는 레코드 확인  
  - 비용: `b_r * t_r + t_s`  
    - `b_r`: 릴레이션 r이 차지하는 블록 수  
    - `t_r`: 블록 전송 시간, `t_s`: 탐색 시간

- 유일 키인 경우 조건 만족 시 즉시 종료 가능 → 평균 `0.5 * b_r * t_r + t_s`

---

## 📌 Selections Using Indices

### 🔹 A2 (Primary B⁺-tree index, equality on key)
- 인덱스를 사용하여 정확히 하나의 레코드를 탐색  
- 비용: `(h_i + 1) * (t_r + t_s)`  
  - `h_i`: B⁺-트리의 높이

### 🔹 A3 (Primary B⁺-tree index, equality on non-unique key)
- 인덱스로 다수의 레코드를 찾음  
- 레코드가 연속된 블록에 있는 경우:  
  - 비용: `h_i * (t_r + t_s) + t_s + t_r * b`  
  - `b`: 연속된 블록 수

### 🔹 A4 (Secondary index, equality on non-unique key)
- 인덱스는 존재하지만 레코드는 **다른 블록에 흩어져 있음**
- 비용 (단일 결과): `(h_i + 1) * (t_r + t_s)`  
- 비용 (n개 결과): `(h_i + n) * (t_r + t_s)`

---

## 📌 Selections Involving Comparisons

### 🔹 A5 (Primary B⁺-tree index, comparison)
- 예: `σ_A ≥ v(r)`
  - 인덱스를 사용해 조건 만족 첫 튜플을 찾고, 이후 **순차적으로 탐색**
  - 비용: `h_i * (t_r + t_s) + t_s + b' * t_r`
    - `b'`: 읽은 블록 수
- 예: `σ_A < v(r)`
  - 인덱스 사용하지 않고 선형 탐색으로 해결

### 🔹 A6 (Secondary B⁺-tree index, comparison)
- 예: `σ_A ≥ v(r)`
  - 조건을 만족하는 인덱스의 첫 엔트리를 찾고, **인덱스를 순차 스캔**
  - 이후 각 포인터가 가리키는 실제 레코드를 I/O로 접근
  - 비용: `(h_i + n) * (t_r + t_s)`
  - 이 경우 **레코드 I/O 비용 누적** → 전체 선형 탐색이 더 나을 수도 있음

## 📌 Implementation of Complex Selections

### 🔹 Conjunction: `σ_θ₁ ∧ θ₂ ∧ ⋯ ∧ θₙ(r)`
- 여러 조건이 모두 참인 레코드를 선택할 때 사용

#### A7 (conjunctive selection using one index)
- 하나의 조건 `θᵢ`에 인덱스를 사용하여 가장 비용이 낮은 방법 선택
- 이후 나머지 조건은 메모리 내에서 필터링  
  예: `salary > 50000 ∧ dept = 'CS'` → 인덱스 있는 조건 우선 선택

#### A8 (conjunctive selection using composite index)
- **다중 속성 인덱스**가 존재할 경우 해당 인덱스를 직접 활용

#### A9 (conjunctive selection by intersection of identifiers)
- **조건마다 인덱스 존재** 시:
  - 각 조건별 레코드 ID(포인터) 리스트 추출
  - 리스트 간 **교집합** 수행
  - 해당 레코드들만 디스크에서 가져옴
  - 일부 조건은 메모리 상에서 추가 필터링 가능

---

## 📌 Algorithms for Complex Selections

### 🔹 Disjunction: `σ_θ₁ ∨ θ₂ ∨ ⋯ ∨ θₙ(r)`
- 조건 중 하나라도 만족하는 레코드를 선택할 때 사용

#### A10 (disjunctive selection by union of identifiers)
- 조건마다 인덱스가 있는 경우:
  - 조건별 레코드 ID를 가져와 **합집합**
  - 해당 레코드만 디스크에서 조회

- 인덱스가 없으면 선형 탐색 사용

---

### 🔹 Negation: `σ_¬θ(r)`
- 부정 조건을 포함한 질의 처리

- **파일 선형 탐색**이 일반적 (특히 다수 레코드가 부정 조건 만족 시)

- 인덱스를 사용할 수 있는 경우:
  - `¬θ`를 만족하는 **소수의 레코드만 존재**하고,
  - `θ`에 대해 인덱스가 존재할 경우 유용함

## 📌 Sorting in Query Processing

### 🔹 정렬의 중요성
- 정렬은 **DBMS에서 핵심적인 작업** 중 하나임
- 메모리에 관계가 모두 올라가는 경우 → quicksort 등 내장 알고리즘 사용
- 관계가 메모리에 적재되지 않는 경우 → **External Sort-Merge** 사용

---

## 📌 External Sort-Merge 개요

### 🔹 단계 1: 정렬된 Run 생성
- 메모리 크기 M (페이지 단위)만큼 반복 수행
  1. M 블록을 메모리에 적재
  2. 내부에서 정렬 (예: quicksort)
  3. 정렬된 결과를 Run `Rᵢ`로 디스크에 저장
- 결과적으로 **N개의 정렬된 Run** 생성

---

### 🔹 단계 2: Merge Runs (N-way merge)

- 가정: Run 수 N < M
  1. N개의 Run을 각각 1페이지씩 메모리에 적재 (N 페이지 사용)
  2. 출력 버퍼용 1페이지 사용
  3. 각 Run에서 첫 번째 값 읽고, 그 중 최소값을 출력 버퍼에 기록
  4. 해당 Run에서 값 제거하고 다음 값 가져옴
  5. 출력 버퍼가 가득 차면 디스크로 기록
  6. 모든 Run이 소진될 때까지 반복

---

## 📌 예시 (M = 4)

- 초기 데이터 → Run 3개 생성 (각 4개씩 정렬됨)
- 1-pass Merge 실행하여 정렬된 결과 완성
- 병합 정렬의 단순하고 효과적인 활용 사례

---

## 📌 여러 Pass가 필요한 경우

- Run 수가 메모리보다 많은 경우 (`N ≥ M`)
- 각 Pass에서 M - 1개의 Run을 병합
- 예: `M = 11`, `Run = 90` → Pass 1에서 Run 수가 9로 감소

- **매 Pass마다 Run 수는 `M - 1`로 나눈만큼 줄어듦**
- 마지막 Pass에서 전체를 1개 Run으로 병합

---

## 📌 예시 (M = 3)

1. 초기 Run 생성 (메모리로 3개씩 읽어 정렬)
2. Pass 1: 2개씩 병합 → 중간 Run 생성
3. Pass 2: 중간 Run 병합 → 최종 정렬 출력

---

## 📌 요약
- External Sort-Merge는 대용량 데이터 정렬에 적합
- 정렬 후 출력이 정렬된 순서로 유지되며, Join, Duplicate 제거, Grouping 등에 사용됨

## 📌 External Merge Sort – Cost Analysis

### 🔹 기본 개념
- `bᵣ`: relation `r`을 저장하는 총 블록 수
- 초기 Run 생성 시 필요한 I/O: `2bᵣ` (읽기 + 정렬 후 쓰기)
- Run 수: `bᵣ / M`
- Merge pass 수: `⌈log_{M−1}(bᵣ / M)⌉`
- 각 pass에서 block transfer는 `2bᵣ`
- 최종 pass는 output을 디스크에 쓰지 않고 다음 연산으로 넘길 수 있으므로 제외 가능

> 총 block transfer:
``2bᵣ (⌈log_{M−1}(bᵣ / M)⌉ + 1)``

---

### 🔹 블록 당 하나의 버퍼를 쓰는 경우 seek 비용 증가
- `bᵣ / b_B`개씩 묶어서 `M`을 새롭게 대체 → seek 수 줄이기
- 버퍼 블록 수에 따라 블록 단위 읽기/쓰기 적용

---

### 🔹 Seek 비용
- Run 생성 시: `2 ⌈bᵣ / M⌉` seeks (읽기 + 쓰기)
- Merge 시: 각 pass마다 `2 ⌈bᵣ / b_B⌉` seeks
- 전체 pass 수에서 마지막 pass 제외

> 총 seeks:
``2 ⌈bᵣ / M⌉ + ⌈bᵣ / b_B⌉ (2 ⌈log_{M / b_B}(bᵣ / M)⌉ − 1)``

---

## 📌 Join Operation – 개요

### 🔹 대표 Join 알고리즘
- Nested-loop join
- Block nested-loop join
- Indexed nested-loop join
- Merge-join
- Hash-join

> 선택은 **비용 추정 기반**

---

### 🔹 예제 데이터 기준
- student: 5,000 레코드, 100 블록
- takes: 10,000 레코드, 400 블록

---

## 📌 Nested-Loop Join

### 🔹 정의 및 동작
- `r ⋈_θ s` 수행 시:
for each tᵣ in r:  
for each tₛ in s:  
if θ(tᵣ, tₛ): 결과에 추가
- `r`: outer relation, `s`: inner relation
- 조건 없이 사용할 수 있으나 비용이 큼

---

### 🔹 비용 분석
- 최악의 경우 (블록 1개씩만 메모리에 적재 가능 시):
  - 블록 전송: `nᵣ * bₛ + bᵣ`
  - seek: `nᵣ * bₛ`

#### 예시:
- student가 outer일 때: `5000 * 400 + 100 = 2,000,100 block transfers`, `5000 * 100 = 5100 seeks`
- takes가 outer일 때: `10,000 * 100 + 400 = 1,000,400 block transfers`, `10,000 * 400 = 10,400 seeks`

---

### 🔹 메모리 최적화
- inner relation이 메모리에 적재되면:
  - 블록 전송: `bᵣ + bₛ`
  - seek: 2
## Block Nested-Loop Join
- **기본 개념**: 외부 릴레이션의 각 블록마다 내부 릴레이션의 모든 블록과 조인을 수행하는 방식
- **의사코드 구조**:
  - 외부 릴레이션 `r`의 각 블록 `Bᵣ`에 대해
  - 내부 릴레이션 `s`의 각 블록 `Bₛ`에 대해
  - `Bᵣ` 내의 튜플 `tᵣ`와 `Bₛ` 내의 튜플 `tₛ`가 조인 조건을 만족하면 결과에 추가
- **비용**:
  - 최악의 경우: `bᵣ * bₛ + bᵣ` 블록 전송 + `2 * bᵣ` 탐색
  - 최선의 경우: `bᵣ + bₛ` 블록 전송 + 2 탐색
- **개선**: 
  - 블록 단위로 묶어 메모리의 `M` 블록 중 2블록을 제외한 `M-2`를 outer relation에 할당
  - 개선된 비용: `⌈bᵣ / (M-2)⌉ * bₛ + bᵣ` 블록 전송 + `2⌈bᵣ / (M-2)⌉` 탐색

## Indexed Nested-Loop Join
- **조건**:
  - 조인 조건이 equi-join 또는 natural join
  - 내부 릴레이션 `s`의 조인 속성에 인덱스 존재
- **동작**:
  - 외부 릴레이션 `r`의 각 튜플 `tᵣ`에 대해, 인덱스를 사용하여 `s`에서 일치하는 튜플 탐색
- **비용 (최악)**:
  - `bᵣ + (tᵣ + tₛ) + nᵣ * c`
    - `c`: 인덱스를 통해 `s`에서 조건 만족하는 튜플을 찾는 비용
    - 실질적으로 selection 조건 하나의 비용으로 근사 가능
- **전략**: 인덱스가 양쪽에 다 있을 경우 튜플 수가 적은 릴레이션을 outer로 사용

## 예시: Nested-Loop Join Cost 비교
- `student ⋈ takes` 조인, `student`가 outer
- `takes`는 ID 속성에 대한 primary B⁺-tree index 존재
- `takes`: 10,000 튜플, B⁺-tree 높이 = 4
- `student`: 5,000 튜플
- 블록 수: `student` = 100, `takes` = 400
- **블록 기반 nested-loop**:
  - 비용: `400 * 100 + 100` = 40,100 블록 전송, 탐색 2회 → 약 200 탐색
- **인덱스 기반 nested-loop**:
  - 비용: `100 + 5000 * 5` = 25,100 블록 전송 및 탐색 → 탐색 수 증가

## Sort-Merge Join
- **절차**:
  1. 조인 속성 기준으로 양 릴레이션 정렬 (이미 정렬되어 있다면 생략)
  2. 정렬된 릴레이션을 병합 (Merge)
- **핵심 처리**:
  - 조인 속성 값이 중복될 수 있기 때문에 동일 값 가진 모든 튜플 쌍 매칭 필요
- **사용 용도**: equi-join 및 natural join에 적합
- **비용**: `bᵣ + bₛ` 블록 전송 + 정렬 비용 (정렬 필요 시)

## Hash-Join
- **적용 가능 조건**: equi-join 및 natural join에 적합함
- **기본 원리**:
  - 해시 함수 `h`를 사용하여 두 릴레이션의 조인 속성(`JoinAttrs`)을 기준으로 튜플들을 파티셔닝함
  - `r`의 튜플은 `r₀, r₁, ..., rₙ`으로 나뉘고, 각 튜플 `tᵣ ∈ r`는 `rᵢ`에 저장됨  
    → 이때 `i = h(tᵣ[JoinAttrs])`
  - `s`의 튜플도 마찬가지로 `s₀, s₁, ..., sₙ`으로 나뉘며, `tₛ ∈ s`는 `sᵢ`에 저장됨  
    → 이때 `i = h(tₛ[JoinAttrs])`

## Hash-Join (Cont.)
- **시각적 구조**:
  - 릴레이션 `r`과 `s` 각각을 동일한 해시 함수로 파티셔닝함
  - 동일한 해시값 `i`를 가진 튜플은 `rᵢ`와 `sᵢ`에 들어가며, 이 두 파티션끼리만 조인 비교가 수행됨

## Hash-Join (Cont.)
- **비교 최적화**:
  - `rᵢ`의 튜플은 `sᵢ`의 튜플과 **만** 비교하면 됨
  - 다른 파티션과는 비교할 필요 없음
- **이유**:
  - 조인 조건을 만족하는 튜플은 동일한 조인 속성 값을 가짐
  - 동일한 해시 함수로 인해 같은 값은 항상 같은 파티션에 매핑됨

## Hash-Join Algorithm
- `r`과 `s`에 대한 해시 조인은 다음 단계로 수행됨:
1. 릴레이션 `s`를 해시 함수 `h`를 사용하여 파티션으로 분할함  
   → 각 파티션마다 출력 버퍼로 블록 하나를 예약함
2. 릴레이션 `r`도 동일하게 분할함
3. 각 파티션 `i`에 대해:
   (a) `sᵢ`를 메모리에 로드하고 조인 속성을 기준으로 인메모리 해시 인덱스를 구성함  
   → 이때 사용되는 해시 함수는 이전과는 다른 것
   (b) `rᵢ`를 디스크에서 읽고, 각 튜플 `tᵣ`에 대해 `sᵢ`에서 일치하는 튜플 `tₛ`를 해시 인덱스로 탐색함  
   → 일치 시 조인 결과 생성

- **용어 구분**:
  - `s`: build input
  - `r`: probe input

## Cost of Hash-Join
- 재귀적 파티셔닝이 **필요 없는 경우**:
  - **비용** = `3(bᵣ + bₛ) + α` (블록 전송 비용) + `2(⌈bᵣ/bᵢ⌉ + ⌈bₛ/bᵢ⌉)` (seek 횟수)
    - `bᵣ`, `bₛ`: `r`, `s`의 블록 수
    - `bᵢ`: 입력/출력 버퍼에 할당된 블록 수
    - `α`: 부분적으로 채워진 블록 처리 오버헤드
  - **분해**:
    - 파티셔닝: `2(bᵣ + bₛ)`
    - 빌드 및 프로브 단계: `(bᵣ + bₛ)`
- 메모리에 build input 전체가 올라가는 경우 → 파티셔닝 생략 가능  
  → 비용은 `bᵣ + bₛ`로 단순화

## Example of Cost of Hash-Join
- **조인**: `instructor ⋈ teaches`
- **가정**:
  - 메모리 크기 = 20 블록
  - `b_instructor` = 100, `b_teaches` = 400
  - `instructor`는 build input으로 사용 → 20 블록짜리 5개 파티션
  - `teaches`도 동일하게 80 블록씩 5개 파티션
- **파티셔닝은 한 번의 패스로 가능**
- **총 비용 계산** (부분 블록 무시):
  - 블록 전송: `3(100 + 400)` = 1500
  - seek: `2(⌈100/3⌉ + ⌈400/3⌉)` = 2(34 + 134) = **336 seeks**
    - `bᵢ` = 3 (입력용)
    - 출력 버퍼 수 = 5

## Complex Joins
- **Conjunctive 조건**:  
  `r ⋈_{θ₁ ∧ θ₂ ∧ ... ∧ θₙ} s`
  - nested-loop 또는 block nested-loop 사용 가능
  - 또는 단순한 조인(`r ⋈_{θᵢ} s`) 결과를 계산한 후, 해당 결과에 남은 조건을 적용함

- **Disjunctive 조건**:  
  `r ⋈_{θ₁ ∨ θ₂ ∨ ... ∨ θₙ} s`
  - nested-loop 또는 block nested-loop 사용 가능
  - 또는 각 조건에 대해 개별 조인을 수행한 뒤 결과를 합집합:  
    `(r ⋈_{θ₁} s) ∪ (r ⋈_{θ₂} s) ∪ ... ∪ (r ⋈_{θₙ} s)`

## Other Operations
- **중복 제거 (distinct)**:
  - 정렬 또는 해싱으로 구현 가능
    - 정렬 시 인접한 중복값 중 하나만 남김
    - 해싱 시 동일한 버킷에 들어간 중복값을 하나로 축소함

- **프로젝션 (projection)**:
  - 각 튜플에 대해 프로젝션 적용 후 중복 제거 진행

## Other Operations : Set Operations
- **집합 연산 (`∪`, `∩`, `−`)**:
  - 정렬 기반 merge-join 방식, 또는 해시 조인 기반 방식 사용 가능
  - 해시를 이용한 방법:
    1. 두 릴레이션을 동일 해시 함수로 파티셔닝
    2. 각 파티션에 대해 처리
       - `r ∪ s`:  
         1. `sᵢ`의 튜플을 해시 인덱스에 추가  
         2. 마지막에 인덱스의 튜플들을 결과에 추가
       - `r ∩ s`:  
         - `sᵢ`에서 해시 인덱스에 존재하는 튜플만 결과에 추가
       - `r − s`:  
         - `sᵢ`의 튜플을 해시 인덱스에서 삭제한 뒤 남은 튜플을 결과에 추가

## Other Operations : Outer Join
- **Outer join 구현 방식**:
  - non-matching 튜플에 `null`을 추가한 조인 수행
- **Merge join 기반 outer join**:
  - `r ⟕ s`:  
    - `r`의 튜플이 `s`와 매칭되지 않으면 `null`로 채워서 출력
  - `r ⟖ s`:  
    - `s`가 build이고 매칭되지 않는 `s` 튜플에 `null`을 붙여 출력
  - full outer join은 위 방식들을 조합하여 구현 가능

## Other Operations : Aggregation
- **Aggregation 연산**은 중복 제거와 유사하게 구현 가능
  - 예:  
    `select dept_name, avg(salary) from instructor group by dept_name`
- **정렬 또는 해싱**을 통해 동일 그룹을 묶은 후 집계 함수 적용
- **on-the-fly 연산 지원**:
  - `count`, `min`, `max`, `sum`: 튜플들을 읽으며 누적 계산
  - `avg`: sum과 count를 유지한 후 마지막에 나누기

## Evaluation of Expressions
- **복합 연산 평가 방식**:
  - **Materialization**: 중간 결과를 저장하여 재사용
  - **Pipelining**: 여러 연산을 동시에 평가하여 메모리 효율화

## Materialization
- **Materialized evaluation**:  
  - 연산을 하나씩 순차적으로 수행하고, 중간 결과를 임시 릴레이션 형태로 저장함
  - 다음 연산 단계는 이 임시 릴레이션을 입력으로 사용
- **예시**:
  1. `σ_{building="Watson"}(department)` 계산 후 디스크에 저장
  2. 저장된 결과와 `instructor`를 조인
  3. 마지막으로 `Π_name`으로 프로젝션 수행

## Materialization (Cont.)
- **항상 적용 가능**한 평가 방식
- 단점:
  - 디스크 입출력 비용이 큼 (중간 결과 쓰기 및 다시 읽기)
- **Double buffering** 기법:
  - 각 연산마다 두 개의 출력 버퍼 사용
  - 하나가 꽉 차면 디스크에 쓰는 동안 다른 하나는 계속 데이터 수신
  - 디스크 작업과 계산을 병행하여 실행 시간 절감 가능

## Pipelining
- **Pipelined evaluation**:
  - 여러 연산을 동시에 실행하며 결과를 다음 연산으로 바로 전달
  - 중간 결과를 저장하지 않고 직접 다음 연산에 전달
- **예시**:
  - `σ_{building="Watson"}(department)` 결과를 저장하지 않고 바로 join 연산에 넘김
  - join 결과도 저장하지 않고 바로 projection 연산에 전달
- **장점**: materialization보다 훨씬 효율적 (디스크 저장 불필요)
- **단점**: 일부 연산(ex. sort, hash-join)에서는 적용 불가
- **파이프라인 실행 방식**:
  - **Demand-driven** (pull)
  - **Producer-driven** (push)

## Pipelining (Cont.)
- **Demand-driven (lazy evaluation)**:
  - 상위 연산자가 다음 튜플을 요구하면 하위 연산자에게 요청을 전달함
  - 각 연산자는 다음에 반환할 튜플을 알기 위해 상태(state)를 유지해야 함

- **Producer-driven (eager evaluation)**:
  - 연산자가 가능한 한 많은 튜플을 생성하여 부모 연산자에게 전달
  - 연산자 사이에 버퍼 존재
    - 자식 연산자는 버퍼에 공간이 있을 때까지 튜플 생성
    - 부모 연산자는 버퍼에서 튜플을 가져감
- **다른 명칭**:
  - Pull model = demand-driven
  - Push model = producer-driven

