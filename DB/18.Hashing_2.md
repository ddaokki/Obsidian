## 📌 Dynamic Hashing

### 🔹 개요
- **정적 해싱의 한계**(버킷 수 고정, 재해싱 필요 등)를 해결하기 위한 방식
- 데이터베이스 크기가 동적으로 변해도 **효율적인 버킷 관리가 가능**함

### 🔹 Linear Hashing
- 재해싱을 **점진적으로(incremental)** 수행하는 방식
- 특정 overflow bucket이 생길 때마다 점진적으로 버킷을 분할함
- 디렉토리 구조를 사용하지 않고도 확장 가능함

### 🔹 Extendible Hashing
- **디스크 기반 시스템에 적합하게 설계됨**
- 여러 해시값이 하나의 bucket을 공유할 수 있음
- 디렉토리 기반으로 구현되며, 버킷 분할 시 디렉토리도 함께 확장됨

### 🔹 동적 해싱의 기본 아이디어
- **버킷 수 또는 디렉토리 크기를 두 배로 늘리면서 확장**
- 버킷 자체를 복사하는 것이 아니라, **버킷 포인터를 모은 디렉토리를 조작**
- 핵심:
  - 디렉토리를 이용해 간접적으로 버킷을 참조함
  - overflow가 발생한 버킷만 분할(split)
  - 전체 해시 함수가 아니라 **일부 비트(prefix/postfix)의 길이만 변경**

- 💡 핵심 포인트: **해시 함수의 결과를 어떻게 해석하느냐**에 따라 유연한 조정이 가능함

## 📌 Extendible Hashing

### 🔹 해시 키의 접미사(postfix) 사용
- 해시 함수의 전체 결과가 아닌, **일부 하위 비트(i bits)**만 사용함
- 해석 방식: `i`비트의 접미사를 사용하여 디렉토리 인덱스를 계산

### 🔹 디렉토리 크기
- 디렉토리의 크기는 $2^i$이며, `i`는 **global depth**를 나타냄
- 초기에는 `i = 0`에서 시작하며, 필요에 따라 **i가 증가하거나 감소**함

### 🔹 구조의 유연성
- **여러 디렉토리 항목이 같은 bucket을 가리킬 수 있음**
  - 예: `00`, `01` 모두 동일한 bucket을 가리키는 경우
- 실제 bucket의 개수는 $2^i$보다 작을 수 있음

### 🔹 Bucket 개수의 동적 변화
- bucket은 **overflow 발생 시 분할되고(split)**, **공간이 비면 병합(coalesce)**될 수 있음
- 이로 인해 전체 bucket 수는 데이터베이스 크기에 맞춰 자동으로 조절됨

## 📌 General Extendible Hash Structure

### 🔹 구조 설명
- 왼쪽은 **디렉토리(bucket address table)**로, 각 항목은 특정 prefix에 해당
- 오른쪽은 **bucket**이며, 각각 로컬 깊이(local depth)를 가짐

### 🔹 Global depth vs Local depth
- **Global depth (i)**:
  - 디렉토리의 전체 크기를 결정함 ($2^i$)
  - 해시 키의 하위 `i`비트를 사용해 디렉토리 인덱스를 계산
- **Local depth (i₁, i₂, ...)**
  - 각 bucket이 실제로 구분되는 비트 수
  - 만약 로컬 깊이 < 글로벌 깊이라면, 해당 bucket은 여러 디렉토리 항목에 공유됨

### 🔹 분할 조건
- 버킷이 가득 차면:
  - **local depth < global depth**: 디렉토리 수정 없이 해당 버킷만 분할 가능
  - **local depth = global depth**: 디렉토리 크기를 **2배로 증가**시켜야 함 (global depth 증가)

### 🔹 동작 예시
- 예: `i = 2`일 때 디렉토리 크기는 4
  - `00`, `01` → bucket 1 (i₁ = 1)
  - `10` → bucket 2 (i₂ = 2)
  - `11` → bucket 3 (i₃ = 2)
- 즉, bucket 1은 local depth가 작아서 여러 prefix를 공유하고 있음

### 🔹 요약
- Extendible hashing은 bucket 개수와 디렉토리 크기를 **독립적으로 동적으로 관리**할 수 있음
- 분산과 재구성이 **부분적으로 이루어지므로 효율적이며**, 공간 낭비 없이 overflow를 관리할 수 있음

## 📌 Extendible Hashing – How it Works

### 🔹 디렉토리와 Global Depth
- 디렉토리는 해시 결과를 기반으로 **bucket을 가리키는 포인터 배열**
- 디렉토리 크기는 $2^G$이며, 여기서 $G$는 **global depth** (전체 디렉토리의 비트 수)
- 예시: $G = 2$이면 디렉토리 크기는 4이며, 해시 키의 하위 2비트를 사용하여 디렉토리 인덱스를 결정함

### 🔹 디렉토리 탐색 방법
- 어떤 키 $K$가 들어왔을 때, 해시 함수 $h(K)$를 계산
- 하위 $G$비트를 추출해 디렉토리 인덱스를 결정함 (`h(K) mod 2^G`)
- 예시:
  - $h(K) = 5 = 0101_2$ → 디렉토리 인덱스 = `01` → 해당 버킷으로 접근
  - $h(K) = 7 = 0111_2$ → 인덱스 = `11` → 해당 버킷으로 접근

## 📌 Extendible Hashing – Bucket Split

### 🔹 버킷 분할 조건
- 새로운 값을 삽입하려 할 때 버킷이 **가득 차있고**, 해당 버킷에 **여러 디렉토리 항목이 매핑되어 있다면**
  - 즉, **local depth < global depth**라면
- 다음 절차를 통해 **부분적으로 분할** 수행

### 🔹 Bucket Split 절차
1. **새로운 버킷을 할당**하고 기존 버킷과 구분되도록 local depth를 증가시킴  
   → $L := L + 1$
2. 디렉토리에서 해당 버킷을 가리키던 일부 인덱스를 새 버킷으로 변경함
3. 원래 버킷에 있던 레코드들을 **해시값 재확인 후** 적절한 버킷으로 재분배
4. **해당 버킷이 여전히 가득 차 있다면**, 추가적인 split 필요

### 🔹 예시 상황
- 디렉토리 $G = 2$, 즉 디렉토리 인덱스는 `00`, `01`, `10`, `11` 존재
- `Insert 1101` 시도 → `01`에 매핑 → 해당 버킷 가득 참 → split 필요

## 📌 Extendible Hashing – Split 후 구조 변화

### 🔹 Split 이후 구조 예시
- overflow가 발생한 `01` 인덱스가 가리키는 버킷을 분할함
- 기존 bucket의 local depth $L=1$ → split 후 $L=2$
- 디렉토리에서 `01`을 가리키던 두 인덱스 중 일부를 **새 버킷**으로 분기시킴

### 🔹 분할 결과
- 기존 bucket에는 `0001`, `0101` 저장
- 새 bucket에는 `0111`, `1111` 저장
- **디렉토리 포인터가 일부는 기존 버킷, 일부는 새로운 버킷을 가리키게 됨**
- 디렉토리의 global depth $G$는 변하지 않고, **부분적 분할만 수행**되므로 효율적임

### 🔹 핵심 요약
- Extendible Hashing의 장점은 전체 구조를 재조정하지 않고도 **부분적으로 확장 가능**하다는 점임
- bucket 마다 local depth를 따로 관리함으로써 **유연하고 정교한 확장**이 가능함

## 📌 Extendible Hashing – Directory Doubling (G = L인 경우)

### 🔹 디렉토리 확장 조건
- bucket overflow 발생 시:
  - 만약 해당 bucket이 **하나의 디렉토리 항목만**에 의해 참조되고 있다면 (`G = L`)
  - → 디렉토리 전체가 확장되어야 함

### 🔹 Directory Doubling 절차
1. **Global depth (G)**를 1 증가시킴
2. 디렉토리의 크기를 **2배로 확장** ($2^{G+1}$)
3. 기존 디렉토리의 각 엔트리를 **두 개로 복사하여 확장된 디렉토리에 배치**
   - 예: `01` → `001`, `101` 둘 다 같은 버킷 가리키도록 설정
4. 그 후 **기존과 같은 bucket split 방식** 적용 가능 (G > L이 됨)

### 🔹 예시
- 기존 $G=2$에서 overflow 발생 → 디렉토리를 $G=3$으로 증가
- 디렉토리 엔트리 4개 → 8개로 확장됨
- 이때 각 기존 포인터는 **두 개의 새로운 포인터로 복제됨**

### 🔹 효과
- 디렉토리 구조 자체는 커지지만, bucket 분할은 **국소적으로만 발생**
- 레코드 재배치는 최소화되고, 확장은 유연하게 수행됨

## 📌 Extendible Hashing vs. Other Schemes

### ✅ 장점 (Advantages)
- 파일 크기가 커져도 해시 성능이 **급격히 저하되지 않음**
- bucket overflow를 효과적으로 방지 가능
- 필요한 bucket만 분할 → **공간 효율성 높음**
- 디렉토리를 통해 유연한 bucket 재조정 가능

### ❌ 단점 (Disadvantages)
- **간접 참조** 단계가 존재 → 원하는 레코드에 접근 시 오버헤드 발생
- 디렉토리(bucket address table)가 커질 수 있음
  - 메모리보다 클 경우, 디스크에 저장 필요
  - 연속된 공간 할당이 어려운 경우 B⁺-Tree 등으로 대체 가능
- 디렉토리 크기 조절(두 배 확장)은 **고비용 연산**

### 🔁 Linear Hashing과의 비교
- Linear Hashing은 **점진적 확장**이 가능함
- 디렉토리 없이 구현할 수 있지만, **bucket overflow가 더 자주 발생**할 수 있음
- Extendible Hashing은 **즉각적인 확장 및 분할**이 가능하므로 더 정교한 제어 가능

### 📌 요약
| 기준 | Extendible Hashing | Linear Hashing |
|------|---------------------|----------------|
| 확장 방식 | 즉각적 + 디렉토리 기반 | 점진적 |
| overflow 방지 | 비교적 강함 | 약함 |
| 구현 복잡도 | 다소 높음 | 단순함 |
| 공간 효율 | 높음 | 중간 |
| 레코드 접근 오버헤드 | 있음 (indirection) | 낮음 |



## 📌 Linear Hashing – a lazy approach

### 🔹 개요
- Linear Hashing은 **디렉토리 없이** 해시 구조를 점진적으로 확장할 수 있는 **동적 해싱 기법**
- overflow bucket이 생기면 **순차적(round-robin)** 으로 기존 bucket을 하나씩 분할하며 확장

### 🔹 기본 아이디어
- overflow 페이지는 일시적으로 허용함
- 현재 포인터(`Next`)가 가리키는 bucket을 분할하고, 이후 `Next`를 다음 bucket으로 이동시킴
- 분할은 overflow가 발생한 bucket이 아닌, **사전에 정해진 순서의 bucket**에서 수행됨

### 🔹 해시 함수 계열 사용
- $h_0(k) = h(k) \mod (2^0N)$  
- $h_1(k) = h(k) \mod (2^1N)$  
- ...
- 분할이 발생할수록 $h_i$ → $h_{i+1}$ 로 진화함 (bucket 수 증가)

## 📌 Linear Hashing – Algorithm

### 🔹 라운드 기반 확장 구조
- 전체 동작은 **round 단위**로 진행되며, 현재 라운드를 `Level`이라 표현
- 각 라운드마다 총 bucket 수는:  
  $N_{Level} = N \times 2^{Level}$  
  - 여기서 $N$은 초기 bucket 수

### 🔹 분할 포인터 `Next`
- 각 round에서 `Next`는 아직 분할되지 않은 bucket을 가리킴
- 분할이 발생할 때마다 `Next`가 1씩 증가
- round가 종료되는 시점: `Next = N_{Level}`  
  → 모든 bucket이 한 번씩 분할된 상태

### 🔹 다음 라운드로 진입
`cpp
`Level++;   // 라운드 증가
`Next = 0;  // 다음 라운드의 시작 bucket으로 초기화

### 🔹 요약

- Linear Hashing은 정해진 bucket부터 순차적으로 확장하므로 **구조가 간단하고 구현이 쉬움**
    
- 다만, overflow가 발생한 bucket이 즉시 분할되지 않아 **일시적으로 긴 overflow 체인**이 생길 수 있음

## 📌 Linear Hashing – Insert 과정

### 🔹 삽입 로직
1. **해당 키 값의 해시 위치를 찾고**, bucket에 공간이 있다면 삽입
2. 공간이 없을 경우:
   - 임시 overflow 페이지에 저장
   - **주의**: 이때 분할되는 것은 overflow 발생한 bucket이 아님!

### 🔹 분할 동작
- 항상 `Next` 포인터가 가리키는 bucket이 분할됨
- 이후 `Next++`를 수행하여 다음 bucket을 가리키도록 함

This is likely NOT the bucket that just overflowed!
- 분할 후 해당 bucket에 있는 엔트리는 다음 해시 함수 $h_{Level+1}$ 기준으로 **재배치**
    

### 🔹 결과적 특성

- round-robin 방식으로 분할이 진행되기 때문에, **일부 bucket에 overflow가 많이 쌓일 수 있음**
    
- Linear Hashing은 구현이 간단하지만, **초기에는 overflow에 덜 민감하게 반응**함
    

### 🔹 요약

| 항목    | 설명                                      |
| ----- | --------------------------------------- |
| 디렉토리  | 없음                                      |
| 분할 기준 | overflow 발생 시 `Next`가 가리키는 bucket       |
| 해시 함수 | $h_i(k) = h(k) \mod (2^iN)$             |
| 장점    | 구현이 단순, 점진적 확장 가능                       |
| 단점    | overflow 발생 bucket이 바로 분할되지 않아 성능 저하 가능 |

## Linear Hashing – How it Works: Overview
Linear Hashing에서는 버킷을 순차적으로 나누어 확장함. 각 라운드(round)에는 `Next` 포인터가 존재하며, 이 포인터는 분할될 다음 버킷을 가리킴.

- 현재 라운드에서 존재했던 초기 버킷 수:  
  `N_Level = N × 2^Level`
- `Next` 포인터가 가리키는 버킷은 `이번 라운드에서 분할될 대상`이며, 해당 버킷의 항목은 `h_{Level+1}`을 사용해 분할된 버킷(split image bucket)으로 이동할 수 있음
- 이전 라운드에서 생성된 버킷은 split image 영역에 있으며, 해시 결과가 이 범위에 포함되면 `h_{Level+1}`로 재해싱함

요약하면:
- 기존 해시 함수 `h_Level`의 결과가 `Next`보다 작으면 이미 분할된 영역 → `h_{Level+1}`로 재해싱
- 그렇지 않으면 기존 bucket에 그대로 접근

## Linear Hashing – Insert 예시: Insert 43 (101011₂)

초기 상태: `Level = 0`, `N = 4`, `h_0(key) = key mod 4`

- 43 (101011₂)은 `h₀(43) = 3`, 즉 마지막 버킷에 삽입 시도
- 하지만 해당 버킷은 이미 가득 찼으므로, overflow page에 43을 임시로 저장함
- 이 시점에서 overflow가 발생했기 때문에 `Next = 0`이 가리키는 첫 번째 버킷을 분할함
- 분할된 값들 중 일부는 split image 버킷으로 이동함 (44, 36)

이 구조는 overflow 발생과 분할이 반드시 같은 버킷에서 일어나지 않음을 보여줌

## Linear Hashing – Insert 예시: Insert 6 (110₂)

- 6은 `h₀(6) = 2`이므로 세 번째 버킷으로 이동
- 해당 버킷은 가득 차 있어 overflow page에 임시 저장됨
- overflow가 발생했으므로 `Next = 1`인 두 번째 버킷을 분할
- 이때 분할된 항목 중 일부는 split image bucket으로 이동 (예: 5)

삽입과 분할 대상이 다른 bucket이라는 점이 핵심이며, 순차 분할 정책이 잘 드러나는 예시임

	## Linear Hashing – Insert 예시: Insert 65 (1000001₂)

- 65의 `h₀(65) = 1`, 해당 bucket이 가득 찼음
- overflow page에 저장한 뒤 `Next = 2` 버킷을 분할
- 분할 결과 일부 값들은 split image bucket으로 재배치됨
- 이후 `Next`가 증가하여 다음 분할 대상으로 이동

이처럼 overflow는 삽입된 버킷이 아닌, 분할 순서에 따라 별도의 버킷에서 발생함
→ hash값과 bucket mapping이 단순하지 않기 때문에 `h_Level`과 `h_{Level+1}`의 구분이 중요함

## Linear Hashing Search Algorithm

- 데이터 항목 `r`이 속한 bucket을 찾기 위해 `h_Level(r)`을 계산함

### Buckets not yet split this round
- `h_Level(r) >= Next`인 경우: 아직 분할되지 않은 bucket에 속함 → `r`은 해당 bucket에 존재

### Buckets split already this round
- `r`은 `h_Level(r)` 또는 `h_Level(r) + N_Level` 버킷 중 하나에 속할 수 있음
- 이 경우 `h_{Level+1}(r)`을 적용하여 실제 bucket을 결정해야 함


## Linear Hashing – Insert/Search 예시: Search 5 (00101₂)

- 5를 삽입/검색할 때 `h_0(5) = 1` → 두 번째 버킷(`bucket 1`)로 이동
- 하지만 `bucket 1`은 이미 분할되었고, `Next < h_0(5)`이므로  
  `h_1(5)` = 5 → `bucket 5`에서 확인해야 함
- 이 bucket은 split image bucket으로, 분할 과정 중 만들어진 버킷임
- 최종적으로 `5`는 bucket 5에서 검색됨

## Ordered Indexing vs. Hashing

- 해싱과 정렬 인덱스 방식의 비교는 다음과 같은 기준에 기반함

### 비교 기준
- 주기적인 재조직 비용
- 삽입/삭제의 상대적 빈도
- 평균 접근 시간 최적화와 최악 접근 시간 간의 균형
- 예상되는 질의 유형:  
  - point query → 해싱이 유리  
  - range query → 정렬 인덱스가 유리

### 실무 관점
- PostgreSQL: 해시 인덱스를 지원하나 성능 문제로 비권장
- Oracle: 정적 해시 파일은 지원하지만 해시 인덱스는 제공하지 않음
- SQLServer: B⁺-트리만 지원
## Multiple-Key Access and Bitmap Index

- 여러 인덱스를 동시에 사용하는 질의 처리 전략이 있음
- 예시 질의:
  `select ID from instructor where dept_name = "Finance" and salary = 80000`

- 단일 속성 인덱스를 활용한 질의 처리 전략:
  1. `dept_name`에 대한 인덱스를 사용하여 "Finance" 부서의 강사를 찾고, 그 결과에서 `salary = 80000`인지를 검사함
  2. `salary`에 대한 인덱스를 사용하여 연봉이 80000인 강사를 찾고, 그 결과에서 `dept_name = "Finance"`인지를 검사함

## Bitmap Index 개념

- Bitmap 인덱스는 다중 키에 대한 효율적인 질의를 위해 설계됨
- 레코드는 `0`부터 순차적으로 번호가 매겨져 있다고 가정
  - 예: 고정 크기 레코드일 경우 특정 번호의 레코드를 찾기 쉬움
- 소수의 상이한 값을 가지는 속성에 적용 가능
  - 예: gender, country, state, income level 등
- 비트맵은 단순히 비트의 배열임

## Bitmap Index 예시 설명

- 각 속성 값마다 하나의 비트맵을 가짐
  - 비트맵의 비트 수 = 레코드 수
  - 어떤 속성 값 `v`에 대한 비트맵에서, 해당 속성 값이 `v`인 레코드의 비트는 1이고 나머지는 0임

- 예시 테이블:

| record# | ID    | gender | income_level |
| ------: | ----- | ------ | ------------ |
|       0 | 76766 | m      | L1           |
|       1 | 22222 | f      | L2           |
|       2 | 12121 | f      | L1           |
|       3 | 15151 | m      | L4           |
|       4 | 58583 | f      | L3           |


- 비트맵 예시:
  - gender = m: `10010`
  - gender = f: `01101`
  - income_level = L1: `10100`
  - income_level = L2: `01000`
  - income_level = L3: `00001`
  - income_level = L4: `00010`
  - income_level = L5: `00000`

## Multiple-Key Access and Bitmap Index

- 다중 속성 질의에 대해 여러 개의 인덱스를 사용하는 방식임
- 예시 질의:
  `select ID from instructor where dept_name = "Finance" and salary = 80000`
- 단일 속성 인덱스를 사용하는 가능한 처리 전략:
  1. `dept_name` 인덱스를 사용하여 "Finance"에 해당하는 튜플을 찾고, 그 중에서 `salary = 80000` 조건을 필터링
  2. `salary` 인덱스를 사용하여 80000에 해당하는 튜플을 찾고, 그 중에서 `dept_name = "Finance"` 조건을 필터링

## Bitmap Index의 개념

- 비트맵 인덱스는 다중 키 질의 처리를 효율적으로 하기 위해 설계됨
- 레코드가 0번부터 순서대로 번호가 부여되어 있다고 가정함
  - 번호가 주어졌을 때 해당 레코드를 쉽게 찾을 수 있어야 함
  - 고정 크기 레코드일 경우 특히 쉬움
- 적용 가능한 속성:
  - 소수의 고유값을 가지는 속성: 성별, 국가, 주 등
  - 예: 소득 수준을 몇 개의 구간으로 나누어 표현 (e.g. 0–9999, 10000–19999 등)
- 비트맵은 단순히 비트들의 배열로 구성됨



