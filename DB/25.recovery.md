## Failure Classification
- **Transaction failure**:
  - **Logical errors**: 트랜잭션 내부 오류로 인해 완료할 수 없음
  - **System errors**: 시스템 오류(예: 데드락)로 인해 트랜잭션이 중단됨
- **System crash**: 정전 또는 하드웨어/소프트웨어 오류로 인해 시스템이 중단되는 경우
  - **Fail-stop 가정**: 비휘발성 저장 장치는 시스템 크래시로 인해 손상되지 않는다고 가정함
    - 데이터베이스 시스템은 디스크 데이터 손상 방지를 위한 무결성 검사 다수 수행
- **Disk failure**: 디스크 자체 손상으로 저장소 일부 혹은 전체가 파괴되는 경우
  - 디스크는 체크섬을 사용하여 오류 탐지 수행

## Recovery Algorithms
- 트랜잭션 `Tᵢ`가 계정 `A`에서 `B`로 $50을 이체한다고 가정할 때:
  - 두 개의 갱신이 발생함:
    - A에서 50을 차감
    - B에 50을 더함

- 트랜잭션 `Tᵢ`는 A와 B에 대한 갱신이 DB에 반영되어야 함
  - 실패가 두 갱신 중간에 발생할 수 있음
  - 비원자적 수정은 DB의 불일치 상태를 야기함
  - 트랜잭션 직후 실패 시 DB 미반영으로 인해 갱신 손실 발생 가능

- 회복 알고리즘은 두 부분으로 구성됨:
  1. 정상적인 트랜잭션 처리 중, 실패 복구를 위한 충분한 정보를 확보하는 조치
  2. 실패 발생 후, 데이터베이스를 원자성, 일관성, 지속성을 만족하는 상태로 복구하는 조치
  
## Data Access
- **Physical blocks**: 디스크에 저장되어 있는 블록을 의미함. 데이터베이스 시스템에서 실제 데이터를 저장하는 가장 기본적인 단위로, 디스크 I/O 연산의 대상이 됨.

- **Buffer blocks**: 메인 메모리(주기억장치)에 임시로 적재된 블록을 의미함. 디스크에서 데이터를 읽어 오거나 수정 후 디스크에 기록하기 전까지 이곳에 머무름.

### 블록 이동 (디스크 ↔ 메인 메모리)
- `input(B)` 연산:
  - 디스크에 있는 물리적 블록 `B`를 메인 메모리의 버퍼 블록으로 불러오는 작업.
  - 데이터 검색이나 수정 등 처리 작업을 위해 필수적으로 수행됨.

- `output(B)` 연산:
  - 메인 메모리에 있는 버퍼 블록 `B`의 내용을 디스크의 해당 위치에 다시 저장하는 작업.
  - 주로 트랜잭션 커밋 시나 수정된 데이터가 있을 경우 수행됨.

### 단순화된 가정
- 각 데이터 항목이 하나의 블록에 정확히 들어간다고 가정함:
  - 실제로는 하나의 블록에 여러 개의 데이터 항목이 들어갈 수 있음
  - 그러나 이 가정은 개념을 단순화하여 블록 단위 I/O를 이해하기 쉽게 만듦

### 추가 설명
- **버퍼 매니저(Buffer Manager)**:
  - 위 연산들은 모두 버퍼 매니저에 의해 자동으로 수행되며, DBMS 성능의 핵심 요소임
  - 디스크 I/O는 비용이 크기 때문에, 버퍼 매니저는 I/O 최소화를 위한 교체 알고리즘(LRU 등)을 사용함

- **쓰기 지연(Write-Back)**과 **즉시 쓰기(Write-Through)** 전략:
  - `output()`이 언제 발생하는지에 따라 변경 사항의 내구성 및 일관성에 영향


## 📌 Example of Data Access & Recovery Techniques
### 🔹 Example of Data Access
- 각 트랜잭션 `Tᵢ`는 자신만의 **작업 공간(work-area)**을 가지며, 이 안에는 접근한 데이터 항목의 **로컬 복사본**이 존재함
  - 예: `T₁`은 `X₁`, `Y₁`, `T₂`는 `X₂` 등의 복사본 사용

- 데이터 접근은 다음과 같은 단계로 이루어짐:
  - `read(X)`: 시스템 버퍼에서 데이터 항목 `X`의 값을 읽어 `Tᵢ`의 로컬 변수 `xᵢ`에 저장
  - `write(Y)`: 트랜잭션의 로컬 변수 `yᵢ` 값을 버퍼에 있는 데이터 항목 `Y`에 반영
  - `output(BX)`: 버퍼에 있는 블록 `BX`의 내용을 디스크로 복사 (즉시 수행되지 않아도 됨)

- 트랜잭션은 `read(X)`를 통해 **최초 접근 시 반드시 읽기**를 수행해야 하며,
  이후의 읽기는 로컬 복사본으로부터 가능함

- `write(X)`는 트랜잭션 commit 이전 어느 시점에서도 실행 가능함

---
### 🔹 Recovery and Atomicity
- 장애 발생 시에도 **원자성(Atomicity)**을 보장하기 위해, 실제 DB를 수정하기 전 **안정 저장소에 변경 정보를 출력**함
- 회복 기법은 크게 두 가지 방식으로 나뉨:
  1. **Log-based recovery**: 실제 DB 변경 전 로그를 남기고, 이후 로그 기반으로 회복
  2. **Shadow-copy / Shadow-paging**: 로그를 사용하지 않는 대안적 방식

- Shadow-copy 기법 예시:
  - (a) 업데이트 전: `db-pointer`는 기존 데이터베이스를 가리킴
  - (b) 업데이트 중: 새로운 복사본 생성, 포인터는 여전히 원본을 가리킴
  - (c) 업데이트 완료 후: 포인터를 새 복사본으로 변경하고, 원본 삭제 준비

---

### 🔹 Shadow Paging
- **Shadow paging**은 로그 없이도 복구 가능한 방식으로, **직렬 실행 환경**에서 유용함

- 기본 아이디어:
  - 트랜잭션 수행 중 **두 개의 페이지 테이블 유지**: `current page table`과 `shadow page table`
  - `shadow page table`은 **비휘발성 저장소**에 유지되며, 트랜잭션 시작 시의 상태를 복구할 수 있음

- 트랜잭션 수행 중:
  - 두 테이블은 동일하게 시작되며, 변경은 `current table`에만 반영됨
  - 어떤 페이지가 처음으로 변경될 경우:
    1. 해당 페이지의 복사본이 **새로운 공간에 생성됨**
    2. `current table`이 해당 복사본을 가리키도록 업데이트됨
    3. 실제 수정은 그 복사본에 대해 수행됨

- 장점:
  - 로그를 사용하지 않기 때문에 **로그 처리 비용이 없음**
  - 트랜잭션 실패 시 shadow table을 통해 **바로 복구 가능**

- 단점:
  - **동시성 지원이 어려움** (직렬적 실행에 적합)
  - 페이지 복사 오버헤드 존재

## 📌 Transaction Commit & Immediate Modification Recovery
### 🔹 Transaction Commit 정의
- 트랜잭션은 그에 대한 **commit 로그 레코드가 안정 저장소(stable storage)에 출력되었을 때** commit된 것으로 간주됨
- commit 시점까지 **모든 로그 레코드가 이미 기록되어 있어야 함**
- 단, 데이터에 대한 실제 쓰기(write)는 아직 버퍼에 있을 수 있으며, 이후 디스크로 출력될 수 있음

---

### 🔹 Immediate Database Modification 예시
**Log 기록**  
<T₀ start>  
<T₀, A, 1000, 950>  
<T₀, B, 2000, 2050>  
<T₀ commit>  
<T₁ start>  
<T₁, C, 700, 600>  
<T₁ commit>

- 쓰기 동작:  
  A = 950, B = 2050, C = 600  
- 출력 동작 예시:
  - `B_C`는 `T₁.commit` 이전에 출력됨
  - `B_A`는 `T₀.commit` 이후에 출력됨

- **중요 개념**: 로그 기반 복구에서는 쓰기 순서보다 로그 기록이 우선이며, 실제 데이터 출력은 지연될 수 있음

---

### 🔹 동시성 제어와 복구
- **공유 로그 및 버퍼 블록**을 사용함
- 하나의 항목을 수정한 트랜잭션 `Tᵢ`가 commit 또는 abort되기 전에는 **다른 트랜잭션이 해당 항목을 수정할 수 없음**
- 해결 방법:
  - 수정된 항목에 대해 **exclusive lock**을 부여하고, commit 또는 abort 시까지 유지  
  - 이는 **strict two-phase locking**에 해당함

---

### 🔹 Undo 및 Redo 연산
- **undo(Tᵢ)**: 로그의 마지막 레코드부터 역방향으로 읽어, `Tᵢ`가 수정한 데이터 항목을 이전 값으로 복원함  
  → `<Tᵢ, X, old_value>`가 로그에 기록됨  
  → 복원 후 `<Tᵢ, abort>` 로그 추가

- **redo(Tᵢ)**: 로그의 처음부터 순방향으로 읽어, `Tᵢ`가 수정한 데이터 항목을 새로운 값으로 다시 적용함  
  → 커밋된 트랜잭션에 대해서만 적용됨

---

### 🔹 장애 복구 조건
- 복구 시 로그를 기반으로 `undo` 또는 `redo` 여부 판단
- 트랜잭션 `Tᵢ`는 다음과 같은 경우 복구 대상임:
  - `undo`: `<Tᵢ, start>`는 있지만 `<Tᵢ, commit>` 또는 `<Tᵢ, abort>` 없음
  - `redo`: `<Tᵢ, start>`와 `<Tᵢ, commit>` 또는 `<Tᵢ, abort>` 모두 있음

---

### 🔹 복구 예시 정리
#### (a) 로그:  
<T₀ start>,  
<T₀, A, 1000, 950>,  
<T₀, B, 2000, 2050>
→ `T₀`는 커밋되지 않았으므로 **undo 수행**  
→ A = 1000, B = 2000으로 복구  
→ `<T₀, B, 2000>`, `<T₀, A, 1000>`, `<T₀ abort>` 기록

#### (b) 로그:  
- <T₀ commit>
- <T₁ start>, <T₁, C, 700, 600>
- → `T₀`는 **redo**, `T₁`은 **undo**  
→ A = 950, B = 2050, C = 700 복구  
→ `<T₁, C, 700>`, `<T₁ abort>` 기록
#### (c) 로그: 
<T₁ commit>
→ `T₀`, `T₁` 모두 commit 상태  
→ **둘 다 redo** 수행  
→ A = 950, B = 2050, C = 600 복구 완료

## 📌 Failure Recovery & Checkpoints
### 🔹 Recovering from Failure
- 만약 트랜잭션 `Tᵢ`가 이전에 `undo`되고 `<Tᵢ, abort>` 로그가 기록된 상태에서 시스템에 장애가 발생한 경우,
  → 복구 시 `Tᵢ`는 **redo 대상**이 됨

- 이러한 방식은 **repeating history**라 불리며,
  - 데이터 복구는 비효율적처럼 보일 수 있지만,
  - 전체적인 복구 로직을 단순화함

---

### 🔹 Checkpoints (체크포인트)
- **문제점**: 시스템이 장시간 동작한 후 장애가 발생하면, **전체 로그를 모두 재처리**하는 것은 비효율적임
  - 이미 디스크에 반영된 트랜잭션도 중복 처리될 수 있음

- **해결책**: 일정 주기로 **체크포인트(checkpointing)** 수행
  - 메모리 상의 로그를 디스크로 출력
  - 버퍼 블록도 디스크로 출력
  - `<checkpoint L>` 로그 기록 (여기서 L은 해당 시점의 활성 트랜잭션 목록)
  - **체크포인트 중에는 모든 업데이트 중단됨**

---

### 🔹 Checkpoints 후 복구 시 고려 사항
- 복구 시에는 다음만 고려하면 됨:
  - 체크포인트 시점에 **미완료된 트랜잭션**
  - 체크포인트 이후에 **시작된 트랜잭션**

- 복구 절차:
  - `<checkpoint L>`부터 로그를 역방향으로 검색
  - `L`에 속한 트랜잭션마다 `<Tᵢ, start>`가 발견될 때까지 로그 탐색
  - 그 외 트랜잭션은 이미 디스크에 반영 완료 → 복구 제외

---

### 🔹 Checkpoint 예시
- 다음과 같은 트랜잭션이 존재한다고 가정:
T₁: checkpoint 이전에 시작되어 종료됨  
T₂, T₃: checkpoint 이전에 시작되었지만 system failure까지 완료되지 않음  
T₄: checkpoint 이후에 시작되었고 system failure 시점에도 미완료
- 복구 대상:
  - `T₁`: 디스크에 이미 반영됨 → 무시
  - `T₂`, `T₃`: **redo**
  - `T₄`: **undo**

