## 📌 Static Hashing (정적 해싱)
### 🔹 버킷(Bucket)의 개념
- `bucket`은 여러 개의 엔트리를 저장할 수 있는 저장 공간 단위임
- 보통 하나의 bucket은 디스크 블록 크기(예: 4KB)임
- 서로 다른 검색 키들이 같은 bucket에 매핑될 수 있음 → 해시 충돌 발생

### 🔹 해시 함수(Hash Function)의 역할
- 해시 함수 `h`는 검색 키 값을 받아 버킷 주소로 변환함
- 예: `h(key) = key MOD N` (N은 전체 bucket 수)
- 이 과정을 통해 키가 저장될 버킷 위치를 빠르게 계산함

### 🔹 해시 충돌 처리
- 서로 다른 검색 키가 같은 버킷에 매핑될 수 있음
- 이 경우, 해당 버킷 내부에서 모든 엔트리를 순차적으로 검색해야 함

### 🔹 Hash Index vs Hash File-Organization
- `hash index`: 버킷은 `(검색 키, 레코드 포인터)` 형태의 엔트리 저장 → 레코드는 실제 다른 위치에 있음
- `hash file-organization`: 버킷이 레코드 자체를 저장함 → 데이터 저장 구조로 직접 사용됨

## 📌 Static Hashing 구조 및 해시 과정

### 🔹 버킷 수와 할당 방식
- 전체 bucket 수는 고정되어 있음 → 삽입/삭제와 무관하게 변하지 않음
- `버킷은 순차적으로 할당되고`, 한 번 할당되면 해제되지 않음

### 🔹 해시 계산 예시
- 해시 함수 예: `h(key) = key MOD N`
- 예를 들어 key = 27, N = 4이면:
  - `h(27) = 27 MOD 4 = 3` → bucket 3에 저장됨

### 🔹 구조 시각화
- 해시 함수 결과를 이용하여 bucket 중 하나로 직접 접근
- 각 bucket은 고정된 순서대로 메모리/디스크 상에 존재
- 입력 키가 `h`를 거쳐서 하나의 버킷에 매핑됨:
key → h → bucket 번호 (0~N-1)

### 🔹 정적 해싱의 특징
- 장점: 빠른 해시 계산을 통해 O(1) 수준의 접근 기대
- 단점: 충돌 처리 시 성능 저하 가능, overflow bucket 필요


## 📌 Handling of Bucket Overflows

### 🔹 Bucket Overflow 발생 원인
- 정적 해싱(static hashing)에서는 **버킷 수가 고정**되어 있기 때문에 데이터가 많아지면 개별 버킷이 가득 차는 상황이 발생함
- 다음 두 가지 원인으로 overflow가 발생할 수 있음:
  - **Insufficient buckets**: 총 버킷 수가 너무 적어서 모든 데이터를 수용하기 어려움
  - **Skew in distribution**: 일부 키 값이 특정 bucket에 몰리는 편향 현상

### 🔹 Skew 발생의 두 가지 주요 이유
- 여러 레코드가 동일한 검색 키를 가짐
- 해시 함수 자체가 키 값을 고르게 분포시키지 못함 (비균등 분포)

### 🔹 Overflow 완화 가능성
- 좋은 해시 함수를 사용하거나 충분한 수의 버킷을 할당하면 **overflow 확률은 낮출 수 있음**
- 하지만 **overflow 자체를 완전히 없애는 것은 불가능함**

### 🔹 Overflow 처리 방법
- 일반적으로는 **overflow bucket**을 사용함
- 기존 버킷이 가득 찼을 때 **추가적인 공간을 외부에 연결해서 사용하는 방식**임

## 📌 Handling of Bucket Overflows (Cont.)

### 🔹 Overflow Chaining
- overflow bucket은 **연결 리스트 구조로 연결됨** (chaining 방식)
- 이 방식은 **closed addressing (closed hashing)**이라 불림
  - 데이터는 해시된 원래 bucket 위치에 저장되거나, 거기서 파생된 overflow 영역에 저장됨
- 장점: 동일한 해시 위치에서 발생한 데이터를 한곳에서 순차적으로 관리 가능

### 🔹 Open Hashing과의 비교
- open hashing은 overflow bucket을 사용하지 않으며, **다른 bucket으로 데이터를 분산시켜 저장**
- 하지만 open hashing은 디스크 기반 DB 시스템에서는 **성능 및 관리 측면에서 부적합**함

### 🔹 Linear Probing (선형 조사)
- open hashing의 한 형태로, 해시 충돌 시 **다음 빈 bucket**을 순환 순서(cyclic order)로 탐색하여 저장
- 메모리 기반 해시 구조에서는 빠른 탐색이 가능하지만, 디스크 I/O가 큰 DB 환경에서는 비효율적일 수 있음

### 🔹 시각적 예시
- `h(key) = k MOD N`으로 계산된 bucket이 가득 찼을 때 → overflow bucket을 연결해서 사용
- 버킷 1이 가득 찼다면, 그 뒤에 overflow bucket들이 링크드 리스트처럼 연결되어 저장 공간 확장됨

## 📌 Example of Hash File Organization

### 🔹 Instructor 파일의 해시 조직
- `dept_name`을 키로 하는 해시 기반 파일 조직을 예로 설명
- 각 문자의 이진 표현 값을 정수로 보고, 이를 모두 더한 후 **mod 10**을 취한 값을 해시값으로 사용

### 🔹 해시 함수 구조
- 문자들의 binary 값을 더한 뒤, 이를 10으로 나눈 나머지를 해시값으로 함
- 예:
  - `h(Music) = 1`
  - `h(History) = 2`
  - `h(Physics) = 3`
  - `h(Elec. Eng.) = 3`

### 🔹 분포 예시
- bucket 2에는 History 관련 레코드들이, bucket 6에는 Computer Science 관련 레코드들이 몰려 있음
- 이로 인해 일부 버킷은 여러 레코드를 담고 있고, 일부는 비어 있음

### 🔹 해시 분포의 문제점
- 이 해시 함수는 모든 키 값을 **균등하게 분산하지 못함**
- 특정 키들(예: History, Comp. Sci.)이 동일한 bucket에 몰리게 되며, 이는 성능 저하와 overflow 가능성을 높임

### 🔹 요약
- 해시 함수 설계가 적절하지 않으면, bucket 간 분포 불균형이 발생하여 overflow나 충돌이 자주 일어날 수 있음
- 해시 기반 파일 조직에서도 **균등 분포를 유도하는 해시 함수 설계가 매우 중요함**

## 📌 Deficiencies of Static Hashing

### 🔹 정적 해싱의 구조적 한계
- 정적 해싱에서는 해시 함수 `h`가 검색 키를 **고정된 개수의 bucket 주소**로 매핑함
- 즉, 해시 구조는 **초기에 설정된 bucket 수에 의존**하며, 이후 데이터 양이 변해도 구조 자체는 변하지 않음

### 🔹 데이터베이스 크기의 변화에 따른 문제
- 현실에서는 데이터베이스가 시간이 지남에 따라 **점점 커지거나 작아짐**
- 이때 정적 해싱은 다음과 같은 한계를 가짐:

#### 🔸 버킷 수가 너무 적을 경우
- 데이터가 많아지면 **bucket overflow**가 자주 발생함
- 각 버킷에 많은 엔트리가 몰려 성능이 급격히 저하됨

#### 🔸 버킷 수가 너무 많을 경우
- 데이터가 적은데도 많은 bucket이 존재하면 **공간 낭비** 발생
- 대부분의 버킷이 비어 있게 되고, 디스크 자원이 비효율적으로 사용됨

### 🔹 해결책 1: Rehashing
- **기존 데이터를 새로운 해시 함수에 따라 재배치하는 방식**
- 주기적으로 파일 전체를 재구성해야 하므로 **운영 중단을 유발하고 비용이 큼**
- 예: 버킷 수를 2배로 늘리고 해시 함수 `h(k) mod 2N`으로 변경

### 🔹 해결책 2: 동적 해싱 (Dynamic Hashing)
- 더 나은 방법은 **bucket 수를 동적으로 조절할 수 있도록 해싱 구조를 변경하는 것**
- 예: Extendible Hashing, Linear Hashing 등
- 데이터 크기에 따라 bucket이 자동으로 추가되거나 병합되므로 공간 효율성과 성능 모두 확보 가능함
