# B+-Tree
### B+-Tree의 정의 및 성질
#### 1. Rooted Tree
- B+-Tree는 루트를 가진 트리
#### 2. 균형 트리 (Balanced Tree)
- 루트에서 리프까지의 모든 경로의 길이가 동일
	- 이는 트리의 균형을 보장하며 검색 시간의 일관성을 제공
#### 3. 내부 노드의 자식 수 제한
- 루트 또는 리프가 아닌 **내부 노드**는 최소 ⌈n/2⌉개, 최대 n개의 자식을 가짐
	- n은 트리의 차수(degree)
#### 4. 리프 노드의 값 수 제한
- 리프 노드는 ⌈(n−1)/2⌉개 이상, n−1개 이하의 값을 가질 수 있음
	- 이는 값이 저장되는 노드이므로, 삽입/삭제 시 균형 조건을 유지해야함
#### 5. 특수한 경우 (Special cases)
- **루트가 리프가 아닐 경우**: 최소 2개의 자식을 가져야함
- **루트가 리프일 경우**: 트리 전체가 하나의 노드(즉, 노드가 하나뿐)인 경우로 0개 이상 (최대n-1개)의 값을 가질 수 있음

![[Pasted image 20250520131550.png]]

### B+-Tree Node Structure
#### 1. 노드 구성
![[Pasted image 20250520131744.png]]
- **K** : **검색 키 값(search-key values)**
	- 정렬된 상태로 저장됨
	- 중복 키는 일단 고려하지 않고 이후에 처리함
- **P** : **포인터**
	- **내부 노드**의 경우: 자식 노드를 가리키는 포인터
	- **리프 노드**의 경우: 레코드 또는 레코드 버킷을 가리키는 포인터
	
#### 2. 키 값의 정렬
- 키 값은 항상 정렬된 상태로 유지됨:
	- K1​<K2​<K3​<⋯<Kn−1​

#### B+-Tree의 리프 노드 특성
##### 1. 리프 노드의 포인터
- 포인터 $P_{i}$는 **검색 키 값 $K_{i}$를 가지는 레코드(record) 또는 레코드 버킷(bucket)을 가리킴** (0 < $i$ < $n$)
##### 2. 정렬된 리프 노드 간의 순서
- $L_i$ ,$L_j$가 리프 노드이고 $i<j$ 이면,
- $L_i$에 있는 검색 키 값들은 $L_j$에 있는 값들보다 작거나 같음
	- 즉, **리프 노드는 키 값 순서에 따라 정렬되어 있음**
##### 3. 리프 노드 간 연결
- 마지막 포인터 $P_n$은 **다음 리프 노드를 가리킴**
	- 이를 통해 리프 노드들이 **연결 리스트 형태**로 연결되어 있어, 범위 검색(range search) 시 빠르게 순차 접근이 가능
- ![[Pasted image 20250520132826.png]]

#### Non-Leaf Nodes in B+-Trees
##### 1. 역할
- **비-리프 노드**는 **리프 노드들에 대한 다단계 희소 인덱스(multi-level sparse index)를 구성**함
- 즉, 리프 노드까지 내려가는 경로를 효율적으로 탐색할 수 있도록 도와주는 **탐색용 인덱스 노드**
- 이 노드들에게는 **검색 키 값만 존재하고 실제 데이터는 존재하지 않음**
##### 2. 구조 설명(n개의 포인터가 있는 경우)
노드 구조는 다음과 같음:	$$P_1, K_1, P_2, K_2, \ldots, K_{n-1}, P_n$$
- $K_i$ : 검색 키값 (정렬된 상태)
- $P_i$: 자식 노드를 가리키는 포인터
##### 3. 탐색 규칙
- $P_1$
	- $K_1$ 보다 **작은** 키 값을 가진 모든 노드로 연결됨
- $P_i  \,\,(2 ≤ i ≤ n-1)$ 
	- $K_i-1 ≤ 키\,값 < K_i$  를 가진 서브트리로 연결됨
- $P_n$
	- $K_n-1$보다 **크거나 같은** 키 값을 가진 노드로 연결됨


###  B⁺-트리 구성 예시
- 루트 노드는 내부 노드이고, 키 `El Said`, `Mozart`를 가짐.
- 각 키는 자식 노드를 나누는 경계값 역할을 함:
    - `El Said`보다 작은 키 → 왼쪽 자식 노드
    - `El Said` 이상 `Mozart` 미만 → 가운데 자식 노드
    - `Mozart` 이상 → 오른쪽 자식 노드

#### 리프 노드 구조
- 총 3개의 리프 노드가 있음:
    1. `Brandt`, `Califieri`, `Crick`, `Einstein` → 4개 키
    2. `El Said`, `Gold`, `Katz`, `Kim` → 4개 키
    3. `Mozart`, `Singh`, `Srinivasan`, `Wu` → 4개 키
- 리프 노드는 오른쪽으로 향하는 포인터로 서로 연결되어 있음 → 순차 탐색(range query)에 사용됨
    

#### 내부 노드 역할
- 루트는 희소 인덱스로, 전체 키 공간을 세 구간으로 나눔:
    - `Brandt`~`Einstein`
    - `El Said`~`Kim`
    - `Mozart`~`Wu`

---
###  B⁺-트리 조건 정리 (`n = 6`)
- **리프 노드**:
    - 최소 키 수: ⌈(n–1)/2⌉ = ⌈5/2⌉ = 3개
    - 최대 키 수: n–1 = 5개  
        → 현재 모든 리프 노드는 4개 키를 가지고 있어 조건 만족함
        
- **내부 노드(루트 제외)**:
    - 최소 자식 수: ⌈n/2⌉ = ⌈6/2⌉ = 3개
    - 최대 자식 수: n = 6  
        → 루트는 자식 노드 3개를 가지고 있어 조건 만족함
        
- **루트 노드**:
    - 최소 2개의 자식 필요함  
        → 조건 만족함

### 🔎 Queries on B⁺-Trees
#### 검색 함수 `find(v)`

1. $C = \text{root}$  
2. $\text{while } (C \text{는 리프 노드가 아님})$  
  2-1. $i = \min\{i \mid v \leq K_i\}$  
  2-2. 그런 $i$가 없다면 → $C = \text{마지막 non-null 포인터}$  
  2-3. $v = K_i$ 인 경우 → $C = P_{i+1}$  
  2-4. 그 외에는 → $C = P_i$  
3. 어떤 $i$에 대해 $K_i = v$ 이면 → $C.P_i$ 반환  
4. 그 외에는 → $\text{null}$ 반환 (해당 키 없음)

#### 탐색 알고리즘 설명
- 루트 노드부터 시작해서 리프 노드에 도달할 때까지 내려가며 `v`가 어느 구간에 속하는지를 판단함
- 각 내부 노드는 정렬된 키 값 기준으로 자식 노드를 탐색하는 포인터만 포함하며, 실제 데이터는 리프 노드에 존재함
- 탐색 중간에 키와 정확히 일치하는 값이 있다면 해당 위치의 포인터를 통해 결과를 반환함
- 키가 존재하지 않는 경우에는 `null`을 반환함
    
#### 트리 예시 구조
- 루트는 `Mozart` 하나의 키를 가지며 세 자식 노드를 가짐
- 두 번째 레벨에는 `Califieri`, `Einstein`, `Gold`, `Srinivasan` 등의 키가 배치되어 있고, 그에 따라 리프 노드로 이어짐
- 리프 노드에는 실제 이름 데이터가 키로 포함되어 있으며, 각 노드 간 순서대로 연결되어 있음

####  Range Query (범위 질의)
- **범위 질의(range query)**는 특정 범위 내의 검색 키 값을 가지는 모든 레코드를 찾는 질의 방식
- 예를 들어, $[lb, ub]$ 구간 내의 키를 모두 조회하고자 할 때 사용됨

####  함수 구조
- 이론적으로는 `\texttt{findRange(lb, ub)}`와 같은 함수로 구현됨
- 해당 함수는 조건을 만족하는 모든 레코드의 집합을 반환함
- 실제 구현에서는 하나씩 순차적으로 레코드를 가져올 수 있도록 `\texttt{next()}` 형태의 **반복자(iterator)** 인터페이스를 제공하는 경우가 많음
    

####  리프 노드 순차 접근 구조
- 리프 노드들은 **오른쪽 포인터(Pₙ)** 로 연결되어 있음
- 한 리프 노드에서 시작하여 오른쪽으로 계속 이동하며 범위에 해당하는 값들을 모두 순차적으로 추출 가능
- B⁺-트리의 구조 특성상, 범위 질의는 매우 효율적임