# B+-Tree
### B+-Tree의 정의 및 성질
#### 1. Rooted Tree
- B+-Tree는 루트를 가진 트리
#### 2. 균형 트리 (Balanced Tree)
- 루트에서 리프까지의 모든 경로의 길이가 동일
	- 이는 트리의 균형을 보장하며 검색 시간의 일관성을 제공
#### 3. 내부 노드의 자식 수 제한
- 루트 또는 리프가 아닌 **내부 노드**는 최소 ⌈n/2⌉개, 최대 n개의 자식을 가짐
	- n은 트리의 차수(degree)
#### 4. 리프 노드의 값 수 제한
- 리프 노드는 ⌈(n−1)/2⌉개 이상, n−1개 이하의 값을 가질 수 있음
	- 이는 값이 저장되는 노드이므로, 삽입/삭제 시 균형 조건을 유지해야함
#### 5. 특수한 경우 (Special cases)
- **루트가 리프가 아닐 경우**: 최소 2개의 자식을 가져야함
- **루트가 리프일 경우**: 트리 전체가 하나의 노드(즉, 노드가 하나뿐)인 경우로 0개 이상 (최대n-1개)의 값을 가질 수 있음

![[Pasted image 20250520131550.png]]

### B+-Tree Node Structure
#### 1. 노드 구성
![[Pasted image 20250520131744.png]]
- **K** : **검색 키 값(search-key values)**
	- 정렬된 상태로 저장됨
	- 중복 키는 일단 고려하지 않고 이후에 처리함
- **P** : **포인터**
	- **내부 노드**의 경우: 자식 노드를 가리키는 포인터
	- **리프 노드**의 경우: 레코드 또는 레코드 버킷을 가리키는 포인터
	
#### 2. 키 값의 정렬
- 키 값은 항상 정렬된 상태로 유지됨:
	- K1​<K2​<K3​<⋯<Kn−1​

#### B+-Tree의 리프 노드 특성
##### 1. 리프 노드의 포인터
- 포인터 $P_{i}$는 **검색 키 값 $K_{i}$를 가지는 레코드(record) 또는 레코드 버킷(bucket)을 가리킴** (0 < $i$ < $n$)
##### 2. 정렬된 리프 노드 간의 순서
- $L_i$ ,$L_j$가 리프 노드이고 $i<j$ 이면,
- $L_i$에 있는 검색 키 값들은 $L_j$에 있는 값들보다 작거나 같음
	- 즉, **리프 노드는 키 값 순서에 따라 정렬되어 있음**
##### 3. 리프 노드 간 연결
- 마지막 포인터 $P_n$은 **다음 리프 노드를 가리킴**
	- 이를 통해 리프 노드들이 **연결 리스트 형태**로 연결되어 있어, 범위 검색(range search) 시 빠르게 순차 접근이 가능
- ![[Pasted image 20250520132826.png]]

#### Non-Leaf Nodes in B+-Trees
##### 1. 역할
- **비-리프 노드**는 **리프 노드들에 대한 다단계 희소 인덱스(multi-level spars)