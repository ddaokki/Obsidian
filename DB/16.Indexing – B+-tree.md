# B+-Tree
### B+-Tree의 정의 및 성질
#### 1. Rooted Tree
- B+-Tree는 루트를 가진 트리
#### 2. 균형 트리 (Balanced Tree)
- 루트에서 리프까지의 모든 경로의 길이가 동일
	- 이는 트리의 균형을 보장하며 검색 시간의 일관성을 제공
#### 3. 내부 노드의 자식 수 제한
- 루트 또는 리프가 아닌 **내부 노드**는 최소 ⌈n/2⌉개, 최대 n개의 자식을 가짐
	- n은 트리의 차수(degree)
#### 4. 리프 노드의 값 수 제한
- 리프 노드는 ⌈(n−1)/2⌉개 이상, n−1개 이하의 값을 가질 수 있음
	- 이는 값이 저장되는 노드이므로, 삽입/삭제 시 균형 조건을 유지해야함
#### 5. 특수한 경우 (Special cases)
- **루트가 리프가 아닐 경우**: 최소 2개의 자식을 가져야함
- **루트가 리프일 경우**: 트리 전체가 하나의 노드(즉, 노드가 하나뿐)인 경우로 0개 이상 (최대n-1개)의 값을 가질 수 있음

![[Pasted image 20250520131550.png]]

### B+-Tree Node Structure
#### 1. 노드 구성
![[Pasted image 20250520131744.png]]
- **K** : **검색 키 값(search-key values)**
	- 정렬된 상태로 저장됨
	- 중복 키는 일단 고려하지 않고 이후에 처리함
- **P** : **포인터**
	- **내부 노드**의 경우: 자식 노드를 가리키는 포인터
	- **리프 노드**의 경우: 레코드 또는 레코드 버킷을 가리키는 포인터
	
#### 2. 키 값의 정렬
- 키 값은 항상 정렬된 상태로 유지됨:
	- K1​<K2​<K3​<⋯<Kn−1​

#### B+-Tree의 리프 노드 특성
##### 1. 리프 노드의 포인터
- 포인터 $P_{i}$는 **검색 키 값 $K_{i}$를 가지는 레코드(record) 또는 레코드 버킷(bucket)을 가리킴** (0 < $i$ < $n$)
##### 2. 정렬된 리프 노드 간의 순서
- $L_i$ ,$L_j$가 리프 노드이고 $i<j$ 이면,
- $L_i$에 있는 검색 키 값들은 $L_j$에 있는 값들보다 작거나 같음
	- 즉, **리프 노드는 키 값 순서에 따라 정렬되어 있음**
##### 3. 리프 노드 간 연결
- 마지막 포인터 $P_n$은 **다음 리프 노드를 가리킴**
	- 이를 통해 리프 노드들이 **연결 리스트 형태**로 연결되어 있어, 범위 검색(range search) 시 빠르게 순차 접근이 가능
- ![[Pasted image 20250520132826.png]]

#### Non-Leaf Nodes in B+-Trees
##### 1. 역할
- **비-리프 노드**는 **리프 노드들에 대한 다단계 희소 인덱스(multi-level sparse index)를 구성**함
- 즉, 리프 노드까지 내려가는 경로를 효율적으로 탐색할 수 있도록 도와주는 **탐색용 인덱스 노드**
- 이 노드들에게는 **검색 키 값만 존재하고 실제 데이터는 존재하지 않음**
##### 2. 구조 설명(n개의 포인터가 있는 경우)
노드 구조는 다음과 같음:	$$P_1, K_1, P_2, K_2, \ldots, K_{n-1}, P_n$$
- $K_i$ : 검색 키값 (정렬된 상태)
- $P_i$: 자식 노드를 가리키는 포인터
##### 3. 탐색 규칙
- $P_1$
	- $K_1$ 보다 **작은** 키 값을 가진 모든 노드로 연결됨
- $P_i  \,\,(2 ≤ i ≤ n-1)$ 
	- $K_i-1 ≤ 키\,값 < K_i$  를 가진 서브트리로 연결됨
- $P_n$
	- $K_n-1$보다 **크거나 같은** 키 값을 가진 노드로 연결됨


###  B⁺-트리 구성 예시
- 루트 노드는 내부 노드이고, 키 `El Said`, `Mozart`를 가짐.
- 각 키는 자식 노드를 나누는 경계값 역할을 함:
    - `El Said`보다 작은 키 → 왼쪽 자식 노드
    - `El Said` 이상 `Mozart` 미만 → 가운데 자식 노드
    - `Mozart` 이상 → 오른쪽 자식 노드

#### 리프 노드 구조
- 총 3개의 리프 노드가 있음:
    1. `Brandt`, `Califieri`, `Crick`, `Einstein` → 4개 키
    2. `El Said`, `Gold`, `Katz`, `Kim` → 4개 키
    3. `Mozart`, `Singh`, `Srinivasan`, `Wu` → 4개 키
- 리프 노드는 오른쪽으로 향하는 포인터로 서로 연결되어 있음 → 순차 탐색(range query)에 사용됨
    

#### 내부 노드 역할
- 루트는 희소 인덱스로, 전체 키 공간을 세 구간으로 나눔:
    - `Brandt`~`Einstein`
    - `El Said`~`Kim`
    - `Mozart`~`Wu`

---
###  B⁺-트리 조건 정리 (`n = 6`)
- **리프 노드**:
    - 최소 키 수: ⌈(n–1)/2⌉ = ⌈5/2⌉ = 3개
    - 최대 키 수: n–1 = 5개  
        → 현재 모든 리프 노드는 4개 키를 가지고 있어 조건 만족함
        
- **내부 노드(루트 제외)**:
    - 최소 자식 수: ⌈n/2⌉ = ⌈6/2⌉ = 3개
    - 최대 자식 수: n = 6  
        → 루트는 자식 노드 3개를 가지고 있어 조건 만족함
        
- **루트 노드**:
    - 최소 2개의 자식 필요함  
        → 조건 만족함

### Observations about B⁺-trees
- 노드는 포인터로 연결되므로, 논리적으로 인접한 블록이 물리적으로 인접할 필요는 없음
    
- 비리프 노드들은 리프 노드에 대한 다단계 희소 인덱스를 형성함
    
- 전체 트리는 비교적 적은 수의 레벨만으로 구성됨
    - 루트 아래 레벨은 최소 `2 × ⌈n/2⌉`개의 값을 가짐
    - 그 다음 레벨은 `2 × ⌈n/2⌉ × ⌈n/2⌉`개의 값을 가짐
    - 이후 레벨들도 같은 방식으로 지수적으로 값 수가 증가함
    - 전체 검색 키 수를 `K`라 하면, 트리의 높이는 `⌈log⌈n/2⌉(K)⌉` 이하
- 효율적인 탐색 가능
    - 탐색 비용 = 트리 높이 = `⌈log⌈n/2⌉(K)⌉`
### 🔎 Queries on B⁺-Trees
#### 검색 함수 `find(v)`

1. $C = \text{root}$  
2. $\text{while } (C \text{는 리프 노드가 아님})$  
  2-1. $i = \min\{i \mid v \leq K_i\}$  
  2-2. 그런 $i$가 없다면 → $C = \text{마지막 non-null 포인터}$  
  2-3. $v = K_i$ 인 경우 → $C = P_{i+1}$  
  2-4. 그 외에는 → $C = P_i$  
3. 어떤 $i$에 대해 $K_i = v$ 이면 → $C.P_i$ 반환  
4. 그 외에는 → $\text{null}$ 반환 (해당 키 없음)

#### 탐색 알고리즘 설명
- 루트 노드부터 시작해서 리프 노드에 도달할 때까지 내려가며 `v`가 어느 구간에 속하는지를 판단함
- 각 내부 노드는 정렬된 키 값 기준으로 자식 노드를 탐색하는 포인터만 포함하며, 실제 데이터는 리프 노드에 존재함
- 탐색 중간에 키와 정확히 일치하는 값이 있다면 해당 위치의 포인터를 통해 결과를 반환함
- 키가 존재하지 않는 경우에는 `null`을 반환함
    
#### 트리 예시 구조
- 루트는 `Mozart` 하나의 키를 가지며 세 자식 노드를 가짐
- 두 번째 레벨에는 `Califieri`, `Einstein`, `Gold`, `Srinivasan` 등의 키가 배치되어 있고, 그에 따라 리프 노드로 이어짐
- 리프 노드에는 실제 이름 데이터가 키로 포함되어 있으며, 각 노드 간 순서대로 연결되어 있음

####  Range Query (범위 질의)
- **범위 질의(range query)**는 특정 범위 내의 검색 키 값을 가지는 모든 레코드를 찾는 질의 방식
- 예를 들어, $[lb, ub]$ 구간 내의 키를 모두 조회하고자 할 때 사용됨

####  함수 구조
- 이론적으로는 `{findRange(lb, ub)}`와 같은 함수로 구현됨
- 해당 함수는 조건을 만족하는 모든 레코드의 집합을 반환함
- 실제 구현에서는 하나씩 순차적으로 레코드를 가져올 수 있도록 `{next()}` 형태의 **반복자(iterator)** 인터페이스를 제공하는 경우가 많음
    

####  리프 노드 순차 접근 구조
- 리프 노드들은 **오른쪽 포인터(Pₙ)** 로 연결되어 있음
- 한 리프 노드에서 시작하여 오른쪽으로 계속 이동하며 범위에 해당하는 값들을 모두 순차적으로 추출 가능
- B⁺-트리의 구조 특성상, 범위 질의는 매우 효율적임

### ⚙️ B⁺-트리 탐색 성능 분석
- 하나의 노드는 일반적으로 디스크 블록 크기와 같으며, 보통 4KB 크기를 가짐
- 인덱스 항목 하나당 약 40바이트이므로 $n \approx 100$ 수준이 일반적임

#### 예시 조건
- 검색 키 값이 1,000,000개이고 $n = 100$일 경우  
- 탐색 시 접근되는 노드 수는 최대
- $$ \log_{50}(1{,}000{,}000) \approx 4$$
- 즉, 루트부터 리프까지 내려가며 **최대 4개 노드만 접근**하면 됨  
- 이는 트리 높이가 $K$개의 키 값에 대해
  $$
  \left\lceil \log_{\left\lceil n/2 \right\rceil} K \right\rceil
  $$
  보다 크지 않기 때문임


#### 이진 트리와의 비교
- 동일한 키 수를 가진 **균형 이진 탐색 트리**에서는 약 **20개 노드**를 접근해야 함
- B⁺-트리와 비교해 **5배 차이** 발생
- 이는 중요한 차이점임.  
    → **모든 노드 접근마다 디스크 I/O가 발생**할 수 있으며,  
    I/O 1회당 약 **20밀리초**의 비용이 소요됨

### 🔑 Non-Unique Keys
- 검색 키 $a_i$가 고유하지 않은 경우,  
  → 고유한 복합 키 $(a_i, A_p)$에 대해 인덱스를 생성해야 함  
  - $A_p$는 기본 키, 레코드 ID, 혹은 고유성을 보장하는 다른 속성이 될 수 있음
- $a_i = v$를 찾고자 할 때는 복합 키에 대해 범위 질의로 처리 가능  
  → 범위: $(v, -\infty)$ ~ $(v, +\infty)$
- 하지만 실제 레코드를 가져오기 위해 더 많은 I/O 연산이 발생할 수 있음  
  - 인덱스가 클러스터링(clustering)인 경우 → 접근은 순차적으로 일어남  
  - 인덱스가 비클러스터링(non-clustering)인 경우 → 각 레코드 접근마다 디스크 I/O가 따로 발생할 수 있음


### 🔄 Updates on B⁺-Trees: Insertion
- 레코드는 이미 파일에 추가되었다고 가정함  
  - $ptr$은 해당 레코드를 가리키는 포인터  
  - $k$는 그 레코드의 검색 키 값
- 검색 키가 삽입될 리프 노드를 찾음  
  1. 리프 노드에 공간이 있으면 $(k, ptr)$ 쌍을 삽입함  
  2. 공간이 없으면, 새 $(k, ptr)$ 항목과 함께 노드를 분할하고  
     → 그 결과를 부모 노드로 전파함 (다음 슬라이드에서 상세히 설명됨)


### 🌿 Splitting a Leaf Node in B⁺-Tree
- 리프 노드를 분할하는 과정은 다음과 같음
  - $n$개의 $(\text{search-key}, \text{pointer})$ 쌍을 정렬된 순서로 준비함  
  - 앞의 $\lceil n/2 \rceil$개는 기존 노드에 그대로 유지하고,  
    나머지 절반은 새로운 노드에 저장함
  - 새 노드를 $p$라고 할 때,  
    $p$에 저장된 키 값들 중 가장 작은 값을 $k$라고 하면,  
    부모 노드에 $(k, p)$를 삽입함 → 부모 노드는 $k$를 통해 하위 노드 경계를 구분하게 됨
  - 만약 부모 노드도 꽉 차 있다면,  
    해당 부모도 분할하고 그 분할 정보를 더 상위 부모에게 전파함 (**propagate**)
- 노드 분할은 최상위로 올라갈 때까지 계속될 수 있음  
  → **최악의 경우 루트 노드까지 분할되어 트리 높이가 1 증가**하게 됨

---

#### ✏️ 추가 설명
- 이 구조는 B⁺-트리가 항상 균형잡힌 상태를 유지하게 해 줌  
  → 삽입이 계속되어도 특정 경로만 과도하게 깊어지지 않음
- 분할 후 부모 노드에 추가되는 키 $k$는 새로 생성된 노드 $p$를 식별할 수 있게 해 주는 **경계값 역할**을 함  
  → 부모 입장에서는 $k$ 미만의 값은 기존 노드로, $k$ 이상은 $p$로 탐색되도록 안내
- 트리의 높이가 증가하는 경우는 드물지만,  
  → 발생 시 루트 자체가 새로운 내부 노드로 바뀌고 자식 노드가 2개로 시작됨
- 이러한 설계 덕분에 B⁺-트리는 **삽입/삭제 시에도 항상 $\log n$ 시간복잡도를 유지**할 수 있음

### 🌿 Insertion in B⁺-Trees (Cont.)

- 내부 노드가 가득 찬 상태에서 $(k, p)$를 삽입할 경우, 내부 노드를 분할함

- 분할 과정은 다음과 같음
  - 노드 $N$을 메모리상의 임시 버퍼 공간 $M$에 복사함
  - $M$에 $(k, p)$를 삽입함
  - $M$에서 앞부분 $P_1, K_1, \dots, K_{\lceil n/2 \rceil -1}, P_{\lceil n/2 \rceil}$를 원래 노드 $N$에 덮어씀
  - 나머지 $P_{\lceil n/2 \rceil +1}, K_{\lceil n/2 \rceil +1}, \dots, K_n, P_{n+1}$는 새로 할당한 노드 $N'$에 저장함
  - 경계 키 $K_{\lceil n/2 \rceil}$와 노드 $N'$를 부모 노드에 삽입함

- 결과적으로 기존 노드는 왼쪽 절반을, 새 노드는 오른쪽 절반을 담당하게 됨

- 오른쪽 그림은 예시임
  - 원래 노드가 `Adams`, `Brandt`, `Califieri`, `Crick`를 포함하고 있었고,
  - 이를 기준으로 `Califieri`를 경계 키로 삼아 분할함

### 🗑️ Updates on B⁺-Trees: Deletion

- 레코드는 파일에서 이미 삭제되었다고 가정함  
  → $K$는 해당 레코드의 키, $Ptr$는 레코드를 가리키는 포인터

- 리프 노드에서 $(K, Ptr)$를 제거함

- 만약 해당 리프 노드의 엔트리 수가 너무 적어 최소 조건을 만족하지 못하면,  
  **형제 노드와 병합(merge siblings)** 수행
  - 두 노드의 키 값을 하나의 노드(보통 왼쪽)에 모두 넣고,  
    나머지 노드(오른쪽)는 삭제함
  - 부모 노드에서 삭제된 노드를 가리키던 포인터 $P_j$와 그 왼쪽 키 $K_{j-1}$를 제거함  
    → 이 과정을 **재귀적으로** 부모 노드에 대해 반복함

- 병합은 트리 위로 전파될 수 있으며,  
  최악의 경우 루트까지 올라가 트리 높이가 줄어들 수도 있음


### 🔁 B⁺-Tree Deletion: Redistribution & Cascading

- 노드 삭제 후 엔트리 수가 너무 적지만, 병합할 만큼 여유 있는 형제 노드가 없을 경우  
  → **포인터 재분배(redistribute)**를 수행함
  - 형제 노드로부터 일부 엔트리를 가져와 두 노드 모두 최소 조건을 만족하도록 재분배함
  - 부모 노드에 있는 해당 구간의 키 값을 갱신함

- 이러한 삭제 및 재구조화 과정은  
  **최소 조건(n/2 이상의 포인터 수)을 만족하는 노드를 만날 때까지 상위로 전파(cascade)**될 수 있음

- 루트 노드가 삭제 후 오직 하나의 포인터만 가지게 되면  
  → 루트 노드는 제거되고, 유일한 자식 노드가 새로운 루트가 됨


### ⚙️ Complexity of Updates

- 삽입 및 삭제 연산의 I/O 비용은 트리의 높이에 비례함  
  - 엔트리 수가 $K$, 차수(최대 fan-out)가 $n$일 때  
    → 최악의 경우 삽입/삭제 연산의 복잡도는 $O(\log_{\lceil n/2 \rceil} K)$

- 하지만 실제 환경에서는 I/O 발생 횟수가 더 적음  
  - 내부 노드는 버퍼에 상주하는 경우가 많음  
  - 대부분의 삽입/삭제는 리프 노드만 영향을 받음  
  - 분할(split)이나 병합(merge)은 자주 발생하지 않음

- 노드의 평균 점유율(occupancy)은 삽입 순서에 따라 달라짐  
  - 랜덤 삽입 시 평균 2/3  
  - 정렬된 순서로 삽입하면 평균 1/2

---

### 🗂️ B⁺-Tree File Organization

- B⁺-Tree 파일 조직에서는 리프 노드가 **레코드 자체를 저장**함 (포인터가 아님)  
  - 삽입/삭제/갱신이 일어나도 레코드들이 논리적으로 묶인 상태를 유지할 수 있음  
  - 데이터가 물리적으로도 군집(clustering)된 상태를 유지하게 도와줌

- 리프 노드는 여전히 최소 반 이상 차 있어야 함 (half-full condition)

- 삽입 및 삭제는 일반적인 B⁺-트리 인덱스와 동일한 방식으로 수행됨

---

### 🗂️ B⁺-Tree File Organization (Cont.)

- B⁺-트리 파일 구조의 예시 그림  
  - 리프 노드에는 실제 레코드가 저장되고 있음 (예: [A,4], [B,8] 등)

- 포인터보다 레코드 자체가 공간을 더 많이 차지하므로, **공간 효율(space utilization)**이 중요함

- 공간 활용도를 높이기 위해 분할(split)이나 병합(merge) 시 **양쪽 형제 노드를 모두 참여**시켜 재분배를 수행할 수 있음  
  - 왼쪽 및 오른쪽 형제를 함께 고려함  
  - 그 결과 각 노드는 최소 $\left\lfloor \frac{2n}{3} \right\rfloor$개의 엔트리를 유지할 수 있음


### 📌 Other Issues in Indexing

- **레코드 이동과 보조 인덱스 문제**
  - 레코드가 이동하면 해당 레코드를 가리키는 모든 보조 인덱스도 갱신되어야 함
  - B⁺-트리 파일 구조에서의 노드 분할은 매우 비쌈

- **해결책**
  - 보조 인덱스에서는 포인터 대신 B⁺-트리 파일 구조의 **검색 키**를 사용함
  - 검색 키가 고유하지 않다면 레코드 ID를 함께 사용해야 함
  - 레코드를 찾기 위해 파일 조직을 한 번 더 순회해야 하므로 쿼리 비용은 증가하지만,  
    노드 분할 시 인덱스 갱신 부담이 줄어듦

---

### 🔤 Indexing Strings

- **가변 길이 문자열을 키로 사용할 경우**
  - 키 길이가 다르므로 fan-out도 가변적임
  - 포인터 개수보다 공간 활용률(space utilization)을 기준으로 분할 판단

- **Prefix Compression**
  - 내부 노드에서는 전체 키 대신 **공통 접두사(prefix)**만 저장 가능
    - 예: "Silas"와 "Silberschatz"는 "Sib"만으로 구분 가능
  - 리프 노드에서도 **공통 접두사 압축**을 통해 저장 공간 절약 가능

---

### 📦 Bulk Loading and Bottom-Up Build

- 항목을 하나씩 삽입할 경우 B⁺-트리는 엔트리당 최소 1회의 I/O가 필요함  
  - 특히 리프 노드가 메모리에 없을 경우 더욱 비효율적임  
  - 대량 데이터를 빠르게 삽입할 때는 매우 비효율적임 → **Bulk Loading**

- **효율적인 방법 1: 정렬 기반 삽입**
  - 먼저 데이터를 정렬한 뒤, 정렬된 순서대로 삽입  
  - I/O 성능은 향상되지만 대부분의 리프 노드가 절반만 채워짐

- **효율적인 방법 2: Bottom-up B⁺-tree construction**
  - 먼저 데이터를 정렬하고
  - 리프 레벨부터 위로 차근차근 트리를 구성함
  - 대부분의 DB 시스템이 이 방식을 채택하고 있음
