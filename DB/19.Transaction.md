## 📌 Transaction Concept
### 🔹 정의
- `Transaction`이란 여러 데이터 항목에 접근하고 이를 갱신할 수 있는 **프로그램 실행의 단위(unit)**를 의미함.

### 🔹 예시: A 계좌에서 B 계좌로 $50 송금하는 트랜잭션
1. `read(A)`  
2. `A := A - 50`  
3. `write(A)`  
4. `read(B)`  
5. `B := B + 50`  
6. `write(B)`

### 🔹 트랜잭션에서 고려해야 할 두 가지 주요 이슈
- 하드웨어 고장, 시스템 크래시와 같은 **장애 상황에 대한 대처**
- **다중 트랜잭션의 동시 실행(concurrent execution)** 관리

## 📌 Example of Fund Transfer
### 🔹 송금 트랜잭션 예시
- A 계좌에서 B 계좌로 $50 송금:
1. `read(A)`  
2. `A := A - 50`  
3. `write(A)`  
4. `read(B)`  
5. `B := B + 50`  
6. `write(B)`

### 🔹 Atomicity Requirement (원자성)
- 트랜잭션이 **중간 단계(예: step 3 이후, step 6 이전)**에 실패하면, 일부 데이터만 갱신되어 **일관성 없는 상태**가 됨
- 따라서 트랜잭션이 **전부 수행되거나 전혀 수행되지 않아야 함**

## 📌 Durability Requirement (지속성)
### 🔹 정의
- 사용자에게 **트랜잭션 완료**가 알려졌다면,
- 해당 트랜잭션의 **모든 결과는 시스템 고장 이후에도 지속되어야 함**
- 즉, $50 송금이 완료되었다고 알려진 경우, 이 변경 사항은 **영구적으로 데이터베이스에 반영되어야 함**

## 📌 Consistency Requirement (일관성)
### 🔹 송금 예시에서의 일관성 유지
- 트랜잭션 전후로 **A + B의 합계는 동일해야 함**
  - 예: A:500, B:800 → A:400, B:900 (합계 1300으로 동일)
- `Atomic TXN`이 상태 전이의 일관성을 보장함

### 🔹 일반적인 일관성 요구 사항
- 명시적 제약 조건 (primary key, foreign key 등)
- 암묵적 무결성 제약 조건
  - 예: 모든 계좌의 잔고 합 - 대출 합 = 현금 보유량 등
- 트랜잭션은 항상 **일관된 데이터베이스 상태**를 관찰해야 함

## 📌 Isolation Requirement (격리성)
### 🔹 정의
- 트랜잭션 T1이 `write(A)`까지 실행된 상태에서, 트랜잭션 T2가 `read(A), read(B)`를 실행하면,
- A와 B는 **부분적으로 갱신된 상태**이므로 `A+B`가 실제보다 작게 보이는 **불일치 상태**가 발생함

### 🔹 예시
- T1:  
  1. `read(A)`  
  2. `A := A - 50`  
  3. `write(A)`  
  4. `read(B)`  
  5. `B := B + 50`  
  6. `write(B)`  
- T2:  
  - `read(A), read(B), print(A+B)`

### 🔹 격리성 보장 방법
- 트랜잭션을 **serially(직렬로)** 실행하면 격리성 확보 가능
- 하지만 직렬 실행은 **성능 저하**를 유발할 수 있음

## 📌 ACID Principles & Transaction State
### 🔹 ACID 원칙: 데이터베이스의 무결성을 보장하기 위한 4가지 핵심 속성
- **Atomicity (원자성)**  
  - 트랜잭션의 모든 연산은 전부 수행되거나 전혀 수행되지 않아야 함  
  - 중간에 실패하면 모든 작업이 무효화되어야 함 ("All or Nothing")

- **Consistency (일관성)**  
  - 트랜잭션은 실행 전후로 데이터베이스의 일관성을 유지해야 함 
  - 무결성 제약 조건이 항상 만족되어야 함

- **Isolation (격리성)**  
  - 여러 트랜잭션이 동시에 실행될 수 있지만, 각 트랜잭션은 마치 독립적으로 수행된 것처럼 보여야 함  
  - 다른 트랜잭션이 중간 결과를 보지 못하도록 보장해야 함  
  - 모든 트랜잭션 `Ti`, `Tj` 쌍에 대해, 만약 `Ti`가 `Tj`보다 먼저 시작되었다면, 전체 실행 결과는 마치 `Ti`가 전부 끝난 후에 `Tj`가 실행된 것처럼 보여야 한다.

- **Durability (지속성)**  
  - 트랜잭션이 성공적으로 종료되면 그 결과는 영구적으로 데이터베이스에 반영되어야 함  
  - 시스템 장애 발생 시에도 변경 사항은 유지되어야 함

---

### 🔹 Transaction State (트랜잭션 상태)
- **Active**: 트랜잭션이 실행 중인 초기 상태  
- **Partially committed**: 마지막 명령문까지 실행된 상태  
- **Failed**: 실행 도중 오류가 발생한 상태  
- **Aborted**: 트랜잭션이 실패하고 이전 상태로 롤백된 상태  
  - 이후 두 가지 선택 가능:  
    - 트랜잭션 재시작 (논리 오류가 없을 경우)  
    - 트랜잭션 완전 종료  
- **Committed**: 성공적으로 완료되어 결과가 데이터베이스에 영구 반영된 상태

---

### 🔹 Transaction State Transition Diagram
- `active → partially committed → committed`: 정상적인 트랜잭션 흐름  
- `active → failed → aborted`: 오류 발생 시 흐름  
- `partially committed → failed`: 마지막 단계에서 오류가 발생한 경우

---

### 🔹 Concurrent Executions (동시 실행)
- 시스템은 다수의 트랜잭션을 **동시에 실행**하도록 허용함  
- **장점**:
  - `CPU`와 `디스크 활용률 향상`: 트랜잭션 하나는 CPU 사용, 다른 하나는 디스크 접근  
  - **응답 시간 단축**: 짧은 트랜잭션이 긴 트랜잭션을 기다릴 필요 없음

- **Concurrency control schemes**:  
  - 동시 실행되는 트랜잭션 간의 **상호작용을 제어**하여 **데이터베이스의 일관성** 유지  
  - 관련 내용은 **Chapter 18**에서 학습 예정

## 📌 Schedules & Serializability
### 🔹 Schedule의 개념
- `Schedule`이란 **동시 실행되는 트랜잭션들의 명령어 실행 순서**를 지정한 것임
- 유효한 schedule은 다음 조건을 만족해야 함:
  - 트랜잭션 내의 **모든 연산을 포함**해야 함
  - 각 트랜잭션 내 연산 순서는 **원래의 순서를 유지**해야 함
- 성공적으로 종료된 트랜잭션은 `commit`으로 끝나며,
- 실패한 트랜잭션은 `abort`로 종료됨

---
### 🔹 Serial Schedule 1
- `T₁`: A에서 B로 $50 송금  
- `T₂`: A 잔고의 10%를 B로 송금  
- 순차적(serial) 실행: `T₁` 완료 후 `T₂` 실행

T₁: read(A), A := A - 50, write(A), read(B), B := B + 50, write(B), commit  
T₂: read(A), temp := A * 0.1, A := A - temp, write(A), read(B), B := B + temp, write(B), commit

- 특징: 두 트랜잭션이 **서로 간섭 없이** 독립적으로 수행됨
- 일관성 유지 가능, `A + B`의 합이 보존됨

---

### 🔹 Serial Schedule 2
- 이번엔 `T₂`가 먼저 실행되고 `T₁`이 나중에 실행됨


T₂: read(A), temp := A * 0.1, A := A - temp, write(A), read(B), B := B + temp, write(B), commit  
T₁: read(A), A := A - 50, write(A), read(B), B := B + 50, write(B), commit

- 역시 서로 간섭이 없고, `T₁`, `T₂`의 실행 순서만 다름
- 결과적으로도 일관성이 보장되며 `A + B` 유지됨

---

### 🔹 Serializable Schedule 3
- `T₁`과 `T₂`의 연산이 **섞여 실행되지만**, 결과는 Schedule 1과 동일함 → `serializable`
T₁: read(A), A := A - 50, write(A)  
T₂: read(A), temp := A * 0.1, A := A - temp, write(A)  
T₁: read(B), B := B + 50, write(B), commit  
T₂: read(B), B := B + temp, write(B), commit

- 이처럼 전체 순서가 직렬적(serial schedule)과 **논리적으로 동일한 경우**를 **serializability**라고 부름
- 트랜잭션 병행 처리 성능을 확보하면서도 일관성 유지 가능

---

### 🔹 Schedule 4 (일관성 깨짐 예시)

- 아래 schedule은 `A + B`의 값을 **보존하지 않음**

T₁: read(A), A := A - 50  
T₂: read(A), temp := A * 0.1, A := A - temp, write(A), read(B)  
T₁: write(A), read(B), B := B + 50, write(B), commit  
T₂: B := B + temp, write(B), commit
- 문제 원인:
  - `T₁`과 `T₂`가 모두 `read(A)`를 한 후, `T₁`이 먼저 `write(A)`함
  - 이후 `T₂`도 `A`를 수정하여 덮어쓰면서 `T₁`의 결과를 덮어버림 (lost update)
  - 그 결과, 최종적으로 `A + B`가 원래의 값보다 **작아짐** → 데이터베이스의 **일관성 위반**

---

### ✅ 추가 설명: Serializability vs. Consistency
- `Serial schedule`: 트랜잭션을 **완전히 순차적**으로 실행 → 항상 일관성 보장
- `Serializable schedule`: 병렬로 실행되더라도 결과가 serial schedule과 **동일한 효과**를 가지면 OK
- 반면, Schedule 4처럼 의존 관계나 동기화 없이 병렬로 처리하면 **일관성 손상** 위험이 있음

## 📌 Serializability & Conflict Serializability
### 🔹 Serializability 개념
- **기본 가정**: 각 트랜잭션은 자체적으로 데이터베이스의 일관성을 유지함
- **Serial execution**: 트랜잭션을 한 번에 하나씩 순차적으로 실행하면 전체적으로 일관성을 유지할 수 있음
- **Serializable schedule**: 어떤 스케줄이 **어떤 순서의 직렬 스케줄과 동일한 결과를 갖는다면**, 해당 스케줄은 serializable임

### 🔹 Serializability의 종류
- **Conflict Serializability**: 충돌이 없는 명령어들을 바꿔서 직렬 스케줄로 만들 수 있는 경우
- **View Serializability**: 결과적으로 읽고 쓰는 데이터 항목의 관점에서 직렬 스케줄과 같은 결과를 제공하는 경우

---

### 🔹 Simplified View of Transactions
- 분석을 단순화하기 위해 `read`와 `write` 외의 연산은 생략함
- 트랜잭션이 중간 계산을 하더라도, 이는 로컬에서 처리된다고 가정
- 따라서 스케줄 분석 시, `read`, `write`만 고려함

---

### 🔹 Conflicting Instructions (충돌 연산)
- 트랜잭션 `Tᵢ`의 연산 `Iᵢ`와 `Tⱼ`의 연산 `Iⱼ`가 다음 조건 중 하나라도 만족하면 **conflict**가 발생함:
  1. `read(Q)` – `read(Q)` → conflict 아님
  2. `read(Q)` – `write(Q)` → conflict 발생
  3. `write(Q)` – `read(Q)` → conflict 발생
  4. `write(Q)` – `write(Q)` → conflict 발생

- 충돌이 발생하면 두 연산 사이의 **순서가 강제**됨
- 충돌이 없는 경우, 명령어를 **순서를 바꿔도 결과는 동일**함

---

### 🔹 Conflict Serializability 정의
- 스케줄 `S`가 **충돌하지 않는 명령어들끼리의 위치 교환**을 통해 스케줄 `S′`로 바뀔 수 있고, `S′`가 직렬 스케줄이라면,
- 스케줄 `S`는 `conflict serializable`임

---

### 🔹 예시 1: Conflict Serializable인 스케줄 (Schedule 3 → Schedule 6)
- **Schedule 3** (섞여 있는 연산):
T₁: read(A), write(A)  
T₂: read(A), write(A)  
T₁: read(B), write(B)  
T₂: read(B), write(B)

- **Schedule 6** (T₁ 다음에 T₂ 실행된 직렬 스케줄):
T₁: read(A), write(A), read(B), write(B)  
T₂: read(A), write(A), read(B), write(B)
→ Schedule 3은 충돌 없는 swap을 통해 Schedule 6으로 변환 가능  
→ 따라서 **Conflict Serializable**

---

### 🔹 예시 2: Conflict Serializable이 아닌 경우
- 다음 스케줄은 conflict serializable하지 않음:
T₃: read(Q), write(Q)  
T₄: write(Q)

- 이유:
  - `T₃.write(Q)` 와 `T₄.write(Q)`는 conflict 발생
  - swap을 통해 `T₃`, `T₄` 순서나 반대 순서로 **직렬화 불가능**

→ 이 스케줄은 **Conflict Serializability를 만족하지 않음**

## 📌 View Serializability & 기타 직렬성 개념
### 🔹 View Serializability 정의
- 두 스케줄 `S`, `S′`가 **동일한 트랜잭션 집합**을 포함할 때, 아래 조건 3가지를 모두 만족하면 `view equivalent`함:
1. **초기 읽기 보존**: `S`에서 트랜잭션 `Tᵢ`가 데이터 항목 `Q`의 초기 값을 읽었다면, `S′`에서도 `Tᵢ`는 동일한 초기 값을 읽어야 함

2. **중간 쓰기 연산 보존**: `S`에서 `Tᵢ`가 `read(Q)`하고 그것이 `Tⱼ`의 `write(Q)` 결과였다면, `S′`에서도 `Tᵢ`는 `Tⱼ`의 같은 `write(Q)` 결과를 읽어야 함

3. **최종 쓰기 보존**: `S`에서 최종적으로 `write(Q)`를 수행한 트랜잭션이 `Tₖ`라면, `S′`에서도 마지막 `write(Q)`는 `Tₖ`이 수행해야 함

- `view equivalence`는 오직 `read`, `write` 연산만을 기반으로 판단됨

---
### 🔹 View Serializability의 특성
- 스케줄 `S`가 직렬 스케줄과 **view equivalent**하다면, `S`는 **view serializable**
- 모든 conflict-serializable한 스케줄은 view-serializable임  
  하지만 그 반대는 항상 성립하지 않음
- 예시 스케줄:
T₇: read(Q), write(Q)  
T₈: write(Q)  
T₉: write(Q)
→ 이 스케줄은 **view serializable**하지만, **conflict serializable은 아님**

- 이러한 경우는 보통 **blind write** (읽기 없이 쓰기) 연산이 있을 때 발생함

---
### 🔹 추가 예시 분석
#### ⬛ 예시: view serializable인지 판단

|   | T1 | T2 | T3 |
|---|----|----|----|
| 1 | R(Q) |     |    |
| 2 | W(Q) | W(Q) |    |
| 3 |     | R(Q) |    |
| 4 |     |     | R(Q) |
| 5 |     |     | W(Q) |

- 각 트랜잭션의 `read(Q)`와 `write(Q)`의 **관계 분석**이 필요함
- 초기 값 읽기, 중간 값 추적, 최종 쓰기 등 조건을 따져야 `view serializable` 여부 판단 가능

---
### 🔹 기타 Serializability 개념
- 다음 스케줄은 `T₁ → T₅` 순서의 **직렬 스케줄과 동일한 결과**를 만들지만,
  - `conflict equivalent`하지도 않고
  - `view equivalent`하지도 않음

T₁: read(A), A := A - 50, write(A), read(B), B := B + 50, write(B)  
T₅: read(B), B := B - 10, write(B), read(A), A := A + 10, write(A)

- 이유:
  - 읽기/쓰기 외의 연산(예: `A := A + 10`)에 의한 의미적 연산 분석이 필요함
- 이처럼 단순한 `read`/`write` 분석만으로 판단이 어려운 경우가 있음

## 📌 Testing for Serializability & Schedule Recoverability
### 🔹 Precedence Graph & Conflict Serializability
- **Precedence graph**란 각 트랜잭션을 노드로 하여, **conflict가 존재하는 경우 방향성 간선**을 연결한 그래프임
- `Tᵢ → Tⱼ` 간선은 `Tᵢ`가 충돌 항목을 `Tⱼ`보다 먼저 접근했음을 의미함

- **Conflict Serializability 조건**:  
  스케줄이 conflict serializable하려면, **precedence graph에 cycle이 없어야 함**(acyclic)
- 이러한 경우 **위상 정렬(topological sort)**을 통해 직렬 스케줄과 동등한 순서를 도출할 수 있음

---

### 🔹 View Serializability 검사
- Precedence graph는 **view serializability** 검사에는 사용 불가
  - 이유: view serializability는 쓰기 값의 출처를 고려해야 하므로 더 복잡함
- View serializability 검사는 **NP-complete 문제**로, **효율적인 알고리즘이 존재하지 않음**
- 따라서, 실무에서는 일부 조건만 만족하는 경우 view serializable로 판단하는 **휴리스틱 기반 검사** 사용

---

### 🔹 Conflict vs. View Serializability 비교
- **Conflict Serializability**
  - 간단하고 검사 쉬움 → **낮은 동시성, 낮은 성능**
  - 실제 DBMS에서 자주 사용됨

- **View Serializability**
  - 더 많은 스케줄을 허용함 → **높은 동시성, 높은 성능**
  - 하지만 검사하기 어렵고 계산 비용이 큼
  - 실용적으로는 제한된 형태로만 사용됨

- 시각적 도식  
  `Conflict Serializable ⊆ View Serializable`

---

### 🔹 Recoverable Schedules (회복 가능한 스케줄)
- **Recoverable Schedule**: 트랜잭션 `Tᵢ`가 `Tⱼ`가 쓴 데이터를 읽었다면, `Tⱼ`의 commit이 반드시 `Tᵢ`의 commit보다 먼저 발생해야 함

- 예시 스케줄 (회복 불가능한 경우):

T₈: read(A), write(A), read(B)  
T₉: read(A), commit

- 문제점:
  - `T₉`는 아직 commit되지 않은 `T₈`의 값을 읽고 커밋함
  - 만약 `T₈`이 나중에 abort된다면, `T₉`는 **일관되지 않은 데이터를 커밋**한 것이 되어 위험함

- **요구 사항**: 트랜잭션 간의 읽기-쓰기 종속성이 있을 경우, 쓰기 트랜잭션이 먼저 커밋되어야 데이터베이스가 일관성을 유지할 수 있음

## 📌 Cascading Rollbacks & Cascadeless Schedules

### 🔹 Cascading Rollback (연쇄 롤백)

- 하나의 트랜잭션 실패가 여러 트랜잭션의 연쇄적인 롤백을 유발하는 현상
- 다음 예시 스케줄에서, `T₁₀`이 실패하여 abort되면 `T₁₁`, `T₁₂`도 모두 롤백되어야 함:

T₁₀: read(A), read(B), write(A), abort  
T₁₁: read(A), write(A)  
T₁₂: read(A)

- 문제점:
  - `T₁₁`과 `T₁₂`는 `T₁₀`이 갱신한 `A`를 읽었기 때문에 `T₁₀`이 abort되면 그들의 작업도 무효가 됨
  - 이는 **많은 작업이 되돌려지는 심각한 낭비**를 유발할 수 있음

---

### 🔹 Cascadeless Schedule (비연쇄적 스케줄)
- 정의: **cascading rollback이 발생하지 않도록 보장된 스케줄**
- 조건:
  - 어떤 트랜잭션 `Tⱼ`가 `Tᵢ`가 쓴 데이터를 읽는 경우, **`Tᵢ`는 이미 commit된 상태**여야 함
  - 즉, **항상 commit된 데이터만 읽도록 제한**

- 특징:
  - 모든 cascadeless 스케줄은 **항상 recoverable**
  - 데이터베이스는 이러한 스케줄을 **우선적으로 유지하도록 제어**하는 것이 바람직함

- 핵심 이점:
  - 하나의 트랜잭션 실패가 **다른 트랜잭션에 영향을 주지 않음**
  - 시스템 안정성 및 회복 효율성을 높임
