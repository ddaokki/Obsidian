
# B+-Tree: 슬라이드 8–21 해석 및 설명

## 📘 슬라이드 8: B+-트리 예시
- Instructor 파일을 위한 B+-트리 구조 예시 (n=6)
- 리프 노드: 3~5개 값 포함 (⌈(n−1)/2⌉ = 3, n−1 = 5)
- 비-루트 내부 노드: 3~6개 자식 (⌈n/2⌉ = 3, n = 6)
- 루트 노드는 최소 2개의 자식 필요

## 📘 슬라이드 9: B+-트리에 대한 관찰
- 노드 간 논리적 인접 ≠ 물리적 인접 (포인터로 연결)
- 비-리프 수준은 희소 인덱스 계층 구조 형성
- 트리 높이 예측:
  - 루트 다음 레벨: ≥ 2 * ⌈n/2⌉ 값
  - 그 다음 레벨: ≥ (2 * ⌈n/2⌉)^2 값
- K개의 키가 있을 때 높이 ≤ ⌈log⌈n/2⌉(K)⌉
- 검색 비용 = 트리 높이

## 📘 슬라이드 10: B+-트리 탐색 함수

```text
function find(v)
1. C = root
2. while C는 리프 노드 아님:
   i = v ≤ Kᵢ 만족하는 최소 i
   없으면 C = 마지막 포인터
   v = Kᵢ면 C = Pᵢ+1
   그 외는 C = Pᵢ
3. 리프 노드에서 Ki = v 이면 Pᵢ 반환
4. 아니면 null
```

## 📘 슬라이드 11: 범위 쿼리 (Range Queries)
- 키 범위 (lower bound, upper bound)에 포함된 레코드 반환
- `findRange(lb, ub)` 사용
- 실제 구현은 `next()` 함수 기반 반복자 인터페이스 제공

## 📘 슬라이드 12: 성능 분석
- 노드 크기 ≒ 디스크 블록 크기 (보통 4KB)
- n ≒ 100 (항목당 40B일 때)
- 100만 키 값 → log₅₀(1,000,000) ≈ 4 → 최대 4개 노드 접근
- 이진 트리 → 약 20개 노드 접근 필요
- 노드 접근은 디스크 I/O 수반 → 20ms 수준

## 📘 슬라이드 13: 중복 키 처리
- 키 ai가 중복되면 (ai, Ap) 형태의 복합 키 사용
  - Ap: 기본키, 레코드 ID 등 고유성 보장 속성
- ai = v 검색 → 범위 쿼리로 처리 (v, -∞) ~ (v, +∞)
- 클러스터 인덱스: 연속 접근
- 비-클러스터 인덱스: 각 레코드마다 I/O 발생 가능

## 📘 슬라이드 14: 삽입 개요
- 레코드는 이미 파일에 존재한다고 가정
- k: 검색 키, ptr: 포인터
1. 삽입 위치 리프 노드 탐색
2. 공간 있으면 (k, ptr) 삽입
3. 공간 없으면 리프 노드 분할 후 부모에 전파

## 📘 슬라이드 15: 리프 노드 분할
- (k, ptr) 포함된 항목들 정렬
- ⌈n/2⌉개: 기존 노드 / 나머지: 새 노드 p
- 새 노드의 최소 키 k를 부모에 삽입
- 부모도 꽉 찼으면 재귀적 분할

## 📘 슬라이드 16: 내부 노드 분할
- (k, p) 삽입 시 내부 노드가 꽉 찬 경우:
1. 기존 노드 N → 임시 버퍼 M에 복사
2. M에 (k, p) 삽입
3. 앞 절반 → 기존 노드 N
4. 뒷 절반 → 새 노드 N'
5. 중간 키 K를 부모에 삽입

## 📘 슬라이드 17–18: 리프 삽입 예시 (‘Adams’ 삽입)
- ‘Adams’ 삽입으로 리프 노드 분할 발생
- 분할된 노드는 순차적으로 연결됨

## 📘 슬라이드 19–21: 리프 + 내부 노드 삽입 예시 (‘Lamport’ 삽입)
- ‘Lamport’ 삽입 → 리프 분할
- ‘Kim’ 키 이후 비-리프 노드도 분할 발생
- 중간 키가 상위 노드로 승격됨
- 루트까지 전파될 경우 트리 높이 1 증가 가능
