## Instruction Execution
- PC → 명령어 메모리(instruction memory) 접근, 명령어를 fetch함
- Register 번호 → register file에서 해당 레지스터의 값을 읽음
- 명령어 종류(instruction class)에 따라 다음 단계 분기

### ▸ ALU를 사용하여 계산
- 산술 연산 결과 계산 (e.g., add, sub)
- 메모리 주소 계산 (load/store 명령어용)
- 분기 명령어의 target address 계산

### ▸ 데이터 메모리 접근
- load: 메모리에서 데이터 읽기
- store: 메모리에 데이터 쓰기

### ▸ PC 갱신
- 일반 명령어: PC ← PC + 4
- 분기 명령어: PC ← target address

### 🔄 명령어 사이클 단계 요약 (우측 그림 기준)
- Fetch: PC에 있는 명령어 읽기 (PC = PC + 4)
- Decode: 명령어 해석 및 레지스터 읽기
- Exec: ALU 연산 또는 메모리 접근 수행
- 이후 다시 Fetch 단계로 순환

## CPU Overview
- **PC (Program Counter)**는 instruction memory에 접근하여 현재 명령어를 가져옴
- 명령어는 **Registers** 블록으로 전달되어 필요한 레지스터 번호와 데이터를 읽음
- ALU는 연산을 수행하고 결과를 메모리로 보낼 수도 있으며, 이 때 계산된 주소를 **Data memory**에 전달함
- 데이터 메모리는 주소에 해당하는 값을 읽거나 쓸 수 있음
- PC는 일반적으로 `PC + 4`가 되거나 분기 명령일 경우 계산된 주소로 변경됨
- 오른쪽 상단의 작은 그림은 Fetch → Decode → Exec의 반복 사이클을 나타냄

## Multiplexers
- CPU 회로에서 여러 입력 중 하나를 선택하여 출력으로 전달할 때 **Multiplexer(다중 선택기)**를 사용함
- 단순히 회로를 직접 연결해서는 안 됨  
  → 하나의 선로에 여러 소스가 동시에 연결되면 충돌이 발생하기 때문
- 빨간 원으로 표시된 부분은 서로 다른 데이터 경로가 겹치는 지점이며, 이들을 분리하고 선택적으로 사용하기 위해 multiplexer가 필요함

### Multiplexer가 필요한 이유 (슬라이드 기준)
- **PC 업데이트 경로**: `PC + 4`와 분기 주소 중 하나를 선택해야 함
- **레지스터 쓰기 데이터 선택**: ALU 결과와 메모리에서 읽은 데이터 중 어떤 것을 쓸지 선택
- **ALU 입력 선택**: 두 번째 입력으로 레지스터 값 또는 즉시값(immediate)을 선택
