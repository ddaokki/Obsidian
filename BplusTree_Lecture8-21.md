
# B+-트리 상세 해설 (슬라이드 8~21)

## 📘 슬라이드 8: B+-트리 예시

- B+-트리 예시: Instructor 파일에 대한 인덱스를 나타냅니다. 
- 계층적 구조에서 `n=6`일 경우:
  - 리프 노드는 ⌈(n–1)/2⌉ = 3개 이상, 최대 5개의 키값을 가짐.
  - 비-루트 내부 노드는 ⌈n/2⌉ = 3개 이상, 최대 6개의 자식을 가짐.
  - 루트 노드는 최소한 두 개의 자식을 가져야 함.

💡 **설명**:  
이 규칙은 B+-트리의 균형성과 효율성을 유지하기 위한 조건입니다. 즉, 모든 노드가 일정 범위 내의 자식/값 개수를 갖도록 하여 탐색 성능을 보장합니다.

---

## 📘 슬라이드 9: B+-트리에 대한 관찰

- 노드 간 연결은 포인터로 구성되어 있으며, 논리적으로 가까운 블록이 물리적으로 가까울 필요는 없음.
- 상위 수준 비-리프 노드는 희소 인덱스 역할.
- 트리의 높이는 매우 작음:
  - 루트 하위 레벨: 최소 2 * ⌈n/2⌉ 개의 값
  - 그 다음 레벨: 최소 (2 * ⌈n/2⌉)^2
- K개의 키가 존재하면, 트리의 높이는 최대 ⌈log⌈n/2⌉(K)⌉
- 검색 효율성: 검색 비용은 트리의 높이에 비례함.

💡 **설명**:  
트리의 레벨이 증가할수록 포함 가능한 키의 수는 기하급수적으로 늘어나기 때문에 실제 데이터베이스에서는 3~4레벨 정도의 낮은 높이로도 수백만 개의 레코드를 효율적으로 탐색할 수 있습니다.

---

## 📘 슬라이드 10: B+-트리에서의 검색

### 함수 정의: `find(v)`
1. `C = root`  
2. C가 리프 노드가 아닐 때까지 반복:
   - 가장 작은 `i`를 찾아서 `v ≤ Kᵢ` 인 경우
   - 해당 i가 없으면 마지막 포인터 선택
   - `v = Kᵢ`이면 다음 포인터(Pᵢ₊₁) 선택
   - 그렇지 않으면 Pᵢ 선택
3. 리프 노드에서 `Kᵢ = v` 이면 Pᵢ 반환
4. 없으면 null 반환

💡 **설명**:  
검색은 루트부터 시작해서 키 비교를 통해 적절한 자식 노드를 따라가며, 리프 노드에서 정확한 값을 찾습니다.

---

## 📘 슬라이드 11: 범위 쿼리

- 주어진 범위 내의 모든 키 값을 가지는 레코드 반환.
- 예: `findRange(lb, ub)` → 조건에 맞는 레코드 집합 반환
- 실제 구현에서는 `next()` 함수 기반의 반복자(iterator) 형태로 하나씩 가져옴.

💡 **설명**:  
B+-트리는 리프 노드들이 링크드 리스트 형태로 연결되어 있기 때문에, 범위 탐색이 매우 효율적으로 수행됩니다.

---

## 📘 슬라이드 12: 성능 분석

- 노드 = 디스크 블록 (보통 4KB)
- 인덱스 항목 ≈ 40바이트 → n ≈ 100
- 키 수 100만 개일 경우:
  - log₅₀(1,000,000) ≈ 4 → 최대 4개의 노드 접근
- 이진 트리일 경우 약 20개 노드 접근 필요
- 노드 접근 = 디스크 I/O → 약 20ms 소요

💡 **설명**:  
B+-트리는 I/O 비용을 줄이기 위해 노드 크기를 디스크 블록에 맞춰 최적화한 구조입니다.

---

## 📘 슬라이드 13: 중복 키 처리

- 키 `aᵢ`가 중복일 경우, (aᵢ, Ap)의 복합 키 사용
  - Ap는 고유 식별자 (예: 기본키, 레코드 ID 등)
- `aᵢ = v` 검색 → `(v, -∞)` ~ `(v, +∞)` 범위 쿼리로 처리
- 클러스터 인덱스: 연속 접근 가능
- 비-클러스터 인덱스: 레코드마다 별도 I/O 필요

💡 **설명**:  
복합 키를 통해 중복 값을 다룰 수 있으며, 클러스터링 여부에 따라 실제 레코드 접근 효율이 달라집니다.

---

## 📘 슬라이드 14: 삽입 개요

- 레코드는 파일에 이미 추가된 상태
- `k = 검색 키`, `ptr = 레코드 포인터`
1. 적절한 리프 노드 찾기
2. 공간이 있으면 (k, ptr) 삽입
3. 공간이 없으면 노드 분할 → 상위 노드 갱신

---

## 📘 슬라이드 15: 리프 노드 분할

- (k, ptr) 포함해 정렬된 상태로 n개의 항목을 준비
- 앞쪽 ⌈n/2⌉ → 기존 노드, 나머지 → 새 노드 p
- 새 노드 p의 최소 키 k를 부모 노드에 삽입
- 부모 노드도 꽉 차 있으면 재귀적으로 분할

---

## 📘 슬라이드 16: 내부 노드 분할

1. 현재 노드를 임시 메모리 공간 M에 복사
2. (k, p) 삽입
3. 앞쪽 절반 → 원래 노드
4. 뒷쪽 절반 → 새 노드 N'
5. 중간 키 k를 부모 노드에 삽입

💡 **설명**:  
내부 노드는 키를 기준으로 트리 구조를 유지하므로, 키와 포인터 쌍을 유지한 채 절반씩 분리합니다.

---

## 📘 슬라이드 17~21: 삽입 예시 (애니메이션 설명)

- ‘Adams’ 삽입 → 리프 노드 분할 필요
- ‘Lamport’ 삽입 → 리프 및 내부 노드 모두 분할 필요
- 중간 키를 부모 노드로 승격
- 루트 노드까지 분할이 전파될 수 있으며, 트리 높이가 1 증가할 수 있음

💡 **설명**:  
삽입 과정에서 리프 노드의 분할은 빈번하게 발생하며, 경우에 따라 루트까지 영향을 미쳐 트리 구조가 조정됩니다.
