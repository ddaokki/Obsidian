## Network Layer: Internet & IP Addressing

### 🌐 Network Layer 기능 요약
- **Path-selection algorithms**: 경로 선택 알고리즘 (OSPF, BGP, SDN 등)
- **IP protocol**: IP 데이터그램 형식 정의, 주소 지정, 패킷 처리 방식 규정
- **ICMP protocol**: 오류 보고 및 라우터 간 제어 메시지 전달

---

### 📦 IP Datagram Format
- **헤더 필드 구성** (32비트 단위)
  - `ver`: IP 버전 (예: IPv4)
  - `head len`: 헤더 길이
  - `type of service`: QoS 관련 필드 (diffserv, ECN)
  - `length`: 전체 데이터그램 길이
  - `identifier`, `flags`, `fragment offset`: 단편화 관련
  - `TTL`: 최대 홉 수
  - `protocol`: 상위 계층 프로토콜 (TCP, UDP 등)
  - `checksum`: 헤더 오류 검사
  - `src/dst IP`: 출발지/목적지 IP 주소
  - `options`: 선택 필드
  - `payload`: 데이터 (보통 TCP 또는 UDP 세그먼트)

- **오버헤드**:
  - TCP: 20바이트
  - IP: 20바이트
  - TCP+IP 합산 40바이트 + 상위 계층 오버헤드

---

### 🧭 IP Addressing: 기본 개념
- **IP 주소**:
  - 32비트 식별자
  - 호스트 또는 라우터의 각 **인터페이스**에 부여됨
- **Interface**:
  - 호스트/라우터와 물리 링크 간 연결 지점
  - 라우터는 보통 여러 개의 인터페이스를 가짐
  - 호스트는 일반적으로 1~2개

- **IP 주소 표기법**:
  - 점 10진법 표기(dotted-decimal): 예) 223.1.1.1
  - 이진법으로는 32비트: 예) 11011111 00000001 00000001 00000001

---

### 🔌 인터페이스 간 연결 방식
- **유선 인터페이스**:
  - 이더넷 스위치를 통해 연결됨
- **무선 인터페이스**:
  - WiFi 베이스 스테이션을 통해 연결됨
- 슬라이드에서는 라우터 없이 직접 연결된 인터페이스 구조를 단순화하여 설명함

> ✅ 실제 연결 구조는 이후 장(6, 7)에서 더 자세히 학습함


\## Subnets, CIDR, and IP Address Assignment

### 🌐 What is a Subnet?
- **서브넷(subnet)**이란 라우터를 거치지 않고 직접 통신 가능한 인터페이스들의 집합임
- IP 주소는 두 부분으로 구성됨:
  - **서브넷 부분(subnet part)**: 동일 서브넷에 속한 디바이스들은 상위 비트를 공유
  - **호스트 부분(host part)**: 각 디바이스 고유 식별자

### 🧱 서브넷 정의 방법
- 각 인터페이스를 그 호스트 또는 라우터로부터 분리하여 고립된 "섬"을 만들면 하나의 서브넷이 됨
- 예: `/24` 서브넷 마스크는 상위 24비트가 서브넷 식별에 사용됨
  - `223.1.1.0/24`, `223.1.2.0/24`, `223.1.3.0/24` 등의 서브넷 생성

---

### 🔎 Subnet 예시 해석
- `223.1.1.0/24` → 223.1.1.* 대역의 모든 호스트
- `223.1.7.0/24`, `223.1.9.0/24`, `223.1.8.0/24` → 각기 다른 물리적 서브넷
- 실제 네트워크 토폴로지에서 서브넷 구분은 라우터로 구분되며, 각 링크는 별개의 서브넷이 됨

---

### 📌 IP Addressing: CIDR (Classless Inter-Domain Routing)
- **CIDR**은 서브넷 비트 길이를 유연하게 정의 가능하게 해줌
- 주소 형식: `a.b.c.d/x`
  - `x`는 서브넷에 사용되는 비트 수
  - 예: `200.23.16.0/23`은 상위 23비트가 서브넷 식별자
- 장점:
  - 주소 공간 절약
  - 경로 요약(Routing Aggregation)에 효과적

---

### ❓ How to Get an IP Address?

**두 가지 질문**:
1. **호스트가 IP 주소를 얻는 방법?**
   - 수동 설정: 시스템 설정 파일에 직접 지정
   - **DHCP (Dynamic Host Configuration Protocol)**:
     - 서버로부터 자동으로 IP를 부여받음 (plug-and-play)

2. **네트워크가 자체 IP 주소를 얻는 방법?**
   - 상위 기관(ISP 또는 관리기관)으로부터 서브넷 주소를 할당받음

## DHCP (Dynamic Host Configuration Protocol)

### 🎯 DHCP의 목적
- 호스트가 네트워크에 접속할 때, **IP 주소를 동적으로 자동 할당**받도록 함
- 특징:
  - 연결된 동안만 주소를 보유함 → **주소 재사용 가능**
  - **모바일 사용자**에게 유리함
  - 사용 중인 주소는 **갱신(renew)** 가능

---

### 🔄 DHCP 동작 순서
1. **DHCP Discover**: 클라이언트가 네트워크에 DHCP 서버가 있는지 브로드캐스트
2. **DHCP Offer**: 서버가 사용 가능한 IP 주소 제안
3. **DHCP Request**: 클라이언트가 제안받은 IP 주소 요청
4. **DHCP ACK**: 서버가 IP 주소 할당을 승인

> Discover/Offer는 생략 가능 (클라이언트가 이전 주소를 기억하고 있는 경우)

---

### 🖥️ DHCP Client-Server 시나리오
- 일반적으로 DHCP 서버는 **라우터에 내장**되어 있고, 해당 라우터에 연결된 서브넷 전체에 대해 IP를 할당함
- 새로 접속하는 클라이언트는 해당 라우터의 DHCP 서버로부터 주소를 받음

---

### ✉️ DHCP 메시지 흐름 요약
- 모든 메시지는 브로드캐스트 혹은 유니캐스트로 전송되며, **UDP/IP** 위에서 동작
- DHCP 메시지는 다음 계층으로 캡슐화됨:
  - DHCP → UDP → IP → Ethernet

---

### 📦 DHCP가 제공하는 정보
DHCP는 단순히 IP 주소만 제공하는 것이 아님:

- **클라이언트가 사용할 기본 게이트웨이 주소**
- **DNS 서버의 IP 주소 및 이름**
- **서브넷 마스크** (주소 중 어느 부분이 네트워크이고 어느 부분이 호스트인지 구분)

---

### 🛠 DHCP 예제 흐름
1. 노트북이 DHCP REQUEST를 보내기 위해 DHCP 메시지를 작성
2. DHCP 메시지는 UDP → IP → Ethernet 순서로 캡슐화되어 브로드캐스트됨
3. 라우터 내장 DHCP 서버가 메시지를 수신하고, 해당 요청을 해석
4. 서버는 IP 주소, 게이트웨이, DNS 정보를 포함한 DHCP ACK 전송
5. 클라이언트는 IP 주소를 포함한 네트워크 설정 정보를 수신하여 정상적으로 네트워크에 연결됨

> DHCP는 현대 네트워크에서 **자동 구성 및 확장성**을 제공하는 핵심 프로토콜임

## IP Address 할당 방식과 계층적 주소 구조

### 🔹 네트워크는 어떻게 IP 주소를 받는가?
- 네트워크는 ISP로부터 할당된 주소 공간의 일부를 배정받음
- 예: ISP가 `200.23.16.0/20` 블록을 보유할 경우, 이를 여러 조직에 나누어 `/23` 단위로 할당 가능
  - Organization 0 → `200.23.16.0/23`
  - Organization 1 → `200.23.18.0/23`
  - …
  - Organization 7 → `200.23.30.0/23`

---

### 🔹 계층적 주소 구조 (Hierarchical Addressing)
- ISP는 각 고객(조직)에게 IP 주소 블록을 할당함
- ISP는 상위 ISP로부터 할당받은 큰 주소 블록을 묶어서 광고 가능
  - 예: Fly-By-Night-ISP는 `200.23.16.0/20` 전체 주소를 한 번에 광고
- 장점: 라우팅 테이블 크기 축소, 광고 효율성 증가

---

### 🔹 더 구체적인 경로 광고 (Specific Route Advertisement)
- 만약 Organization 1이 ISP를 변경하여 `ISPs-R-Us`로 이동하면:
  - 기존 ISP는 `200.23.16.0/20`만 광고
  - 새로운 ISP는 `200.23.18.0/23`을 **별도로** 광고하여 더 구체적인 경로 제공
- 이렇게 되면 인터넷 상에서 **Organization 1만을 위한 독립적 경로**가 생김

---

## IP 주소 할당 관련 사항 정리

### 🔸 ISP는 어떻게 주소 블록을 받는가?
- **ICANN** (Internet Corporation for Assigned Names and Numbers)
  - 전 세계 IP 주소를 관리
  - 5개의 **지역 인터넷 등록기관(RIR)**을 통해 ISP 및 로컬 등록기관에 주소 할당
  - DNS 루트 존(.com, .edu 등) 관리도 담당

### 🔸 IPv4 주소가 충분한가?
- 2011년 ICANN은 마지막 IPv4 주소 블록을 지역 등록기관에 할당
- **NAT**를 통해 IPv4 주소 고갈 문제 일부 해결
- 궁극적 해결책은 **IPv6** (128비트 주소 공간)


\## NAT: Network Address Translation

### 🔹 NAT 개념
- **NAT (Network Address Translation)**: 로컬 네트워크 내 모든 디바이스가 외부에서는 **하나의 공용 IP 주소**만 사용하는 방식
- 내부 주소 예: 10.0.0.0/24  
- 외부에서 보이는 주소: 예) 138.76.29.7
- 로컬 네트워크를 나가는 모든 데이터그램은 동일한 NAT IP 주소를 가지며, 포트 번호를 통해 구별됨

---

### 🔹 NAT의 동작 방식

#### 1. Outgoing Datagram 처리
- 내부 디바이스가 외부로 데이터그램을 보낼 때:
  - 출발지 IP와 포트 번호 → NAT IP와 새 포트 번호로 대체
  - 이 정보는 NAT 테이블에 저장됨

#### 2. NAT 테이블 기록
- (내부 IP, 포트) ↔ (공용 NAT IP, 포트) 쌍을 **NAT 변환 테이블**에 저장

#### 3. Incoming Datagram 처리
- 외부로부터 수신되는 응답은 NAT 테이블을 참조하여
  - NAT IP/포트 → 원래 내부 IP/포트로 복원 후 전달

---

### 🔹 NAT 작동 예시
1. 호스트 `10.0.0.1`이 포트 3345에서 외부 IP `128.119.40.186`의 포트 80으로 데이터그램을 보냄
2. NAT 라우터는 소스 주소를 `138.76.29.7:5001`로 변경하고 NAT 테이블에 기록
3. 응답 도착: 목적지가 `138.76.29.7:5001`
4. NAT는 다시 이를 내부 주소 `10.0.0.1:3345`로 변환해 전달

---

### 🔹 NAT의 장점
- 내부 네트워크의 모든 호스트가 **하나의 공용 IP 주소만 사용**
- 내부 주소 체계 변경 가능 (외부에 알릴 필요 없음)
- ISP를 변경해도 내부 IP 구조 변경 불필요
- 보안성 향상: 외부에서 내부 호스트 직접 접근 불가

---

### 🔹 NAT 관련 논란 및 현실
- **논란**:
  - 라우터는 원칙적으로 3계층까지만 처리해야 하는데, 포트 번호는 4계층임
  - 주소 고갈 문제는 **IPv6**로 해결되어야 한다는 주장
  - **종단 간 통신(end-to-end)** 원칙 위배
  - **NAT Traversal** 문제: NAT 뒤에 있는 서버에 외부 클라이언트가 접근하기 어려움

- **현실**:
  - 가정, 기업, 이동통신망(4G/5G 등)에서 광범위하게 사용 중
  - 현재로서는 없어질 수 없는 네트워크 기술임

## IPv6: 동기 및 패킷 구조

### 🔹 IPv6 도입 배경 (Motivation)
- IPv4의 32비트 주소 공간은 고갈될 것이 명확하였음
- 추가 동기:
  - 고정 40바이트 헤더를 통해 **빠른 라우터 처리 가능**
  - **"flow" 기반** 트래픽 구분을 통한 네트워크 계층 처리 다양화 가능

---

### 🔹 IPv6 Datagram 구조
- 헤더 구성:
  - `ver`, `pri`: 버전과 우선순위
  - `flow label`: 동일 흐름의 데이터그램 식별
  - `payload len`, `next hdr`, `hop limit`: 페이로드 길이, 상위 프로토콜, 홉 제한
  - `source/destination address`: 128비트 주소
- IPv4와 비교 시 누락된 항목:
  - 체크섬 없음 → 라우터에서 처리 시간 단축
  - 단편화 없음 (발신지에서 단편화 처리)
  - 옵션 필드 없음 (상위 계층에서 처리)

> "Flow"의 정의는 명확히 정해져 있지 않으며, 실질적으로는 QoS 또는 리소스 예약을 위한 개념으로 활용될 수 있음

---

## IPv6 전환 및 터널링 (Transition & Tunneling)

### 🔹 IPv4 → IPv6 전환 문제
- 모든 라우터를 동시에 업그레이드할 수 없음 → 혼합 운영 필요
- 해결책: **터널링(Tunneling)**  
  - IPv6 데이터그램을 IPv4 패킷의 **payload**로 감싸 전송
  - 외부 IPv4 라우터는 IPv6 헤더를 인식하지 않고 단순히 전달함

> 실제 4G/5G 네트워크에서도 터널링은 자주 사용됨

---

### 🔹 터널링 및 캡슐화(Tunneling & Encapsulation)
- 예시 1: IPv6 네트워크가 이더넷으로 직접 연결됨 → 일반적인 링크 계층 캡슐화 사용
- 예시 2: IPv4 네트워크가 IPv6 라우터 사이를 연결 → **IPv4 패킷 안에 IPv6 패킷을 삽입**

→ 이 과정을 통해 IPv6 패킷은 IPv4만 인식하는 라우터를 투과 가능

---

### 🔹 논리적 vs 물리적 터널
- 논리적 관점: A → F 간 IPv6 통신은 연속적 경로처럼 보임
- 실제 물리적 관점:
  - 중간 노드(B, C, D)는 **IPv6-in-IPv4** 패킷을 처리
  - 외부 IPv4 헤더의 출발지는 B, 도착지는 E (터널의 양끝)

> 중요한 점은, 원래 패킷의 출발지/도착지인 A와 F는 **변하지 않고**, 터널의 IPv4 주소가 외부 헤더에 사용된다는 것임

### ✅ 요약
- IPv6는 주소 확장 외에도 **처리 최적화**와 **네트워크 트래픽 제어** 기능을 추가함
- 기존 IPv4 인프라와의 공존을 위해 터널링 기술이 필수적이며, 실제 다양한 환경에서 널리 활용됨

## IPv6: Adoption

### 🔹 도입 현황 (2023 기준)
- **Google 통계**: 약 40%의 클라이언트가 Google 서비스에 IPv6로 접속
- **NIST 통계**: 미국 정부 도메인의 약 1/3이 IPv6 사용 가능 상태

### 🔹 느린 도입 속도
- IPv6 도입은 매우 느리게 진행됨
  - IPv6 제안 이후 **25년 이상** 지났음에도 아직 IPv4가 주류
- 같은 기간 동안 애플리케이션 계층에서는 급속한 변화가 있었음:
  - 웹(WWW), 소셜 미디어, 스트리밍, 온라인 게임, 원격 회의 등

### ❓ 왜 이렇게 느렸는가?
- **호환성 문제**: 기존 IPv4 인프라와의 공존이 필요
- **즉각적인 필요 부족**: NAT 등 우회 기술로 당장 주소 고갈을 회피 가능
- **비용 문제**: 장비 및 소프트웨어 업그레이드 필요
- **비가시성 문제**: 최종 사용자 입장에서의 체감이 적음
- **운영 리스크**: 네트워크 운영자 입장에서 안정성이 검증된 IPv4 선호

> IPv6는 결국 필연적으로 전환해야 할 기술이지만, 실질적인 동기 부족이 느린 채택의 주요 원인으로 분석됨
