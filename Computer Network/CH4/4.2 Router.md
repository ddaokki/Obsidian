## Router architecture overview (1) - 구조적 개요
- 라우터는 **입력 포트 → 스위칭 패브릭 → 출력 포트** 구조로 동작함
- **Routing Processor**는 제어 평면(control plane)에서 작동하며, 라우팅 테이블과 포워딩 테이블을 생성함. 소프트웨어 기반으로 밀리초 단위에서 작동
- **Switching Fabric**은 고속 하드웨어로 구성되며, 데이터 평면(data plane)에서 동작하고 나노초 단위로 데이터그램을 전송함
- 입력 포트와 출력 포트는 포워딩 테이블 기반으로 데이터그램을 전송하고 수신함

### 제어 평면 vs 데이터 평면
- **Control Plane**: 라우팅 및 네트워크 관리 담당, 느리지만 지능적
- **Data Plane**: 실제 패킷 전송 담당, 빠르지만 단순함

## Router architecture overview (2) - 비유적 설명

- 비유적으로 보면, **Station Manager**는 라우팅 프로세서와 같으며, 어떤 방향으로 차량(패킷)을 보낼지 결정함
- **Roundabout**은 스위칭 패브릭에 해당하며, 차량이 빠르게 진입하고 나가는 구조를 상징함
- 차량이 진입하는 **entry stations**는 입력 포트, 빠져나가는 **exit roads**는 출력 포트를 나타냄

### 요약
- 라우터 내부 작동을 교통 시스템에 비유하여, 중앙의 결정과 빠른 전환을 시각적으로 이해 가능

## Input port functions (1)
### 포트 구성 요소
- **Physical Layer**: 비트 수준 수신 처리 (예: 이더넷 신호 처리)
- **Link Layer**: 링크 계층 수신 처리 (프레임 수신)
- **Lookup, Forwarding**: 포워딩 테이블을 이용해 출력 포트 결정
- **Queueing**: 스위칭 패브릭이 바쁠 경우 대기열에 저장

### Decentralized Switching
- 각 입력 포트에서 독립적으로 포워딩 결정 수행 (중앙 제어 없이)
- **match plus action**: 헤더 필드 값을 기준으로 출력 포트 결정 후 행동 지정
- 목표: **라인 속도(line speed)**로 입력 포트 처리 완료
- **Input Port Queuing**: 스위칭 패브릭 처리보다 빠르게 도착한 데이터그램은 큐에 저장됨

## Input port functions (2) - 전통적/일반화된 포워딩
### Destination-based forwarding (전통적)
- 목적지 IP 주소를 기준으로 출력 포트 결정
- 가장 기본적인 방식

### Generalized forwarding (일반화된 방식)
- 헤더의 다양한 필드(예: 포트번호, 프로토콜 등)를 활용해 포워딩 결정
- 소프트웨어 정의 네트워크(SDN)에서 활용됨

### 요약
- 입력 포트에서의 포워딩은 단순 IP 기반이 아닌 다양한 기준으로 확장 가능
- 입력 단계에서 최대한 빠르게 처리해야 전체 라우터 성능이 유지됨

## Destination-based forwarding
- 포워딩 테이블은 목적지 주소 범위(Destination Address Range)에 따라 각 패킷이 어느 링크 인터페이스로 가야 할지를 결정함
- 각 항목은 특정 주소 범위를 나타내며, 해당 범위 내의 목적지 주소를 가진 패킷은 지정된 인터페이스로 전송됨
- 예시에서는 특정 비트 범위에 따라 포트 0, 2, 3 중 하나로 포워딩함

### 문제 제기
- 주소 범위가 깔끔하게 나눠지지 않을 경우, 어떻게 가장 적절한 인터페이스를 결정할 것인가?

→ 이를 해결하기 위한 방식이 **Longest Prefix Matching**

## Longest Prefix Matching (개념)

- 주어진 목적지 주소에 대해 포워딩 테이블에서 **가장 긴 접두어(prefix)** 가 일치하는 항목을 선택하는 방식
- 단순히 처음 매치되는 항목이 아니라, 가장 많은 비트를 일치시키는 항목을 선택
- 이 방식은 주소 범위가 겹치는 경우, **가장 구체적인 경로**를 선택하게 함

### 예시
- 목적지 주소: `11001000 00010111 00010110 ...`
  - 포워딩 테이블에 여러 후보가 있는 경우, 가장 긴 접두어(예: 20비트, 22비트 등)를 가진 항목이 선택됨
## Longest Prefix Matching (예제 1)

- 목적지 주소: `11001000 00010111 00010...`
- 포워딩 테이블:
  - `11001000 00010111 00010***` → 인터페이스 0
  - `11001000 00010111 00011000` → 인터페이스 1
  - `11001000 00010111 00011***` → 인터페이스 2

→ `00010`으로 시작하는 패턴 중 가장 긴 접두어인 첫 번째 항목이 선택됨 → **인터페이스 0**

## Longest Prefix Matching (예제 2)

- 목적지 주소: `11001000 00010111 00011...`
- 포워딩 테이블:
  - `11001000 00010111 00010***` → 인터페이스 0
  - `11001000 00010111 00011000` → 인터페이스 1
  - `11001000 00010111 00011***` → 인터페이스 2

→ `00011`로 시작하는 패턴 중 가장 긴 접두어는 세 번째 항목 → **인터페이스 2**

## Longest Prefix Matching (예제 3)

- 목적지 주소: `11001000 00010111 00011000`
- 포워딩 테이블:
  - `11001000 00010111 00010***` → 인터페이스 0
  - `11001000 00010111 00011000` → 인터페이스 1
  - `11001000 00010111 00011***` → 인터페이스 2

→ 완전히 일치하는 두 번째 항목이 가장 긴 접두어이므로 선택 → **인터페이스 1**

## Longest Prefix Matching (구현 및 중요성)

- 실제 라우터에서는 **TCAM (Ternary Content Addressable Memory)** 을 활용하여 LPM 수행
- **Content addressable**: 주소를 입력하면 테이블 전체를 탐색하지 않고 한 번의 클록 사이클로 일치 항목을 즉시 반환함
- Cisco Catalyst 등에서는 약 **100만 개의 포워딩 테이블 항목**을 TCAM에 저장 가능

### 요약
- LPM은 겹치는 주소 범위에서 가장 구체적인 경로를 선택할 수 있도록 하며, 고속 하드웨어를 통해 효율적으로 구현됨

## Switching Fabrics 개요 및 종류
### 개요
- 스위칭 패브릭(switching fabric)은 입력 포트에서 수신된 패킷을 적절한 출력 포트로 전달하는 기능을 수행함
- **스위칭 속도(switching rate)**: 입력에서 출력으로 패킷을 전달할 수 있는 속도
  - 일반적으로 입출력 링크 속도의 배수로 표현됨
  - N개의 입력 포트가 있다면, 이상적으로는 N × R (라인 속도) 만큼의 처리 속도가 필요함

### 주요 스위칭 방식
#### 1. Memory 기반 스위칭
- **1세대 라우터에서 사용**
- 전통적인 컴퓨터 구조로, 패킷을 CPU 제어 하에 메모리에 복사한 후 처리
- 속도 병목: 시스템 버스를 두 번 통과해야 하며, 메모리 대역폭에 의해 제한됨

#### 2. Bus 기반 스위칭
- 공용 버스를 이용하여 입력 포트 메모리에서 출력 포트 메모리로 전송
- **버스 경합(bus contention)** 발생 가능 → 버스 대역폭에 의해 속도 제한
- 예: Cisco 5600은 32Gbps 버스로 액세스 라우터에서 충분한 성능 제공

#### 3. Interconnection Network 기반 스위칭
- **교차바(crossbar)**, **Clos 네트워크** 등 다단계 스위치(multistage switch) 구조 사용
- 다수의 소형 스위치를 결합하여 nxn 구조 구현 가능
- 병렬성(parallelism)을 활용:
  - 데이터그램을 고정 길이 셀로 분할하여 각 경로로 동시에 전송
  - 출구에서 셀을 재조립하여 원래 데이터그램으로 복원

#### 4. 고성능 Interconnection 예시: Cisco CRS 라우터
- 8개의 스위칭 평면(plane)을 병렬로 사용
- 각 평면은 3단계(interconnection) 네트워크로 구성
- 수백 Tbps까지 확장 가능한 스위칭 용량 제공

### 요약
- 스위칭 패브릭의 설계는 라우터의 전체 처리량과 성능에 직접적인 영향을 줌
- 초기에는 메모리 기반이었으나, 성능 향상을 위해 버스 → 인터커넥션 네트워크로 진화

## Input & Output Port Queuing, Buffering, Scheduling
### 🔵 Input Port Queuing
- 입력 포트들의 전송 속도 합이 스위칭 패브릭보다 클 경우, 입력 포트에서 큐잉 발생
- **큐잉 지연 및 버퍼 오버플로우에 의한 손실** 발생 가능
- **Head-of-the-Line (HOL) Blocking**:
  - 큐 맨 앞의 패킷이 특정 출력 포트를 점유하고 있어 대기 중이면,
    그 뒤에 있는 패킷들도 막히게 됨
  - 이는 전체 처리량을 저하시킴

---

### 🔵 Output Port Queuing
- 스위칭 패브릭을 통해 데이터그램이 출력 포트로 몰릴 경우,
  **도착률이 링크 전송률을 초과**하면 출력 포트에서도 큐잉 발생
- 이로 인해 **출력 버퍼 오버플로우**, **지연**, **패킷 손실** 발생 가능
- **Buffering**은 필수
  - 스위칭 패브릭의 속도가 링크보다 빠를 수 있기 때문
- **Drop Policy**:
  - 버퍼가 꽉 찼을 때 어떤 패킷을 버릴지 결정
  - 예: tail drop(도착한 패킷 버림), priority drop(우선순위 낮은 패킷 버림)
- **Scheduling Discipline**:
  - 어떤 순서로 패킷을 전송할지를 결정
  - 성능, 공정성, 네트워크 중립성 등에 영향을 미침

---

### 🔵 적절한 버퍼 크기 (How much buffering?)
- **RFC 3439 규칙**: 평균 버퍼링 크기 = RTT × 링크 용량(C)
  - 예: 10 Gbps 링크, RTT 250ms → 2.5 Gbit 버퍼
- **최근 권장사항**:
  - N개의 흐름이 있을 때 버퍼 크기 =  
    $\frac{\text{RTT} \cdot C}{\sqrt{N}}$
- 과도한 버퍼링은 **지연 증가** 및 TCP 반응성 저하 유발 가능
  - 특히 RTT가 긴 경우 실시간 애플리케이션에 불리함
  - 따라서 **혼잡 제어는 적절한 수준의 버퍼 점유율 유지**가 핵심

---

### 🔵 Buffer Management
- **Drop**: 버퍼가 가득 찼을 때 어떤 패킷을 제거할지 결정
  - tail drop: 맨 마지막에 도착한 패킷 제거
  - priority drop: 우선순위 기준으로 제거
- **Marking**: 혼잡 신호를 보내기 위한 표시
  - 예: ECN, RED

---

### 🔵 Packet Scheduling: FCFS
- **Packet Scheduling**: 큐에 있는 패킷 중 어떤 것을 먼저 전송할지 결정하는 과정
- **FCFS (First-Come-First-Served)**:
  - 도착 순서대로 전송하는 가장 단순한 스케줄링
  - FIFO(First-In First-Out)라고도 함
  - 공정하지만, 긴 패킷이 앞에 있을 경우 전체 지연 증가 가능성 있음

### ✅ 기타 스케줄링 방식
- Priority: 우선순위 높은 패킷 먼저
- Round Robin: 순환 방식으로 공평하게 분배
- Weighted Fair Queuing: 가중치 기반 공정 분배

## Scheduling Policies

### 🔴 Priority Scheduling
- 도착한 트래픽을 클래스별로 구분하여 큐에 저장함
  - 헤더 필드의 값 등을 기반으로 분류 가능
- 항상 **우선순위가 가장 높은 큐**에서 패킷을 먼저 전송함
  - 같은 클래스 내에서는 FCFS 방식으로 처리됨
- 장점:
  - 긴급 트래픽(예: 음성, 제어 신호 등)에 유리함
- 단점:
  - 낮은 우선순위 큐는 무기한 대기(starvation)할 수 있음

---

### 🔵 Round Robin Scheduling
- 도착한 트래픽을 클래스별로 큐에 저장함
- 서버가 각 큐를 **순환적으로(cyclically)** 스캔하며, **각 클래스에서 한 개의 패킷씩** 순서대로 전송함
- 장점:
  - 모든 클래스에 공평한 기회 제공
- 단점:
  - 트래픽 양이 매우 다른 경우에는 비효율 발생 가능

---

### 🟢 Weighted Fair Queueing (WFQ)
- **일반화된 Round Robin** 방식
- 각 클래스 i에 대해 **가중치 wi**를 부여하여, **비례적으로 전송 기회**를 부여함
  - 한 사이클 내에서 클래스 i가 얻는 서비스 비율:
    - $ \frac{w_i}{\sum w_j} $
- **트래픽 클래스별 최소 대역폭 보장**
- 장점:
  - 다양한 트래픽 유형 간 공정하고 유연한 자원 분배 가능
  - 고품질 서비스를 요구하는 트래픽과 일반 트래픽을 함께 처리할 수 있음

## Network Neutrality & ISP Classification

### 🔵 What is Network Neutrality?
- **기술적 측면**:
  - ISP가 자원을 어떻게 할당하고 공유할지에 대한 기준
  - 관련 메커니즘: 패킷 스케줄링, 버퍼 관리 등
- **사회적·경제적 원칙**:
  - 표현의 자유 보장
  - 혁신 및 경쟁 촉진
- **법적 규제**:
  - 각국의 법과 정책에 따라 다르게 정의 및 적용됨

> 💬 "국가마다 네트워크 중립성에 대한 입장은 상이함"

---

### 🔵 2015년 미국 FCC 네트워크 중립성 3대 원칙
**FCC 명령문: "Protecting and Promoting an Open Internet"**
1. **No Blocking**  
   - 합법적 콘텐츠, 애플리케이션, 서비스 또는 장치를 차단해서는 안 됨

2. **No Throttling**  
   - 특정 인터넷 콘텐츠, 애플리케이션, 서비스에 대해 속도를 고의로 저하시키거나 품질을 저하시키면 안 됨

3. **No Paid Prioritization**  
   - 돈을 받고 특정 트래픽에 우선순위를 부여하는 행위를 금지함

---

## ISP: 통신 서비스인가 정보 서비스인가?

### 🔵 왜 중요한가?
- ISP가 **telecommunications service**인지 **information service**인지에 따라 **규제의 수준이 완전히 달라짐**

### 🔵 US Telecommunications Act (1934 & 1996)

- **Title II: Telecommunications Services**
  - "공통 운송자(common carrier)"로 간주
  - 합리적인 요금, 차별 금지, 규제 필요
  - 규제를 강제할 수 있음

- **Title I: Information Services**
  - 공통 운송자 의무 없음 → **규제 대상 아님**
  - FCC는 필요시 제한적 기능 수행 가능

> ⚖️ ISP 분류에 따라 규제 여부가 결정되며, 이는 네트워크 중립성 보장에 중대한 영향을 줌
