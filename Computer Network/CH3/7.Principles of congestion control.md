### Principles of Congestion Control
- **Congestion (혼잡)**: 네트워크가 감당할 수 있는 속도보다 **너무 많은 송신자**가 **너무 빠르게 데이터를 보낼 때** 발생
- 주요 징후:
  - 라우터 큐 대기 → **지연 증가**
  - 라우터 버퍼 오버플로우 → **패킷 손실**
- **Flow Control과는 다름**
  - Flow Control은 **송신자와 수신자 간의 속도 조절**
  - Congestion Control은 **네트워크 전체 자원 사용량 조절**

> 예시 비유:  
> - Flow Control: 호스를 너무 빠르게 받는 어린아이  
> - Congestion Control: 고속도로에 너무 많은 차

---

### Causes/Costs of Congestion: Scenario 1
- **가정**: 하나의 라우터, **무한한 버퍼**, 링크 용량은 R
- 송신자 A, B → 출력 링크 공유
- 재전송 없음, 전송률 λ<sub>in</sub>, 수신률 λ<sub>out</sub>

#### 결과:
- λ<sub>in</sub> → R/2까지는 throughput 증가
- λ<sub>in</sub>이 R/2에 가까워지면 **지연이 급격히 증가**
- 이유: 무한 버퍼라도 큐잉 지연이 쌓이기 때문

---

### Causes/Costs of Congestion: Scenario 2
- **현실 반영**: 라우터는 **유한한 버퍼**를 가짐
- 송신자가 **타임아웃 후 재전송**함

#### 문제:
- 전송률 λ<sub>in</sub>은 여전히 같지만, 실제 입력량은 λ′<sub>in</sub> ≥ λ<sub>in</sub> (재전송 포함)
- 출력은 λ<sub>out</sub>이지만, **실제 들어온 양은 더 많아짐**
- 네트워크 자원을 낭비하고, 패킷 손실과 지연을 증가시킴

---

### 이상적 상황: Perfect Knowledge
- 송신자가 **라우터의 버퍼 상태를 정확히 알고 있을 경우**
- 라우터에 버퍼 여유가 있을 때만 전송 → 재전송 없음
- 이 경우:
  - λ′<sub>in</sub> = λ<sub>in</sub>
  - λ<sub>out</sub>도 R/2에 도달 가능
  - 지연도 증가하지 않음

> 하지만 현실에서는 송신자는 라우터 버퍼 상태를 알 수 없음  
> → 따라서 **TCP는 혼잡 제어 알고리즘을 사용하여 간접적으로 조절**

### Causes/Costs of Congestion: Some Knowledge Case
- **일부 완벽한 정보 가정**: 송신자가 **패킷 손실 여부를 정확히 알 수 있음**
- 라우터 버퍼가 가득 차면 패킷은 **즉시 드롭**
- 송신자는 드롭된 것이 확실할 때만 재전송

→ 이 경우 재전송은 있지만 **불필요한 중복은 없음**, λ′<sub>in</sub> ≥ λ<sub>in</sub>

#### 결과
- 필요 최소한의 재전송만 발생하므로 효율적
- 하지만 여전히 일부 자원 낭비는 존재  
  (재전송된 패킷이 전체 처리량을 높이지 않기 때문)

---

### 혼잡의 실제 시나리오: Un-needed Duplicates
- 현실에서는 송신자가 패킷 손실을 정확히 알 수 없으므로 **타이머 기반 재전송** 사용
- 타이머가 너무 빨라서 **실제로 도달한 패킷도 중복 전송**되는 경우 발생
- 둘 다 수신자에게 도달하면 **불필요한 중복 데이터**가 네트워크를 점유함

#### 결과
- λ′<sub>in</sub>은 여전히 증가하지만,  
  λ<sub>out</sub>은 포화(R/2) 이후 **평탄해지며 효율 저하**
- 그래프 상에서는 throughput(λ<sub>out</sub>)이 λ′<sub>in</sub>보다 느리게 증가

---

### Costs of Congestion
- **전송 효율 저하**
  - 수신자는 같은 양을 받지만 송신자는 더 많은 일을 함 (재전송 포함)
- **링크 낭비**
  - 링크는 불필요한 중복 패킷까지 전달하므로 실제 유효 데이터의 처리율이 낮아짐
- **결과적으로 최대 처리량 저하**
  - 혼잡 상황에서는 링크 용량이 충분해도 그만큼 성능을 활용하지 못함

> → TCP는 이 문제를 해결하기 위해 **혼잡 제어 알고리즘**을 적용함


### Causes/Costs of Congestion: Scenario 3 (Multi-hop with Multiple Senders)
- **환경**: 송신자 4명, 다중 홉 경로, 유한한 라우터 버퍼, 타임아웃 기반 재전송 존재

#### Q: λ<sub>in</sub> 및 λ′<sub>in</sub>이 증가하면 무슨 일이 발생하는가?
- 하나의 송신 흐름(예: 빨간 라인)의 λ′<sub>in</sub>이 증가하면,
  다른 흐름(예: 파란 라인)이 공유 라우터 버퍼에서 **드롭**됨
- 이로 인해 **일부 흐름의 처리율(λ<sub>out</sub>)이 0에 수렴**할 수 있음
- 라우터가 처리 가능한 한계를 초과한 흐름이 **다른 흐름을 몰아냄**

---

### 혼잡의 또 다른 비용
- 드롭된 패킷이 있다면, 해당 패킷이 이미 지나온 경로의 전송 자원(링크 대역폭, 큐 공간)은 **모두 낭비**
- → **상위 홉의 리소스도 손실**되는 셈

#### 처리율 그래프 해석
- λ′<sub>in</sub>이 일정 수준을 넘으면, 처리율(λ<sub>out</sub>)이 오히려 **급격히 감소**
- 혼잡은 전체 네트워크 효율을 망가뜨림

---

### 통찰: Congestion의 본질적 문제 정리

- **처리율은 링크 용량(capacity)을 넘을 수 없음**
- **용량에 가까워질수록 지연 증가**
- **패킷 손실과 재전송**은 실제 유효 처리율을 감소시킴
- **불필요한 중복 전송(un-needed duplicates)**은 이를 더욱 악화시킴
- **하류에서 손실된 패킷**은 상류에서 소모된 전송 자원을 모두 낭비시킴

> → TCP 혼잡 제어의 핵심 목적: 이러한 **비효율을 최소화**하고 네트워크를 안정적으로 유지하는 것

### Approaches Towards Congestion Control

#### 1. End-to-End Congestion Control (종단 간 혼잡 제어)
- **네트워크로부터 명시적인 피드백 없음**
- 송신자는 **손실(loss)이나 지연(delay)**과 같은 **간접적인 현상**을 관찰하여 **혼잡 상태를 추론**
- TCP는 이 방식을 채택함
  - 예: 타임아웃 발생 → 네트워크 혼잡으로 간주
  - ACK 지연 → RTT 증가 → 혼잡 가능성 판단

> 특징: **추론 기반**, 네트워크 독립적, 단순 구현, 그러나 혼잡 반응이 늦을 수 있음

---

#### 2. Network-Assisted Congestion Control (네트워크 지원 혼잡 제어)
- **라우터가 직접 혼잡 정보를 송신자/수신자에게 전달**
  - 예: ECN (Explicit Congestion Notification) 비트 설정
- 피드백 형태:
  - 혼잡 정도의 표시
  - 권장 전송 속도 제공
- 사용 예시: TCP ECN, ATM, DECbit 등

> 특징: **명시적 정보 제공**, 빠른 대응 가능, 그러나 라우터 구현 복잡도 증가

---

### 비교 요약
| 방식 | 네트워크 피드백 | 구현 위치 | 예시 |
|------|------------------|------------|------|
| End-to-End | 없음 (간접 추론) | 송신자 | TCP |
| Network-Assisted | 있음 (명시적) | 라우터+송신자 | TCP ECN, DECbit |

→ 실제 대부분의 TCP는 **end-to-end 방식**에 기반하고 있으며,  
**ECN**과 같은 기법은 이를 보완하기 위한 **하이브리드적 접근**임
