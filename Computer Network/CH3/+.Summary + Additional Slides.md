## Chapter 3: summary
- transport layer 서비스의 핵심 원리:
  - multiplexing, demultiplexing
  - reliable data transfer
  - flow control
  - congestion control
- 인터넷에서의 구현:
  - UDP
  - TCP

## Go-Back-N: sender extended FSM
- sender는 하나의 상태(Wait)만 가지며, 모든 이벤트에 따라 전이됨
- `rdt_send(data)` 이벤트:
  - `nextseqnum < base + N`이면:
    - 새로운 패킷 생성
    - 전송 수행
    - base == nextseqnum이면 타이머 시작
    - nextseqnum 증가
  - 아니라면 데이터 전송 거부
- `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt)`:
  - ack 번호를 기준으로 base 갱신
  - base == nextseqnum이면 타이머 정지, 아니면 타이머 재시작
- `timeout` 이벤트:
  - base부터 nextseqnum - 1까지 모든 패킷 재전송

## Go-Back-N: receiver extended FSM
- receiver도 하나의 상태(Wait)만 가지며, 입력된 패킷에 따라 동작
- `rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && hasseqnum(rcvpkt, expectedseqnum)`:
  - 데이터 추출 및 상위 계층 전달
  - ack 전송
  - expectedseqnum 증가
- 그 외 경우:
  - 데이터는 버림 (buffering 없음)
  - 가장 마지막으로 수신된 in-order 패킷에 대한 ack 재전송

## 핵심 정리
- sender는 sliding window 기반으로 연속 전송 가능
- receiver는 순서대로 수신되지 않은 패킷은 전부 버림
- Go-Back-N은 에러 처리 시 sender 측에서 여러 패킷을 재전송하므로 비효율적일 수 있음

## TCP sender (simplified)
- 초기 설정:  
  `NextSeqNum = InitialSeqNum`, `SendBase = InitialSeqNum`
- 데이터 전송:
  - 응용 계층에서 데이터를 수신하면 `NextSeqNum`을 포함하여 세그먼트를 생성하고 전송
  - `NextSeqNum += length(data)`
  - 타이머가 동작 중이 아니면 시작
- ACK 수신 시:
  - ACK 번호 `y`가 `SendBase`보다 크면, `SendBase = y`로 갱신
  - 아직 ACK되지 않은 세그먼트가 존재하면 타이머 유지, 그렇지 않으면 종료
- 타임아웃 발생 시:
  - 가장 오래된 미확인 세그먼트를 재전송하고 타이머 다시 시작

## TCP 3-way handshake FSM
- 클라이언트: `Socket clientSocket = newSocket("hostname", "port")`
  - SYN(x) 전송, `SYN_SENT` 상태로 이동
- 서버: `Socket connectionSocket = welcomeSocket.accept()`
  - `SYN_RCVD` 상태로 이동 후, `SYNACK(seq=y, ACKnum=x+1)` 응답
- 클라이언트는 `ACK(ACKnum=y+1)` 전송
  - 양측 모두 `ESTAB` 상태로 연결 완료

## Closing a TCP connection
- 클라이언트:
  - `clientSocket.close()` 호출 시 `FIN_WAIT_1`
  - `FINbit=1, seq=x` 송신
  - `ACKbit=1, ACKnum=x+1` 수신 시 `FIN_WAIT_2`
  - 서버의 FIN 수신 후 `TIMED_WAIT`
  - 2*MSS 세그먼트 시간 대기 후 `CLOSED`
- 서버:
  - 클라이언트 FIN 수신 시 `CLOSE_WAIT`
  - 애플리케이션 종료 후 `LAST_ACK` → `FINbit=1, seq=y` 전송
  - 클라이언트 ACK 수신 후 `CLOSED`

## TCP throughput

- TCP의 평균 처리량(throughput)은 윈도우 크기(W)와 RTT(Round-Trip Time)에 따라 달라짐
- 슬로우 스타트는 무시하고, 항상 보낼 데이터가 존재한다고 가정함

### W: 손실이 발생하는 윈도우 크기 (bytes 단위)
- 평균 윈도우 크기는 전체의 3/4 수준임
- 따라서 평균 TCP 처리량은 다음과 같음:
  
  $$
  \text{avg TCP throughput} = \frac{3}{4} \cdot \frac{W}{RTT} \text{ bytes/sec}
  $$

- 그림에서는 W와 W/2 사이를 오르내리는 톱니형의 처리량 변화를 시각화함 (AIMD 모델 반영)

---

## TCP over "long, fat pipes"

- 예시: 1500 byte 세그먼트, 100ms RTT, 목표 처리량 10 Gbps
- 필요한 윈도우 크기 $W$는 83,333 세그먼트 수준

### 처리량 수식 (Mathis 1997):
$$
\text{TCP throughput} = \frac{1.22 \cdot MSS}{RTT \cdot \sqrt{L}}
$$

- 여기서 $L$은 세그먼트 손실 확률
- 10 Gbps 달성을 위해 필요한 손실률 $L = 2 \cdot 10^{-10}$ 수준임 → 매우 낮은 손실률 요구

### 의미:
- 고속 장거리 링크에서는 기존 TCP로는 손실이 자주 발생하므로 처리량 확보가 어려움
- 이를 해결하기 위한 TCP 변형들이 존재함 (예: TCP CUBIC 등)




