## TCP Congestion Control: AIMD

### AIMD 개요
AIMD(Additive Increase Multiplicative Decrease)는 TCP에서 혼잡 제어를 위한 핵심 알고리즘임. 송신자는 네트워크 혼잡이 감지될 때까지 전송 속도를 점진적으로 증가시키고, 혼잡이 감지되면 급격히 속도를 감소시킴.

- **Additive Increase**:  
  RTT마다 전송 속도(cwnd)를 1 MSS씩 증가  
  → 혼잡이 감지되기 전까지 점진적으로 전송률을 늘림

- **Multiplicative Decrease**:  
  혼잡 감지 시 cwnd를 절반으로 줄임  
  → 혼잡 회피

> 결과적으로 cwnd는 톱니형(sawtooth) 패턴을 보이며, 네트워크 대역폭을 탐색(probing)함

---

## AIMD 세부 사항

### Multiplicative Decrease 방식
- **Triple Duplicate ACK** → `cwnd`를 절반으로 감소 (TCP Reno)
- **Timeout 발생** → `cwnd`를 1 MSS로 감소 (TCP Tahoe)

> 이러한 방식은 혼잡된 네트워크 상황에서 **안정적인 수렴성과 효율적인 자원 분배**를 보장함

---

## TCP Congestion Control 변수: `cwnd`

### 기본 개념
- **cwnd (congestion window)**: 혼잡 상태를 고려하여 송신자가 전송할 수 있는 데이터 바이트 수 제한
- **기본 동작**: `cwnd` 바이트만큼 전송한 후 → ACK를 수신하고 → 그 다음 전송 가능

### 동작 조건
`LastByteSent - LastByteAcked ≤ cwnd`

즉, 전송한 바이트 중 아직 ACK를 받지 못한 부분이 `cwnd`를 초과하면 전송을 중지함.

### 전송률 수식
`TCP rate ≈ cwnd / RTT (bytes/sec)`

---

## TCP Slow Start

연결이 처음 시작될 때는 혼잡 상태를 모르므로 전송 속도를 천천히 증가시키는 전략이 필요함.

### 동작 방식
- 초기 `cwnd = 1 MSS`
- 매 RTT마다 수신하는 ACK 수에 비례하여 `cwnd` 2배씩 증가  
  → **지수적 증가**

> 혼잡이 감지되면 slow start 종료, 이후 AIMD의 additive increase 적용

### 요약
- 초기 전송률은 느리지만 매우 빠르게 증가함
- 네트워크 상태에 빠르게 적응 가능

---

## 정리

| 단계 | 전송 속도 변화 | 조건 |
|------|----------------|------|
| Slow Start | 지수적 증가 | 연결 초기에 적용 |
| AIMD - AI | 선형 증가 (1 MSS/RTT) | 혼잡 없음 |
| AIMD - MD | 절반 감소 | 혼잡 감지 시 |

이러한 방식은 TCP가 **효율성**과 **공정성**, **안정성**을 모두 확보할 수 있게 함.


## TCP: from slow start to congestion avoidance

**Q:** 언제 지수적 증가에서 선형 증가로 전환해야 하는가?  
**A:** `cwnd`가 타임아웃 발생 직전의 값의 1/2에 도달했을 때

### Implementation
- `ssthresh`라는 변수 사용
- 패킷 손실 이벤트 발생 시, `ssthresh = cwnd / 2`로 설정  
  → 이후 `cwnd`가 `ssthresh`에 도달하면 선형 증가(congestion avoidance)로 전환됨

---

## Summary: TCP congestion control

- **slow start**:  
  - `cwnd = 1 MSS`부터 시작, ACK 받을 때마다 `cwnd` 2배씩 증가
  - 중복 ACK 3개 또는 타임아웃 발생 시 fast recovery 혹은 초기화

- **congestion avoidance**:  
  - `cwnd >= ssthresh` 시 진입
  - ACK 받을 때마다 `cwnd += MSS² / cwnd` (사실상 선형 증가)

- **fast recovery**:  
  - 중복 ACK 3개 수신 시 진입
  - 손실 세그먼트 재전송 후 `cwnd = ssthresh + 3 * MSS`
  - 새로운 ACK 수신 시 congestion avoidance로 전환

- **타임아웃** 발생 시:
  - `ssthresh = cwnd / 2`, `cwnd = 1 MSS`로 초기화
  - 다시 slow start로 진입


## TCP CUBIC

- **AIMD보다 더 나은 대역폭 탐색 방법이 있을까?**  
  → **TCP CUBIC**은 기존의 선형적 AIMD와 달리 비선형 곡선을 이용하여 효율적으로 혼잡을 피하고 대역폭을 탐색함

### 핵심 아이디어
- **$W_{max}$**: 혼잡이 발생한 순간의 윈도우 크기
- 혼잡 후 전송 속도를 **절반($\frac{W_{max}}{2}$)**으로 줄인 후, **$W_{max}$를 더 빠르게 다시 접근**하려는 전략 사용
- 이후엔 천천히 접근함으로써 **잦은 혼잡 재발 방지**

### CUBIC 함수적 증가 방식
- `K`: 윈도우가 $W_{max}$에 도달할 시점 (시간 기준)  
  → 이 값은 조정 가능 (tunable)
- 현재 시점과 `K` 사이 거리의 **세제곱(cubic)**을 이용해 윈도우 크기를 조정
  - `K`와 멀면 → **더 빠르게 증가**
  - `K`에 가까우면 → **점점 느리게 증가** (안정성 확보)

### 특징
- **Linux 기본 TCP 알고리즘**  
  → 웹 서버 등에서 가장 널리 사용됨
- TCP Reno 대비 **더 높은 처리율(throughput)** 보장

### 시각적 비교 (CUBIC vs. Classic TCP)
- **Classic TCP**: 선형 증가 후 손실 발생 시 급감
- **TCP CUBIC**: 혼잡 후 빠른 복구, 점진적 접근

## TCP and the congested “bottleneck link”
- TCP(CUBIC 포함)은 송신 속도를 점차 증가시킴
- 그러다 네트워크 상 라우터의 출력 포트에서 패킷 손실이 발생할 경우 해당 링크를 **병목 링크(bottleneck link)**로 간주함

### 병목 링크의 특성
- 송신 측에서는 TCP가 RTT를 통해 네트워크 상태를 추정하며 속도를 조절함
- 병목 링크에서는 **queue가 거의 비어있지 않고**, 때로는 overflow 발생 → **패킷 손실**
- 이 구간의 혼잡 정도를 인식하는 것이 TCP 전송 제어에 핵심

### 혼잡 인식 전략
- TCP는 end-to-end 경로 중에서 병목 구간만 고려해 제어하는 것이 바람직함
- 송신 속도를 증가시켜도 **총 end-to-end 처리량이 증가하지 않음**
- 오히려 **RTT 증가**나 **손실 위험 증가**만 초래함
> 목표: **“end-to-end 파이프를 가득 채우되 넘치지 않게 유지”**하는 것

### Delay-based TCP congestion control
Keeping sender-to-receiver pipe “just full enough, but no fuller”: bottleneck 링크는 항상 전송 작업 중이지만, 과도한 지연이나 버퍼링은 피해야 함
- `RTT_measured`: 측정된 round-trip time
- measured throughput = `# bytes sent in last RTT interval / RTT_measured`
    

#### Delay-based approach
- `RTT_min`: 관측된 최소 RTT (혼잡 없는 경로에서의 값)
- 혼잡 없는 상황에서의 예상 throughput = `cwnd / RTT_min`

```text
if measured throughput “very close” to expected throughput:
    increase cwnd linearly     // 경로가 혼잡하지 않음
else if measured throughput “far below” expected throughput:
    decrease cwnd linearly     // 경로가 혼잡함을 나타냄
```

### Delay-based TCP congestion control (continued)
- 손실을 유도하거나 강제하지 않고도 혼잡 제어 가능함
- 최대 throughput을 확보하면서도 지연을 최소화하는 접근
    - "just full... but not fuller"
- 일부 배포된 TCP 구현은 delay-based 방식 채택
    - 예: **Google의 내부 backbone network**에서는 BBR 사용
        

### Explicit Congestion Notification (ECN)
TCP에서 network-assisted congestion control을 구현하는 방식 중 하나
- IP 헤더 (ToS 필드)의 두 비트를 network router가 설정하여 혼잡을 나타냄
    - 어떤 상황에서 마크할지에 대한 정책은 네트워크 운영자 설정
- 혼잡 정보는 목적지로 전송됨
- 목적지는 ACK 세그먼트의 ECE 비트를 설정하여 송신자에게 혼잡 통지
- IP 계층: ECN 비트 마킹
- TCP 계층: TCP 헤더의 C, E 비트 마킹

예시:
- `ECN=1`로 설정된 IP 패킷을 받으면, 목적지 호스트는 `ECE=1`로 설정된 TCP ACK를 보냄
## TCP fairness
**Fairness goal**: `K`개의 TCP 세션이 동일한 병목 링크를 공유하고 그 링크의 대역폭이 `R`이라면, 각 세션은 평균적으로 `R/K`의 전송률을 가져야 함
- 병목 라우터에서 큐가 거의 항상 가득 차 있고, 패킷 손실이 간헐적으로 발생함
- 각 TCP 세션은 RTT 기반의 혼잡 제어로 `Additive Increase / Multiplicative Decrease` 전략을 사용하여 자신에게 허용된 대역폭을 조절함

## Is TCP Fair?
- 두 개의 TCP 세션이 경쟁하는 상황에서:
    - `Additive Increase`: 선형 증가, 기울기 1
    - `Multiplicative Decrease`: 손실 발생 시 윈도 크기를 절반으로 감소

**결론**: 이상적인 조건 하에서는 공정함
- 같은 RTT를 갖는 TCP 세션들 간
- 혼잡 회피 상태에서만 세션 수가 고정되어 있을 경우
    

## Fairness and Applications
### Fairness and UDP
- 멀티미디어 애플리케이션은 TCP를 사용하지 않는 경우가 많음
    - 혼잡 제어로 인해 전송률이 제한되는 것을 원치 않음
    - 대신 UDP를 사용하여 손실을 감수하고 고정 비트레이트로 전송함
- 인터넷에는 이러한 혼잡 제어 사용을 강제하는 중앙 규칙이 없음
    

### Fairness and Parallel TCP Connections
- 하나의 애플리케이션이 다수의 병렬 TCP 연결을 생성 가능
- 예: 웹 브라우저가 여러 개의 연결을 동시에 열어 전송률 확보
    - 기존에 9개의 TCP 세션이 있는 상태에서 새로운 애플리케이션이 1개 세션을 열면 `R/10`
    - 대신 11개의 세션을 열면 전체 대역폭의 `R/2`까지 확보 가능
**요점**: TCP의 공정성은 네트워크 프로토콜 자체만으로 보장되지 않으며, 실제 애플리케이션의 동작 방식과 사용자의 선택에 따라 왜곡될 수 있음