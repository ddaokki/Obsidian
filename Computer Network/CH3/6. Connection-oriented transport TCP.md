## TCP: 개요
**RFC 문서들**: 793, 1122, 2018, 5681, 7323  
→ TCP의 동작 원리 및 표준은 여러 RFC 문서에 정의되어 있음
- **point-to-point: 하나의 송신자와 하나의 수신자**
  - TCP 연결은 정확히 두 개의 종단점(엔드포인트) 간에 설정됨
  - 브로드캐스트나 멀티캐스트는 TCP에서 지원하지 않음

- **reliable, in-order byte stream: 신뢰 가능하고 순서가 보장된 바이트 스트림**
  - TCP는 메시지를 바이트 단위로 연속 전송함
  - 수신 측은 송신 측이 보낸 바이트를 정확히 순서대로 받아야 하며, 중간에 손실되거나 순서가 어긋나지 않도록 보장됨
  - "메시지 경계"가 없다는 뜻은, TCP는 바이트 흐름만 관리할 뿐, 개별 메시지 구분은 애플리케이션이 처리해야 함

- **full duplex data: 전이중 통신**
  - 한쪽이 데이터를 보내면서 동시에 받을 수 있음 (양방향 통신)
  - 동일한 TCP 연결 내에서 송수신이 독립적으로 동작함
  - MSS(Maximum Segment Size): 한 번에 전송할 수 있는 최대 세그먼트의 크기

- **cumulative ACKs: 누적 확인 응답**
  - TCP는 여러 세그먼트 중 마지막까지 연속해서 도착한 시점의 바이트 번호까지를 ACK로 응답함
  - 예: 100~199, 200~299를 받고 300~399가 도착하지 않았을 경우, ACK 300을 계속 보냄 → 299까지는 잘 받았음을 의미

- **pipelining: 파이프라이닝**
  - 여러 개의 세그먼트를 한 번에 전송 가능 (Stop-and-Wait 방식 아님)
  - 수신 측의 ACK를 기다리지 않고 일정 윈도우 크기 내에서 계속 전송
  - 혼잡 제어 및 흐름 제어 메커니즘이 윈도우 크기를 설정

- **connection-oriented: 연결 지향**
  - 데이터 전송 전 반드시 3-way handshaking 수행
  - 클라이언트와 서버가 연결 상태를 설정하고 유지하기 위한 제어 메시지를 주고받음
  - 연결이 설정되기 전까지는 실제 데이터가 전송되지 않음

- **flow controlled: 흐름 제어**
  - 수신 측의 수용 능력을 초과하지 않도록 송신 측을 제어함
  - TCP는 수신자가 제공하는 윈도우 크기를 통해 송신량을 제한함 → 수신자 과부하 방지

## TCP 세그먼트 구조 (TCP segment structure)

- **source port # / dest port #**  
  - 송신자와 수신자의 포트 번호 (각 16비트)
  - 포트 번호를 통해 애플리케이션과의 연결을 식별함

- **sequence number (시퀀스 번호)**  
  - 바이트 스트림 상에서 현재 세그먼트의 첫 번째 바이트의 위치를 나타냄  
  - *세그먼트 단위가 아니라 바이트 단위로 번호를 매김*

- **acknowledgement number (확인 응답 번호)**  
  - 수신자가 다음에 기대하는 바이트의 번호  
  - 이 번호까지의 모든 데이터를 정상적으로 받았음을 의미함  
  - `A` 플래그(ACK bit)가 1인 경우에만 유효함

- **head len (TCP 헤더 길이)**  
  - TCP 헤더의 크기 (단위: 32비트 워드)
  - TCP 옵션 사용 시 헤더가 가변 길이가 되므로 필요함

- **control bits (플래그 비트들)**  
  - `C`, `E`: 혼잡 알림 (Congestion Notification)
  - `U`, `A`, `P`, `R`, `S`, `F`:
    - URG: 긴급 포인터 필드 사용 여부
    - ACK: acknowledgement number 필드 유효 여부
    - PSH: 수신 측이 바로 상위 계층으로 전달하도록 지시
    - RST: 연결 재설정 요청
    - SYN: 연결 요청
    - FIN: 연결 종료 요청

- **receive window (수신 윈도우 크기)**  
  - 수신자가 현재 수용 가능한 바이트 수 (flow control 용도)
  - 송신자는 이 값을 기반으로 전송량을 조절함

- **checksum (체크섬)**  
  - 오류 검출용 필드 (IP pseudo header 포함하여 계산)

- **Urgent data pointer (긴급 데이터 포인터)**  
  - URG 플래그가 설정된 경우 유효하며, 긴급 데이터의 끝 위치를 나타냄

- **options (TCP 옵션)**  
  - 가변 길이 필드로, MSS, 윈도우 크기 조정(Window Scale), 타임스탬프 등 다양한 옵션 포함 가능

- **application data (애플리케이션 데이터)**  
  - TCP 소켓을 통해 애플리케이션이 전송한 실제 데이터 (가변 길이)

## TCP Sequence Numbers & ACKs

### Sequence numbers (시퀀스 번호)
- 세그먼트 내 **데이터의 첫 번째 바이트**가 바이트 스트림에서 차지하는 위치를 나타내는 번호
- TCP는 **바이트 단위**로 순서를 관리하며, 각 세그먼트에 부여된 시퀀스 번호는 그 세그먼트가 포함한 바이트의 시작 위치를 의미함

### Acknowledgements (확인 응답 번호)
- 수신자가 **다음에 기대하는 바이트의 시퀀스 번호**를 송신자에게 알려줌
- **누적 ACK(cumulative ACK)** 방식 사용:
  - 예: `ACK = 100`이면, 0~99 바이트까지는 모두 받았음을 의미함
- TCP는 out-of-order 패킷을 어떻게 처리할지 명시하지 않음  
  → 이는 **구현자에게 위임됨 (up to the implementor)**

### 송신자 시퀀스 번호 공간 예시 (sender sequence number space)
- 시퀀스 번호 공간은 다음과 같이 구분됨:
  - 초록색: 이미 ACK 받은 바이트
  - 파란색: 전송했지만 아직 ACK를 받지 못한 바이트 (in-flight)
  - 노란색: 현재 윈도우 내, 아직 전송하지 않은 바이트 (usable)
  - 회색: 아직 윈도우 밖 (not usable)

---

## TCP Sequence Numbers & ACKs: Telnet 예시 시나리오

### 상황 설명
- **Host A**가 문자 `'c'` 입력 → TCP 세그먼트 전송
- **Host B**가 이를 수신하고 `'c'`를 다시 에코(되돌려줌) → A는 이를 수신 후 ACK

### 세부 흐름
1. **Host A → Host B**
   - Seq = 42, ACK = 79, data = `'c'`
   - Host A가 `'c'`를 보내며, B로부터 0~78까지 데이터를 이미 받았다고 알림
1. **Host B → Host A**
   - Seq = 79, ACK = 43, data = `'c'`
   - Host B는 A의 `'c'`를 수신 완료했음을 알리고, 자신도 `'c'`를 보냄
1. **Host A → Host B**
   - Seq = 43, ACK = 80
   - Host A가 B로부터 보낸 `'c'`를 수신했다는 확인 메시지 전송
### 핵심 개념
- TCP는 바이트 단위로 순서를 추적하며, 각 방향으로 별도 시퀀스/ACK 번호가 유지됨
- Telnet과 같은 단문자 통신에서도 시퀀스 번호는 바이트 단위로 정밀하게 관리됨
## TCP Round Trip Time (RTT) and Timeout
### Q: How to set TCP timeout value?
- **기본 원칙**: Timeout 값은 RTT보다 길어야 하지만, RTT는 **시간에 따라 달라짐**
- **너무 짧으면**:  
  - ACK가 도착하기 전에 timeout 발생  
  - 불필요한 재전송 증가 (premature timeout)
- **너무 길면**:  
  - 실제 세그먼트 손실 발생 시 **느리게 반응**
  - 전송 지연이 심화됨

---
### Q: How to estimate RTT?
- **SampleRTT**:  
  - 한 세그먼트 전송 시점부터 해당 세그먼트에 대한 ACK 수신까지의 시간  
  - 재전송된 세그먼트는 **무시하고 측정하지 않음**

- SampleRTT는 가변적이므로 **보다 부드러운 평균값(EstimatedRTT)**을 계산해야 함
  - 최근 여러 SampleRTT 값을 평균하여 변동성 완화

---

## EstimatedRTT 계산식
`EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT`
- **EWMA (Exponentially Weighted Moving Average)**
    - 과거 SampleRTT에 가중치를 부여하여 점진적으로 반영
    - 시간이 지나면 과거 값의 영향력이 지수적으로 줄어듦
        
- **α (알파) 값**: 일반적으로 **0.125 (1/8)** 사용
    - α가 클수록 최신 SampleRTT의 반영 비율이 커짐
    - α가 작을수록 과거 추세를 더 많이 반영함

### 그래프 해석 (아래 그래프 참조)
- **파란 점 (sampleRTT)**: 개별 ACK 왕복 시간 측정값 (실제 측정된 RTT)
- **분홍 선 (EstimatedRTT)**: EWMA 기반으로 계산된 추정 RTT
    - 급격한 변화에 덜 민감하고, **평탄한 곡선 형태**를 가짐
    - timeout 설정 시 이 EstimatedRTT가 기준이 됨


## TCP Timeout 계산 및 송신자 동작
### Timeout Interval 설정
- **TimeoutInterval**은 두 요소로 구성됨:
  - **EstimatedRTT**: 예상 왕복 시간
  - **DevRTT**: SampleRTT와 EstimatedRTT 간의 편차 (표준편차 유사 개념)
`TimeoutInterval = EstimatedRTT + 4 * DevRTT`

- **DevRTT**는 SampleRTT의 변동성을 지수 가중 이동 평균(EWMA) 방식으로 계산:

`DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|`

- 일반적으로 **β = 0.25**
- 변동성이 클수록 TimeoutInterval이 더 커져 **안정적인 재전송 시점** 확보

## TCP 송신자 동작 요약 (Simplified TCP Sender FSM)
### 이벤트: 애플리케이션으로부터 데이터 수신
- 시퀀스 번호(seq #)를 붙여 세그먼트 생성
    - seq #는 세그먼트 내 첫 번째 바이트의 바이트 스트림 위치
- 타이머가 꺼져 있으면 **시작**
    - 타이머는 가장 오래된 미확인(ACK되지 않은) 세그먼트 기준
    - 타이머 만료 시간은 TimeoutInterval 사용

### 이벤트: 타임아웃 발생
- **타임아웃을 유발한 세그먼트 재전송**
- **타이머 재시작**
### 이벤트: ACK 수신
- 수신된 ACK가 **이전의 미확인 세그먼트를 확인**하면:
    - 확인된 바이트 범위 업데이트
    - 아직 미확인된 세그먼트가 남아 있다면 **타이머 다시 시작**

### 요약
- TCP는 정확한 RTT 예측을 위해 SampleRTT를 기반으로 EstimatedRTT 및 DevRTT를 계산
- 이 값을 활용하여 타이머를 설정하고, 효율적인 재전송 및 혼잡 회피를 가능하게 함
- 송신자는 이벤트 기반으로 동작하며, ACK와 Timeout에 따라 동적으로 전송 로직을 조정함

## TCP Receiver: ACK Generation 규칙 (RFC 5681)

| Event at receiver                                                                 | TCP receiver action                                                                 |
|-----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|
| in-order 세그먼트 도착, 기대한 시퀀스 번호이고, 그 앞까지는 이미 ACK 전송된 상태         | **지연 ACK** 적용: 최대 500ms 동안 다음 세그먼트 도착을 기다림. 도착하지 않으면 ACK 전송 |
| in-order 세그먼트 도착, 기대한 시퀀스 번호이고, 이전 세그먼트도 ACK 대기 중               | **즉시 누적 ACK 전송**: 두 개의 in-order 세그먼트를 모두 ACK함                       |
| out-of-order 세그먼트 도착, 기대한 시퀀스 번호보다 높은 시퀀스 번호                        | **즉시 중복 ACK 전송**: 수신 측이 기대하는 다음 시퀀스 번호를 포함하여 재전송 유도     |

---

### 요약 설명
- **지연 ACK (Delayed ACK)**  
  - 수신자는 ACK를 바로 보내지 않고, 다음 세그먼트가 곧 도착할 것을 기대하며 **최대 500ms** 기다림  
  - 이를 통해 불필요한 ACK 전송을 줄이고 네트워크 부하를 완화
- **누적 ACK (Cumulative ACK)**  
  - 여러 개의 연속된 세그먼트를 한 번에 ACK하여 **성능 향상 및 오버헤드 감소**
- **중복 ACK (Duplicate ACK)**  
  - 세그먼트 손실을 빠르게 감지하기 위해 **기대한 시퀀스 번호에 대한 ACK를 반복 전송**
  - 이는 송신자 측 Fast Retransmit의 트리거가 됨


## TCP: Retransmission Scenarios
### 1. Lost ACK Scenario (ACK 손실 시나리오)
#### 상황 요약
- Host A → Host B로 `Seq=92, 8 bytes` 데이터 전송
- Host B → ACK=100 응답 보냈지만 **ACK 손실**
- Host A는 timeout 발생 후 동일 데이터(`Seq=92`) 재전송
- Host B는 중복 수신이지만 다시 ACK=100 전송

#### 설명
- TCP는 ACK 손실 시 재전송을 유발할 수 있음
- 하지만 수신자는 중복 데이터를 **무시하고 ACK만 재전송**함
- **시퀀스 번호 기반 중복 제거**가 동작하여 데이터 중복 수신 방지

---

### 2. Premature Timeout (조기 타임아웃)

#### 상황 요약
- Host A:
  - `Seq=92, 8 bytes`
  - `Seq=100, 20 bytes` 전송
- Host B:
  - ACK=100, ACK=120 연속 전송
- Host A가 timeout 전에 ACK를 받지 못해 `Seq=92` 재전송
- Host B는 이미 받은 데이터이므로 **ACK=120 누적 응답**만 다시 전송

#### 설명
- 송신자는 **timeout 기반 재전송을 수행**하지만, 실제로는 ACK가 늦게 도착한 것일 수 있음
- TCP의 누적 ACK 덕분에 손실 없는 상황에서 **중복 재전송에도 대응 가능**

---

### 3. Cumulative ACK로 커버되는 손실 (누적 ACK 보완 시나리오)

#### 상황 요약
- Host A:
  - `Seq=92, 8 bytes`, `Seq=100, 20 bytes` 전송
- Host B:
  - ACK=100이 손실됨, 이후 `ACK=120` 도착
- Host A는 ACK=100 손실을 모름
- 이후 전송한 `Seq=120, 15 bytes` 데이터도 정상 수신됨

#### 설명
- 손실된 ACK는 **후속 누적 ACK** (`ACK=120`)에 의해 **자동 보완됨**
- TCP의 누적 ACK 방식은 일부 ACK 손실에도 불구하고 **정상적 데이터 흐름 유지**에 기여함
- 이로 인해 **불필요한 재전송 감소** 가능


## TCP Fast Retransmit

### 핵심 개념
- **트리플 중복 ACK(Triple Duplicate ACK)** 수신 시,
  - 송신자는 **타임아웃을 기다리지 않고 즉시 재전송**
  - 손실된 것으로 의심되는 **가장 낮은 시퀀스 번호의 세그먼트**를 재전송
조건: 동일한 ACK가 3번 반복 수신됨 (즉, ACK n이 4번 도착)
→ 이는 수신자가 n 이후의 세그먼트들을 이미 받았다는 의미
→ 세그먼트 n은 손실된 것으로 판단하여 재전송`
### 시나리오 설명
#### 통신 흐름
1. Host A:
    - `Seq=92, 8 bytes` 전송
    - `Seq=100, 20 bytes` 전송 → 이 세그먼트가 손실
2. Host B:
    - `Seq=92`까지만 수신 성공 → 이후 순차적으로 도착한 세그먼트는 out-of-order
    - 손실 탐지를 위해 **ACK=100**을 **세 번 반복 전송**
3. Host A:
    - ACK=100을 **3번 연속 수신**하고 `Seq=100` 세그먼트 **즉시 재전송**

---

### 요약
- **중복 ACK 3회**는 **손실 가능성 높은 강한 신호**로 간주됨
- TCP는 이를 통해 **타임아웃 기반 재전송보다 빠르게 복구 가능**
- **지연 최소화 및 네트워크 효율 향상**을 위한 중요한 최적화 기법임



