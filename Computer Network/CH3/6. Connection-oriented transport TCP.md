## TCP: 개요
**RFC 문서들**: 793, 1122, 2018, 5681, 7323  
→ TCP의 동작 원리 및 표준은 여러 RFC 문서에 정의되어 있음
- **point-to-point: 하나의 송신자와 하나의 수신자**
  - TCP 연결은 정확히 두 개의 종단점(엔드포인트) 간에 설정됨
  - 브로드캐스트나 멀티캐스트는 TCP에서 지원하지 않음

- **reliable, in-order byte stream: 신뢰 가능하고 순서가 보장된 바이트 스트림**
  - TCP는 메시지를 바이트 단위로 연속 전송함
  - 수신 측은 송신 측이 보낸 바이트를 정확히 순서대로 받아야 하며, 중간에 손실되거나 순서가 어긋나지 않도록 보장됨
  - "메시지 경계"가 없다는 뜻은, TCP는 바이트 흐름만 관리할 뿐, 개별 메시지 구분은 애플리케이션이 처리해야 함

- **full duplex data: 전이중 통신**
  - 한쪽이 데이터를 보내면서 동시에 받을 수 있음 (양방향 통신)
  - 동일한 TCP 연결 내에서 송수신이 독립적으로 동작함
  - MSS(Maximum Segment Size): 한 번에 전송할 수 있는 최대 세그먼트의 크기

- **cumulative ACKs: 누적 확인 응답**
  - TCP는 여러 세그먼트 중 마지막까지 연속해서 도착한 시점의 바이트 번호까지를 ACK로 응답함
  - 예: 100~199, 200~299를 받고 300~399가 도착하지 않았을 경우, ACK 300을 계속 보냄 → 299까지는 잘 받았음을 의미

- **pipelining: 파이프라이닝**
  - 여러 개의 세그먼트를 한 번에 전송 가능 (Stop-and-Wait 방식 아님)
  - 수신 측의 ACK를 기다리지 않고 일정 윈도우 크기 내에서 계속 전송
  - 혼잡 제어 및 흐름 제어 메커니즘이 윈도우 크기를 설정

- **connection-oriented: 연결 지향**
  - 데이터 전송 전 반드시 3-way handshaking 수행
  - 클라이언트와 서버가 연결 상태를 설정하고 유지하기 위한 제어 메시지를 주고받음
  - 연결이 설정되기 전까지는 실제 데이터가 전송되지 않음

- **flow controlled: 흐름 제어**
  - 수신 측의 수용 능력을 초과하지 않도록 송신 측을 제어함
  - TCP는 수신자가 제공하는 윈도우 크기를 통해 송신량을 제한함 → 수신자 과부하 방지

## TCP 세그먼트 구조 (TCP segment structure)

- **source port # / dest port #**  
  - 송신자와 수신자의 포트 번호 (각 16비트)
  - 포트 번호를 통해 애플리케이션과의 연결을 식별함

- **sequence number (시퀀스 번호)**  
  - 바이트 스트림 상에서 현재 세그먼트의 첫 번째 바이트의 위치를 나타냄  
  - *세그먼트 단위가 아니라 바이트 단위로 번호를 매김*

- **acknowledgement number (확인 응답 번호)**  
  - 수신자가 다음에 기대하는 바이트의 번호  
  - 이 번호까지의 모든 데이터를 정상적으로 받았음을 의미함  
  - `A` 플래그(ACK bit)가 1인 경우에만 유효함

- **head len (TCP 헤더 길이)**  
  - TCP 헤더의 크기 (단위: 32비트 워드)
  - TCP 옵션 사용 시 헤더가 가변 길이가 되므로 필요함

- **control bits (플래그 비트들)**  
  - `C`, `E`: 혼잡 알림 (Congestion Notification)
  - `U`, `A`, `P`, `R`, `S`, `F`:
    - URG: 긴급 포인터 필드 사용 여부
    - ACK: acknowledgement number 필드 유효 여부
    - PSH: 수신 측이 바로 상위 계층으로 전달하도록 지시
    - RST: 연결 재설정 요청
    - SYN: 연결 요청
    - FIN: 연결 종료 요청

- **receive window (수신 윈도우 크기)**  
  - 수신자가 현재 수용 가능한 바이트 수 (flow control 용도)
  - 송신자는 이 값을 기반으로 전송량을 조절함

- **checksum (체크섬)**  
  - 오류 검출용 필드 (IP pseudo header 포함하여 계산)

- **Urgent data pointer (긴급 데이터 포인터)**  
  - URG 플래그가 설정된 경우 유효하며, 긴급 데이터의 끝 위치를 나타냄

- **options (TCP 옵션)**  
  - 가변 길이 필드로, MSS, 윈도우 크기 조정(Window Scale), 타임스탬프 등 다양한 옵션 포함 가능

- **application data (애플리케이션 데이터)**  
  - TCP 소켓을 통해 애플리케이션이 전송한 실제 데이터 (가변 길이)

## TCP Sequence Numbers & ACKs
### Sequence numbers (시퀀스 번호)
- 세그먼트 내 **데이터의 첫 번째 바이트**가 바이트 스트림에서 차지하는 위치를 나타내는 번호
- TCP는 **바이트 단위**로 순서를 관리하며, 각 세그먼트에 부여된 시퀀스 번호는 그 세그먼트가 포함한 바이트의 시작 위치를 의미함

### Acknowledgements (확인 응답 번호)
- 수신자가 **다음에 기대하는 바이트의 시퀀스 번호**를 송신자에게 알려줌
- **누적 ACK(cumulative ACK)** 방식 사용:
  - 예: `ACK = 100`이면, 0~99 바이트까지는 모두 받았음을 의미함
- TCP는 out-of-order 패킷을 어떻게 처리할지 명시하지 않음  
  → 이는 **구현자에게 위임됨 (up to the implementor)**

### 송신자 시퀀스 번호 공간 예시 (sender sequence number space)
- 시퀀스 번호 공간은 다음과 같이 구분됨:
  - 초록색: 이미 ACK 받은 바이트
  - 파란색: 전송했지만 아직 ACK를 받지 못한 바이트 (in-flight)
  - 노란색: 현재 윈도우 내, 아직 전송하지 않은 바이트 (usable)
  - 회색: 아직 윈도우 밖 (not usable)

---

## TCP Sequence Numbers & ACKs: Telnet 예시 시나리오

### 상황 설명
- **Host A**가 문자 `'c'` 입력 → TCP 세그먼트 전송
- **Host B**가 이를 수신하고 `'c'`를 다시 에코(되돌려줌) → A는 이를 수신 후 ACK

### 세부 흐름
1. **Host A → Host B**
   - Seq = 42, ACK = 79, data = `'c'`
   - Host A가 `'c'`를 보내며, B로부터 0~78까지 데이터를 이미 받았다고 알림
1. **Host B → Host A**
   - Seq = 79, ACK = 43, data = `'c'`
   - Host B는 A의 `'c'`를 수신 완료했음을 알리고, 자신도 `'c'`를 보냄
1. **Host A → Host B**
   - Seq = 43, ACK = 80
   - Host A가 B로부터 보낸 `'c'`를 수신했다는 확인 메시지 전송
### 핵심 개념
- TCP는 바이트 단위로 순서를 추적하며, 각 방향으로 별도 시퀀스/ACK 번호가 유지됨
- Telnet과 같은 단문자 통신에서도 시퀀스 번호는 바이트 단위로 정밀하게 관리됨
## TCP Round Trip Time (RTT) and Timeout
### Q: How to set TCP timeout value?
- **기본 원칙**: Timeout 값은 RTT보다 길어야 하지만, RTT는 **시간에 따라 달라짐**
- **너무 짧으면**:  
  - ACK가 도착하기 전에 timeout 발생  
  - 불필요한 재전송 증가 (premature timeout)
- **너무 길면**:  
  - 실제 세그먼트 손실 발생 시 **느리게 반응**
  - 전송 지연이 심화됨

---
### Q: How to estimate RTT?
- **SampleRTT**:  
  - 한 세그먼트 전송 시점부터 해당 세그먼트에 대한 ACK 수신까지의 시간  
  - 재전송된 세그먼트는 **무시하고 측정하지 않음**

- SampleRTT는 가변적이므로 **보다 부드러운 평균값(EstimatedRTT)**을 계산해야 함
  - 최근 여러 SampleRTT 값을 평균하여 변동성 완화

---

## EstimatedRTT 계산식
`EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT`
- **EWMA (Exponentially Weighted Moving Average)**
    - 과거 SampleRTT에 가중치를 부여하여 점진적으로 반영
    - 시간이 지나면 과거 값의 영향력이 지수적으로 줄어듦
        
- **α (알파) 값**: 일반적으로 **0.125 (1/8)** 사용
    - α가 클수록 최신 SampleRTT의 반영 비율이 커짐
    - α가 작을수록 과거 추세를 더 많이 반영함

### 그래프 해석 (아래 그래프 참조)
- **파란 점 (sampleRTT)**: 개별 ACK 왕복 시간 측정값 (실제 측정된 RTT)
- **분홍 선 (EstimatedRTT)**: EWMA 기반으로 계산된 추정 RTT
    - 급격한 변화에 덜 민감하고, **평탄한 곡선 형태**를 가짐
    - timeout 설정 시 이 EstimatedRTT가 기준이 됨


## TCP Timeout 계산 및 송신자 동작
### Timeout Interval 설정
- **TimeoutInterval**은 두 요소로 구성됨:
  - **EstimatedRTT**: 예상 왕복 시간
  - **DevRTT**: SampleRTT와 EstimatedRTT 간의 편차 (표준편차 유사 개념)
`TimeoutInterval = EstimatedRTT + 4 * DevRTT`

- **DevRTT**는 SampleRTT의 변동성을 지수 가중 이동 평균(EWMA) 방식으로 계산:

`DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|`

- 일반적으로 **β = 0.25**
- 변동성이 클수록 TimeoutInterval이 더 커져 **안정적인 재전송 시점** 확보

## TCP 송신자 동작 요약 (Simplified TCP Sender FSM)
### 이벤트: 애플리케이션으로부터 데이터 수신
- 시퀀스 번호(seq #)를 붙여 세그먼트 생성
    - seq #는 세그먼트 내 첫 번째 바이트의 바이트 스트림 위치
- 타이머가 꺼져 있으면 **시작**
    - 타이머는 가장 오래된 미확인(ACK되지 않은) 세그먼트 기준
    - 타이머 만료 시간은 TimeoutInterval 사용

### 이벤트: 타임아웃 발생
- **타임아웃을 유발한 세그먼트 재전송**
- **타이머 재시작**
### 이벤트: ACK 수신
- 수신된 ACK가 **이전의 미확인 세그먼트를 확인**하면:
    - 확인된 바이트 범위 업데이트
    - 아직 미확인된 세그먼트가 남아 있다면 **타이머 다시 시작**

### 요약
- TCP는 정확한 RTT 예측을 위해 SampleRTT를 기반으로 EstimatedRTT 및 DevRTT를 계산
- 이 값을 활용하여 타이머를 설정하고, 효율적인 재전송 및 혼잡 회피를 가능하게 함
- 송신자는 이벤트 기반으로 동작하며, ACK와 Timeout에 따라 동적으로 전송 로직을 조정함

## TCP Receiver: ACK Generation 규칙 (RFC 5681)

| Event at receiver                                                                 | TCP receiver action                                                                 |
|-----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|
| in-order 세그먼트 도착, 기대한 시퀀스 번호이고, 그 앞까지는 이미 ACK 전송된 상태         | **지연 ACK** 적용: 최대 500ms 동안 다음 세그먼트 도착을 기다림. 도착하지 않으면 ACK 전송 |
| in-order 세그먼트 도착, 기대한 시퀀스 번호이고, 이전 세그먼트도 ACK 대기 중               | **즉시 누적 ACK 전송**: 두 개의 in-order 세그먼트를 모두 ACK함                       |
| out-of-order 세그먼트 도착, 기대한 시퀀스 번호보다 높은 시퀀스 번호                        | **즉시 중복 ACK 전송**: 수신 측이 기대하는 다음 시퀀스 번호를 포함하여 재전송 유도     |

---

### 요약 설명
- **지연 ACK (Delayed ACK)**  
  - 수신자는 ACK를 바로 보내지 않고, 다음 세그먼트가 곧 도착할 것을 기대하며 **최대 500ms** 기다림  
  - 이를 통해 불필요한 ACK 전송을 줄이고 네트워크 부하를 완화
- **누적 ACK (Cumulative ACK)**  
  - 여러 개의 연속된 세그먼트를 한 번에 ACK하여 **성능 향상 및 오버헤드 감소**
- **중복 ACK (Duplicate ACK)**  
  - 세그먼트 손실을 빠르게 감지하기 위해 **기대한 시퀀스 번호에 대한 ACK를 반복 전송**
  - 이는 송신자 측 Fast Retransmit의 트리거가 됨


## TCP: Retransmission Scenarios
### 1. Lost ACK Scenario (ACK 손실 시나리오)
#### 상황 요약
- Host A → Host B로 `Seq=92, 8 bytes` 데이터 전송
- Host B → ACK=100 응답 보냈지만 **ACK 손실**
- Host A는 timeout 발생 후 동일 데이터(`Seq=92`) 재전송
- Host B는 중복 수신이지만 다시 ACK=100 전송

#### 설명
- TCP는 ACK 손실 시 재전송을 유발할 수 있음
- 하지만 수신자는 중복 데이터를 **무시하고 ACK만 재전송**함
- **시퀀스 번호 기반 중복 제거**가 동작하여 데이터 중복 수신 방지

---

### 2. Premature Timeout (조기 타임아웃)

#### 상황 요약
- Host A:
  - `Seq=92, 8 bytes`
  - `Seq=100, 20 bytes` 전송
- Host B:
  - ACK=100, ACK=120 연속 전송
- Host A가 timeout 전에 ACK를 받지 못해 `Seq=92` 재전송
- Host B는 이미 받은 데이터이므로 **ACK=120 누적 응답**만 다시 전송

#### 설명
- 송신자는 **timeout 기반 재전송을 수행**하지만, 실제로는 ACK가 늦게 도착한 것일 수 있음
- TCP의 누적 ACK 덕분에 손실 없는 상황에서 **중복 재전송에도 대응 가능**

---

### 3. Cumulative ACK로 커버되는 손실 (누적 ACK 보완 시나리오)

#### 상황 요약
- Host A:
  - `Seq=92, 8 bytes`, `Seq=100, 20 bytes` 전송
- Host B:
  - ACK=100이 손실됨, 이후 `ACK=120` 도착
- Host A는 ACK=100 손실을 모름
- 이후 전송한 `Seq=120, 15 bytes` 데이터도 정상 수신됨

#### 설명
- 손실된 ACK는 **후속 누적 ACK** (`ACK=120`)에 의해 **자동 보완됨**
- TCP의 누적 ACK 방식은 일부 ACK 손실에도 불구하고 **정상적 데이터 흐름 유지**에 기여함
- 이로 인해 **불필요한 재전송 감소** 가능


## TCP Fast Retransmit

### 핵심 개념
- **트리플 중복 ACK(Triple Duplicate ACK)** 수신 시,
  - 송신자는 **타임아웃을 기다리지 않고 즉시 재전송**
  - 손실된 것으로 의심되는 **가장 낮은 시퀀스 번호의 세그먼트**를 재전송
조건: 동일한 ACK가 3번 반복 수신됨 (즉, ACK n이 4번 도착)
→ 이는 수신자가 n 이후의 세그먼트들을 이미 받았다는 의미
→ 세그먼트 n은 손실된 것으로 판단하여 재전송`
### 시나리오 설명
#### 통신 흐름
1. Host A:
    - `Seq=92, 8 bytes` 전송
    - `Seq=100, 20 bytes` 전송 → 이 세그먼트가 손실
2. Host B:
    - `Seq=92`까지만 수신 성공 → 이후 순차적으로 도착한 세그먼트는 out-of-order
    - 손실 탐지를 위해 **ACK=100**을 **세 번 반복 전송**
3. Host A:
    - ACK=100을 **3번 연속 수신**하고 `Seq=100` 세그먼트 **즉시 재전송**

---

### 요약
- **중복 ACK 3회**는 **손실 가능성 높은 강한 신호**로 간주됨
- TCP는 이를 통해 **타임아웃 기반 재전송보다 빠르게 복구 가능**
- **지연 최소화 및 네트워크 효율 향상**을 위한 중요한 최적화 기법임


## TCP Flow Control (흐름 제어)

### 네트워크 계층이 데이터를 너무 빠르게 전달하면?
> Q: What happens if network layer delivers data faster than application layer removes data from socket buffers?

### 문제 상황
- 수신자의 TCP 수신 버퍼는 **용량이 제한된 공간**
- **IP 계층 → TCP 계층**으로 데이터가 빠르게 도달하는데,
- **애플리케이션 계층이 데이터를 천천히 읽으면**  
  → 버퍼에 데이터가 계속 쌓이게 됨
- 결과적으로 TCP 수신 버퍼가 **가득 차면(overflow)**  
  → **추가 수신 불가능 → 손실 가능성**

### 비유적 설명
- 애플리케이션 입장에서 보면,  
  마치 **작은 입으로 호스를 통해 강하게 물이 쏟아지는 상황**
- 아래 그림처럼, 수신 측이 처리 속도보다 빠르게 데이터가 도착하면  
  **감당하지 못하고 TCP 수신 버퍼가 차오르게 됨**

### 이 문제에 대한 TCP의 해결책
- **수신 윈도우 (receive window)** 값을 통해  
  송신자에게 **현재 수용 가능한 바이트 수**를 알림
- 송신자는 이 값을 참고하여 **전송 속도를 조절**
- 이는 **flow control**의 핵심 개념임

## TCP Flow Control (계속)
### 수신자가 감당 가능한 데이터 양: Receive Window
- TCP 수신자는 자신의 수신 버퍼에서 **현재 수용 가능한 바이트 수**를 계산하여,
- 송신자에게 `receive window` 값으로 전달함
- 이 값은 **TCP 헤더의 Window 필드(16비트)**에 포함되어 ACK와 함께 주기적으로 전송됨  
  → `flow control: # bytes receiver willing to accept`
- 수신 버퍼에 여유 공간이 적으면 → `window size` 값을 줄이고
- 여유가 없으면 → `window = 0`으로 설정하여 **송신을 일시 중단시킴**

### 흐름 제어의 핵심 원리
`flow control: receiver controls sender, so sender won’t overflow receiver’s buffer by transmitting too much, too fast`

- 즉, **수신자가 송신자의 속도를 제어**하는 구조
- 이를 통해 송신자가 과도하게 많은 데이터를 보내서 **수신자의 TCP 버퍼가 넘치지 않도록 보장**

### 요약
- TCP의 흐름 제어는 **송신자의 전송 속도를 수신자의 처리 능력에 맞추기 위한 장치**
- 수신자의 버퍼 상황이 실시간으로 `window size` 값에 반영되어 전송됨
- **수신자의 버퍼 보호**를 위한 안정적인 데이터 흐름 조절 메커니즘

### TCP 흐름 제어의 실현 방식

- 수신자는 자신의 **빈 버퍼 공간**을 **`rwnd` 필드(receive window)**로 송신자에게 알림
- 이 필드는 TCP 헤더에 포함되어 전송되며, 송신자는 이 값을 바탕으로 **미확인 데이터의 전송량(in-flight)**을 조절함

### 수신 측 버퍼 구조
- `RcvBuffer`: 수신 버퍼 전체 크기 (예: 4096바이트)
- `rwnd`: 현재 남아 있는 여유 공간
- 운영체제는 일반적으로 `RcvBuffer` 크기를 자동 조절함 (auto-adjust)

→ 송신자는 `rwnd`가 0이면 전송을 중단하고, `rwnd`가 커지면 다시 전송함

### TCP 세그먼트와 rwnd의 위치
- `rwnd`는 TCP 헤더의 16비트 `Window Size` 필드에 저장됨
- 수신자는 ACK 메시지를 보낼 때마다 자신의 현재 여유 공간을 함께 광고(advertise)함

---

### TCP 연결 관리 (Connection Management)

- TCP는 데이터 교환에 앞서 송신자와 수신자가 **3-way handshake**를 통해 연결을 수립함
- 이때 양쪽은 다음 정보를 공유함:
  - 서로의 **연결 의지**
  - 초기 시퀀스 번호
  - 각자의 **수신 버퍼 크기(RcvBuffer)**

### 연결 상태 예시

클라이언트:
`Socket clientSocket = newSocket("hostname", "port number");`
서버:
`Socket connectionSocket = welcomeSocket.accept();`
→ 연결 수립 이후 양쪽은 `ESTAB` 상태로 전환되고, 시퀀스 번호와 버퍼 설정을 공유한 상태로 데이터 송수신을 시작함

### 2-Way Handshake와 그 한계

- 연결을 설정하는 가장 단순한 방식은 2-way handshake
  - 송신자: `req_conn(x)` 전송 (연결 요청 및 시퀀스 번호 `x` 선택)
  - 수신자: `acc_conn(x)`로 응답하고 ESTAB 상태로 전이
- 이 방식은 이론상 정상 작동 가능

#### Q: 2-way handshake는 항상 안전한가?

→ 그렇지 않음. 다음과 같은 문제가 있음:

- 네트워크 지연 (variable delays)
- 메시지 손실로 인한 재전송
- 메시지 순서 뒤바뀜 (reordering)
- 통신 상대방의 상태를 명확히 알 수 없음

---

### 2-Way Handshake 시나리오

#### ✅ 정상 시나리오 (No problem)

- `req_conn(x)` → `acc_conn(x)` → `data(x+1)` → `ACK(x+1)`
- 클라이언트와 서버 모두 ESTAB 상태
- 정상적으로 연결 수립 및 데이터 교환

#### ❌ 문제 시나리오: Half-open connection

- 클라이언트가 `req_conn(x)` 전송 후 종료됨
- 서버는 `acc_conn(x)` 전송 → 이 응답은 도중에 손실됨
- 클라이언트는 다시 `req_conn(x)` 전송
- 서버는 이를 새 요청으로 착각하여 또다시 ESTAB 진입
- 결과: **서버는 연결 상태로 착각하지만, 클라이언트는 존재하지 않음**

→ 이는 **Half-open connection** 문제이며, TCP에서 반드시 피해야 할 상태

---

### 결론

> 2-way handshake는 이론적으로는 가능하지만,
> **비정상 종료나 손실로 인한 동기화 문제로 인해 안전하지 않음**  
> → TCP는 이를 방지하기 위해 **3-way handshake**를 사용함

### 2-Way Handshake의 또 다른 문제

- 클라이언트가 `req_conn(x)`을 전송하고 응답을 기다리기 전에 데이터 `data(x+1)`를 전송한 경우
- 서버는 `acc_conn(x)` 없이 `req_conn(x)`만 보고 ESTAB 상태로 들어간 뒤, `data(x+1)`을 수신함
- 그런데 서버는 클라이언트가 이미 종료되었거나 이전 연결을 잘못 기억하고 있을 수 있음

→ 이 경우 **중복 데이터가 수락되는 심각한 문제 발생**

> ❌ Problem: dup data accepted! (중복된 연결 또는 이전 연결의 데이터로 잘못 해석됨)

---

### TCP 3-Way Handshake

TCP는 이러한 문제를 피하기 위해 **3-way handshake**를 사용

#### 클라이언트
1. `SYN=1`, `Seq=x` → 연결 요청 (SYN_SENT 상태)
2. 서버로부터 `SYN=1`, `ACK=1`, `Seq=y`, `ACKnum=x+1` 수신
3. `ACK=1`, `ACKnum=y+1` 전송 후 ESTAB 상태 진입

#### 서버
1. `SYN=1`, `Seq=x` 수신 → `SYN_RCVD` 상태
2. `SYN=1`, `ACK=1`, `Seq=y`, `ACKnum=x+1` 전송
3. 클라이언트로부터 `ACK=1`, `ACKnum=y+1` 수신 → ESTAB 상태 진입

→ 양측 모두 서로의 존재와 상태를 확실히 확인하고 나서 연결 수립

---

### 직관적 비유: 인간 3-way handshake

1. **클라이머**: "On belay?" (연결 요청)
2. **빌레이어**: "Belay on." (수락 응답)
3. **클라이머**: "Climbing." (상태 확인 및 최종 확인)

→ 양측이 **정확히 3번의 신호를 교환**해야만 올라가는 것처럼, TCP도 마찬가지로 **안정성과 동기화**를 확보함

---

### TCP 연결 종료 (Connection Teardown)

- 연결 종료 시, 양측은 **독립적으로 FIN 메시지를 보냄**
  - FIN 플래그가 1인 TCP 세그먼트를 전송
- 상대방은 FIN을 수신하면 **ACK로 응답**
  - 이때 자신의 FIN과 ACK를 **동시에 보낼 수도 있음**
- TCP는 **양방향 FIN 교환을 모두 처리할 수 있도록 설계됨**

→ 연결의 시작(3-way handshake)과 마찬가지로, **종료도 안정적으로 이루어짐**

