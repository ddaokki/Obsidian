## Evolving transport-layer functionality
- TCP, UDP는 지난 40년간 주요 전송 계층 프로토콜로 사용됨
- 다양한 시나리오에 맞춰 TCP의 여러 변형이 개발됨

| Scenario                 | Challenges                                    |
| ------------------------ | --------------------------------------------- |
| Long, fat pipes (대용량 전송) | 많은 패킷이 한 번에 전송됨 → 손실 발생 시 파이프라인 전체가 멈춤        |
| Wireless networks        | 무선 링크의 오류 및 이동성으로 인한 손실 발생 → TCP는 이를 혼잡으로 간주함 |
| Long-delay links         | 매우 긴 RTT (Round-Trip Time)                    |
| Data center networks     | 지연 민감 환경                                      |
| Background traffic flows | 낮은 우선순위, "백그라운드" TCP 흐름                       |

- 전송 계층 기능을 애플리케이션 계층으로 이동시키는 추세
  - 예: HTTP/3은 QUIC 프로토콜을 사용하여 UDP 위에서 동작함

## QUIC: Quick UDP Internet Connections
- 애플리케이션 계층에서 동작하는 프로토콜로, UDP 위에 구축됨
  - HTTP 성능 향상을 위해 설계됨
  - Google 서버 및 Chrome, YouTube 모바일 앱 등에서 사용 중

- 기존 구조 (HTTP/2 over TCP)
  - Application: HTTP/2
  - Transport: TLS, TCP
  - Network: IP

- QUIC은 위 구조를 UDP 기반으로 통합하여 효율성과 성능을 높임


## Evolving transport-layer functionality
- TCP, UDP는 40년간 주요 전송 계층 프로토콜로 사용됨
- 특정 시나리오에 맞는 다양한 TCP 변형이 개발됨

| Scenario | Challenges |
|----------|------------|
| Long, fat pipes (large data transfers) | Many packets "in flight"; loss shuts down pipeline |
| Wireless networks | Loss due to noisy wireless links, mobility; TCP treats this as congestion loss |
| Long-delay links | Extremely long RTTs |
| Data center networks | Latency sensitive |
| Background traffic flows | Low priority, “background” TCP flows |

- 전송 계층 기능을 응용 계층으로 이동시키는 시도 (예: QUIC)

## QUIC: Quick UDP Internet Connections
- UDP 위에서 동작하는 응용 계층 프로토콜
  - HTTP 성능 향상
  - Google 서버 및 앱(Chrome, YouTube 등)에서 사용

### 기존 TCP 기반 HTTP
Application: HTTP/2  
↓  
TLS  
↓  
Transport: TCP  
↓  
Network: IP

→ HTTP/2 over TCP

## QUIC의 주요 설계 방식
- TCP의 연결 설정, 오류 제어, 혼잡 제어 방식과 유사
  - `error and congestion control`: TCP 유사 알고리즘
  - `connection establishment`: 신뢰성, 혼잡 제어, 인증, 암호화, 상태 설정을 한 번에 수행

- 하나의 QUIC 연결에서 다중 application stream을 다룸
  - 각 스트림은 별도의 신뢰성 제공
  - 공통 혼잡 제어 사용

## QUIC: Connection establishment
- **TCP + TLS**: 2번의 handshake 필요
  - TCP 핸드셰이크
  - TLS 핸드셰이크 (보안 상태 확립)
- **QUIC**: 1 handshake로 모두 포함
  - 신뢰성 + 혼잡 제어 + 인증 + 암호화 한 번에 처리

## QUIC: Streams and Head-of-Line (HOL) Blocking 문제 해결

### HTTP 1.1에서의 문제 (그림 (a))
- 여러 HTTP 요청(GET 등)이 순차적으로 하나의 TCP 연결을 통해 전송됨
- TCP는 바이트 스트림 단위의 전송을 보장하므로, 하나의 패킷에 오류가 발생하면 그 뒤의 모든 패킷도 블로킹됨  
  → 이를 **Head-of-Line (HOL) Blocking** 문제라고 함
- TLS는 데이터 단위를 암호화하므로 병렬 요청 처리도 어려움
- 결과적으로, 병렬 처리가 어려워 전체 처리 속도 저하가 발생

### QUIC의 해결 방식 (해당 그림은 이후 슬라이드에 있을 가능성 있음)
- QUIC은 자체적으로 스트림 분리 처리 지원
- 각 스트림이 독립적으로 오류 제어 및 전송 가능함
- 하나의 스트림 오류가 다른 스트림에 영향을 미치지 않음
- TLS는 전송 계층 위가 아니라 QUIC 내부에서 함께 처리되므로 HOL 문제가 완화됨

→ **결론**: QUIC은 애플리케이션 레벨에서 병렬 처리와 신속한 복구를 가능하게 하여 HTTP/2의 HOL blocking 문제를 근본적으로 해결함


