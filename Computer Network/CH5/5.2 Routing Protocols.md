## Routing protocols
- `Routing protocol goal`: 출발지 호스트에서 목적지 호스트까지 패킷을 전달하기 위해 **좋은 경로(good path)** 를 결정하는 것
- `path`: 패킷이 거치는 라우터들의 연속적인 경로
- `good`: 비용이 적거나(least cost), 빠르거나(fastest), 혼잡하지 않은(least congested) 경로
- 라우팅은 네트워킹에서 매우 중요한 이슈 중 하나임 ("top-10" challenge)

→ **라우팅 프로토콜은 네트워크 전체의 효율성과 안정성에 직접적인 영향을 미침**  
→ 좋은 라우팅은 네트워크 지연, 패킷 손실, 과부하 등을 최소화할 수 있음

---

## Graph abstraction: link costs
- 실제 네트워크를 그래프로 추상화하여 분석
- `G = (N, E)`  
  - `N`: 라우터 집합 (예: {u, v, w, x, y, z})  
  - `E`: 링크 집합 (예: (u,v), (v,x), ... )

- 각 링크에는 **link cost**가 존재:  
  - `c_{a,b}`: 노드 a와 b 사이의 직접 연결 비용
  - 예시: `c_{w,z} = 5`, `c_{u,z} = ∞` (연결 안 됨)

→ 비용은 네트워크 운영자가 정의하며,  
`대역폭에 반비례`하거나 `혼잡도에 비례`하는 등 다양한 방식으로 설정 가능

→ **이 추상화는 알고리즘 설계 및 최적 경로 계산에 필수적**

---

## Routing algorithm classification

라우팅 알고리즘은 두 가지 기준으로 분류됨:

### 1. 정보 공유 방식 (y축)
- `global`: 모든 라우터가 전체 topology와 link cost 정보를 알고 있음  
  → **link state 알고리즘**
- `decentralized`: 라우터는 이웃과 정보 교환을 통해 경로를 점진적으로 계산  
  → **distance vector 알고리즘**

### 2. 경로 변경 속도 (x축)
- `static`: 경로가 거의 변하지 않음
- `dynamic`: 경로가 자주 바뀜 (링크 비용 변화에 반응하여 업데이트)

→ 현실적인 환경에서는 `dynamic + decentralized` 방식이 많이 사용되며,  
그 예가 RIP(distance vector)와 OSPF(link state)임

→ **Link State**는 계산량이 크지만 전체적인 최적 경로 보장이 가능  
**Distance Vector**는 상대적으로 단순하지만 loop 문제가 발생할 수 있음

## Dijkstra’s Link-State Routing Algorithm

### • 개요
- `centralized`: 모든 라우터가 전체 네트워크 토폴로지와 링크 비용 정보를 공유함 (`link state broadcast` 통해 전달됨)
- 하나의 출발지 노드에서 모든 노드로의 최소 비용 경로를 계산
- 각 노드는 이 정보를 기반으로 `forwarding table`을 구성함
- `iterative`: 매 반복마다 한 개 노드의 최단 경로가 확정됨

### • 표기법 (notation)
- `c_{x,y}`: 노드 x에서 y로 가는 직접 링크 비용 (연결 안 되어 있으면 ∞)
- `D(v)`: 출발 노드로부터 노드 v까지의 최소 비용 경로에 대한 현재 추정값
- `p(v)`: 노드 v까지 경로 상에서 v의 직전 노드
- `N'`: 최소 경로가 확정된 노드 집합

---

## 알고리즘 절차

`1. 초기화 (Initialization)`  
`N' = {u}`  
`모든 노드 v에 대해:`  
`- (u,v)가 직접 연결되어 있으면 D(v) = c_{u,v}`  
`- 아니면 D(v) = ∞`

`2. 반복 (Loop)`  
`(1) N'에 포함되지 않은 노드 중 D(w)가 최소인 w 선택`  
`(2) N'에 w 추가`  
`(3) w와 인접한 노드 v에 대해:`  
`    D(v) = min(D(v), D(w) + c_{w,v})`

→ 모든 노드가 N'에 포함될 때까지 반복

---

## 예제: 그래프에서 u → 모든 노드

### • 초기 상태 (Step 0)
- `N' = {u}`
- `D(v)=2`, `D(w)=5`, `D(x)=1`, `D(y)=∞`, `D(z)=∞`

### • Step 1
- `x` 선택 (D(x)=1)
- `D(y) = min(∞, 1+1) = 2`

### • Step 2
- `y` 선택 (D(y)=2)
- `D(w) = min(5, 2+1) = 3`, `D(z) = min(∞, 2+2) = 4`

### • Step 3
- `v` 선택 (D(v)=2, 이미 최소임 → 경로 확정)

### • Step 4
- `w` 선택 (D(w)=3)

### • Step 5
- `z` 선택 (D(z)=4)

→ `N' = {u, x, y, v, w, z}` 로 모든 노드 확정 완료

---

## 결과
### • 최소 비용 경로 트리 (from u)
- u → x → y → z  
- u → v  
- u → x → w

### • Forwarding Table in u

| Destination | Outgoing Link |
|-------------|----------------|
| v           | (u,v)          |
| x           | (u,x)          |
| y           | (u,x)          |
| w           | (u,x)          |
| z           | (u,x)          |

→ 대부분의 목적지 경로가 `x`를 통해 시작됨 → x는 u의 주요 중계 노드 역할을 수행함

---

## 참고 사항
- 알고리즘의 시간복잡도: O(N²) (heap이나 priority queue 적용 시 O(N log N))
- 다익스트라 알고리즘은 음의 가중치를 허용하지 않음 (음의 cost가 존재하면 Bellman-Ford 사용)
- `Dijkstra`는 `link state 알고리즘`의 대표 사례임 (vs. Distance Vector)

## Dijkstra’s Algorithm: Oscillations Possible

### • 경로 진동(Route Oscillation) 발생 조건
- 링크 비용이 **트래픽 양(volume)** 에 따라 변할 경우 발생할 수 있음
- 즉, 라우팅 결정이 링크 비용을 바꾸고, 변경된 링크 비용이 다시 라우팅 결정을 바꿈
→ **라우팅 결과와 링크 비용이 서로 영향을 주며 반복적으로 변화**

### • 시나리오 예시
- 목적지: `a`
- 트래픽이 `d`, `c`, `e`에서 각각 진입 (rate = 1, e, 1)
  - 단, `0 < e < 1`  
- 링크는 방향성이 있으며, 링크 비용은 유량에 따라 달라짐

### • 변화 과정
1. **초기 상태**  
   - 각 링크 비용은 초기 설정 (e.g., 0, 1, e 등)  
   - 이에 따라 라우팅 경로 결정됨

2. **새로운 경로 선택에 따라 트래픽 분포가 달라짐**  
   - 링크 사용량 변경 → 비용 변화 발생  
   - 예: `1 + e` → `2 + e` 등

3. **변경된 비용을 기준으로 다시 경로 계산**  
   - 새로운 경로 선택 → 다시 링크 사용량과 비용 변화

4. **이러한 과정이 반복되며 경로가 계속해서 진동**  
   - 수렴하지 않고 **루프에 빠질 수 있음**

---

### • 정리
- Dijkstra 알고리즘은 고정된 링크 비용을 가정함
- 그러나 **링크 비용이 트래픽 의존적**이면 알고리즘은 **불안정**해질 수 있음
- 실시간 트래픽 기반 링크 비용을 사용하는 경우에는 **안정화**

## Distance Vector Algorithm

### • 개요
- Bellman-Ford(BF) 방정식을 기반으로 동작하는 라우팅 알고리즘
- 각 노드는 이웃 노드들로부터 거리 벡터(Distance Vector)를 주기적으로 받아 갱신함
- 경로 정보는 각 노드가 목적지까지의 최소 비용을 추정한 값의 집합으로 구성됨

---

## Bellman-Ford Equation

`Dₓ(y) = minᵥ { cₓᵥ + Dᵥ(y) }`

- `Dₓ(y)`: 노드 x에서 y까지의 최소 비용 추정값  
- `cₓᵥ`: x에서 인접 노드 v까지의 직접 비용  
- `Dᵥ(y)`: v에서 목적지 y까지의 최소 경로 비용 추정  
- 최소값은 x의 모든 인접 노드 v에 대해 계산함

---

## Bellman-Ford 예시

노드 u의 이웃 노드: x, v, w  
각 노드는 목적지 z까지의 추정 비용을 알고 있음

- `Dₓ(z) = 3`, `Dᵥ(z) = 5`, `D_w(z) = 3`  
- `c_{u,x} = 1`, `c_{u,v} = 2`, `c_{u,w} = 5`

→ `Dᵤ(z) = min { 1+3, 2+5, 5+3 } = min{4, 7, 8} = 4`  
→ 최단 경로는 `u → x → z`

---

## Distance Vector Algorithm - 작동 원리
### • 핵심 개념
- 일정 시간 간격마다 각 노드는 자신의 거리 벡터를 **이웃 노드**에게 전송함
- 노드 x는 이웃으로부터 받은 정보로 자신의 거리 벡터를 Bellman-Ford 방정식으로 갱신함

`Dₓ(y) ← minᵥ{ cₓᵥ + Dᵥ(y) }` for each y ∈ N

- 수렴 조건이 충족되면, 각 노드의 추정치는 실제 최소 비용으로 수렴함

---

## Distance Vector Algorithm - 실행 흐름

각 노드는 다음과 같은 방식으로 작동함:

1. `(wait)`  
   로컬 링크 비용 변경 또는 이웃 노드로부터 메시지를 기다림

2. `(recompute)`  
   받은 정보 기반으로 자신의 거리 벡터를 재계산함

3. `(notify)`  
   만약 거리 벡터가 변경되었으면 이웃에게 알림

---

## 알고리즘 특성

- `iterative, asynchronous`  
  - 각 노드는 독립적으로 작동하며, 로컬 이벤트(링크 변화, 메시지 수신)에 의해 갱신됨

- `distributed, self-stopping`  
  - 거리 벡터가 변경된 경우에만 이웃에게 알림  
  - 이웃도 동일하게 전달받아 필요 시 재전파  
  - 변경이 없으면 어떤 동작도 수행되지 않음

→ 불필요한 통신을 줄이면서도 전체 네트워크에 점진적으로 정보가 전파됨

---

## 정리
- Distance Vector 알고리즘은 간단하고 분산적이나, 다음과 같은 한계가 존재함:
  - 수렴 속도가 느림 (count-to-infinity 문제)
  - 루프 발생 가능성 존재
- RIP, IGRP 등의 라우팅 프로토콜이 이를 기반으로 동작하며, 안정성을 위해 추가적 완화 기법 사용

## Distance Vector: Example (t = 0)
- 각 노드는 **직접 연결된 이웃 노드에 대해서만 거리 정보를 알고 있음**
- 예: 노드 `a`는 `b(8)`, `d(1)`만 알고 있으며 나머지는 무한대로 간주함
- 모든 노드는 자신의 로컬 거리 벡터를 **이웃에게 전송**
- 이 시점에서는 최소 비용 경로를 알 수 없으며 단순히 직접 링크 정보만 존재

---

## Distance Vector: Iteration (t = 1)
- 각 노드는 이웃으로부터 받은 거리 벡터 정보를 기반으로 **Bellman-Ford 방정식**을 사용하여 새로운 거리 추정치를 계산함:
  
  `Dₓ(y) ← minᵥ{ cₓᵥ + Dᵥ(y) }`

- 계산 완료 후, 새로운 거리 벡터를 다시 이웃에게 전파함
- 이 시점에서 최초의 "거리 업데이트"가 이루어짐

---

## Distance Vector: Iteration (t = 1, compute 단계)
- 모든 노드가 `compute` 상태로 진입하여 거리 벡터 재계산을 수행
- 예를 들어, `b`는 `a`를 통해 `d`로 가는 비용을 `a→d = 1, b→a = 8 → 총합 9`로 추정할 수 있음
- 해당 정보는 아직 모든 노드에 전파되지 않은 초기 단계임

---

## Distance Vector: Iteration (t = 1, send 단계)
- 새로운 거리 벡터를 이웃들에게 전송
- 메시지 교환은 이웃 간의 1-hop 범위에서만 발생
- 이 과정이 반복적으로 전체 네트워크에 거리 정보를 확산시킴

---

## Distance Vector: Iteration (t = 2)
- 이웃에게서 받은 **두 번째 거리 벡터** 정보를 기반으로 각 노드는 다시 거리 추정값을 업데이트함
- 예: `a`는 `b → e → h → i` 경로를 간접적으로 알게 되며 최소 비용을 계산함
- 점점 더 멀리 있는 목적지에 대한 경로가 수렴해감

---

## Distance Vector: Iteration (t = 2, compute 단계)
- compute 단계에서 노드들은 자신이 가지고 있는 정보를 기반으로 모든 목적지에 대해 가장 짧은 비용을 계산
- 예시에서 `g`는 이제 `b`까지의 경로를 `g → d → a → b = 1 + 1 + 8 = 10`처럼 계산 가능

---

## Distance Vector: Iteration (t = 2, send 단계)
- 계산된 거리 벡터를 기반으로 이웃에게 다시 전달 (전파)
- 이 과정이 계속 반복되면서 네트워크 전체에 정보가 확산되며 수렴

---

## Distance Vector: Iteration (and so on)
- 이 과정은 더 이상 거리 벡터에 변화가 없을 때까지 계속 반복됨
- 변화가 없으면 해당 노드는 이웃에게 메시지를 보내지 않음 → self-stopping
- 결국 모든 노드의 거리 벡터는 **최단 경로 비용으로 수렴**하게 됨

## Distance Vector Example: Node b 업데이트 (t = 1)
- 노드 `b`는 이웃 `a`, `c`, `e`로부터 거리 벡터(DV)를 수신함
- Bellman-Ford 식으로 각각의 목적지까지 최소 비용 계산:

  ```
  D_b(a) = min(c_ba + D_a(a), c_bc + D_c(a), c_be + D_e(a)) = min(8 + 0, ∞, ∞) = 8
  D_b(c) = min(8 + 1, 1 + 0, ∞) = 1
  D_b(d) = min(8 + 1, ∞, 1 + 1) = 2
  D_b(e) = min(∞, ∞, 1 + 0) = 1
  D_b(h) = min(∞, ∞, 1 + 1) = 2
  ```

- 업데이트 후 `b`의 거리 벡터는 다음과 같음:
  ```
  D_b(a)=8, D_b(c)=1, D_b(d)=2, D_b(e)=1, D_b(h)=2
  ```

---

## Distance Vector Example: Node c 업데이트 (t = 1)
- 노드 `c`는 `b`로부터 거리 벡터 수신 후 계산 수행:
  
  ```
  D_c(a) = c_cb + D_b(a) = 1 + 8 = 9
  D_c(b) = c_cb + D_b(b) = 1 + 0 = 1
  D_c(d) = 1 + 2 = 3
  D_c(e) = 1 + 1 = 2
  D_c(h) = 1 + 2 = 3
  ```

- `c`의 새로운 거리 벡터는 다음과 같음:
  ```
  D_c(a)=9, D_c(b)=1, D_c(d)=3, D_c(e)=2, D_c(h)=3
  ```

---

## Distance Vector Example: Node e 업데이트 (t = 1)
- `e`는 이웃 `b`, `d`, `f`, `h`로부터 거리 벡터를 받음
- Bellman-Ford 기반 최소 비용 계산 수행
- 이로 인해 전체 네트워크에 대한 정보가 점차 퍼져 나감

---

## Distance Vector: 정보 확산
- t=0: `c`의 상태는 오직 `c`만 알고 있음
- t=1: `b`가 업데이트된 `c`의 정보 반영 → 최대 1-hop 확산
- t=2: `a`, `e` 등 2-hop 이웃들도 영향 받기 시작
- t=3: `d`, `f`, `h` 등 3-hop 노드 반응
- t=4: 최종적으로 `g`, `i`까지 영향 전파 → **전체 수렴**

> 이처럼 distance vector 알고리즘은 **점진적이며 지역 기반 통신만으로 전체 네트워크 상태를 반영**할 수 있음

---

## Distance Vector: 링크 비용 변경 - 좋은 소식은 빠르게 전달됨
- 예: `x - y`의 비용이 4에서 1로 줄어듦
- `y`는 변경 감지 후 DV 업데이트 → `z`에게 알림
- `z`는 최단 경로로 업데이트된 정보 사용 → 업데이트 종료
- 불필요한 재전파는 없음

---

## Distance Vector: 링크 비용 변경 - 나쁜 소식은 느리게 전파됨 (Count-to-Infinity 문제)
- 예: `x - y` 비용이 1에서 60으로 급증했지만 `z`는 아직 5의 경로라고 착각
- 잘못된 경로를 참조하면서 점차 6, 7, 8, ... 식으로 **무한 증가**
- 이로 인해 convergence가 느려지며, 루프도 발생 가능

> 이 문제를 해결하기 위해 split horizon, poison reverse 등의 기법이 도입됨

## Comparison of LS and DV Algorithms

### message complexity
- **LS (Link State)**: 모든 라우터가 전체 네트워크 정보를 공유  
  → n개의 라우터가 있다면, O(n²)개의 메시지 발생
- **DV (Distance Vector)**: 이웃 간에만 거리 벡터 교환  
  → 메시지 수는 적지만 수렴 시간은 불확실

---

### speed of convergence
- **LS**: O(n²) 시간과 메시지 복잡도, 하지만 **진동(oscillation)** 가능성 있음
- **DV**:
  - 수렴 시간은 네트워크 상황에 따라 달라짐
  - **라우팅 루프** 발생 가능
  - **count-to-infinity 문제** 존재

> LS는 더 빠르고 예측 가능한 수렴, DV는 단순하지만 불안정할 수 있음

---

### robustness (내결함성, 보안성)
- **LS**:
  - 라우터가 잘못된 **링크 비용**을 광고할 수 있음
  - 하지만 각 라우터는 자신의 경로만 계산 → 피해 국한

- **DV**:
  - 라우터가 잘못된 **경로(path) 비용**을 광고할 수 있음  
    → 예: “나한테 오면 어디든 공짜야” → **black-holing (블랙홀 효과)** 발생 가능
  - 하나의 오류가 전체 네트워크에 **전이되어 확산**

> DV는 구조상 전파 기반이라, 하나의 잘못된 정보가 전체 네트워크에 영향을 줄 수 있음

## Making Routing Scalable
- 기존 라우팅 알고리즘은 "모든 라우터가 동일"하고 "플랫한 네트워크"를 전제로 함 → 현실과 맞지 않음
- **문제점 1: scale**
  - 목적지 수가 너무 많아 모든 엔트리를 라우팅 테이블에 담을 수 없음
  - 라우팅 정보 교환만으로도 링크 과부하 발생
- **문제점 2: administrative autonomy**
  - 인터넷은 수많은 독립된 네트워크(AS)의 결합체
  - 각 관리자는 자신의 네트워크 내부 라우팅을 독립적으로 통제하고자 함

---

## Internet Approach to Scalable Routing
- 라우터들을 **Autonomous System (AS)** 단위로 묶어 라우팅 단위화
- 두 가지 라우팅 수준 존재:
  ### intra-AS (intra-domain)
  - 같은 AS 내부 라우터 간 라우팅
  - 같은 라우팅 프로토콜 사용 필수
  - 외부와 연결되는 라우터를 **gateway router**라고 함

  ### inter-AS (inter-domain)
  - 서로 다른 AS 간 라우팅
  - gateway 라우터가 수행하며, intra-AS와 동시에 작동함

---

## Interconnected ASes
- 포워딩 테이블은 intra-AS와 inter-AS 라우팅 알고리즘이 **함께 구성**
  - intra-AS: 동일 AS 내 목적지에 대한 경로 설정
  - inter-AS: 외부 목적지 경로를 gateway로 설정

---

## Inter-AS Routing: 역할
- AS1 내 라우터가 외부 목적지로 가는 패킷을 수신한 경우
  - 어느 gateway로 포워딩할지 결정해야 함
- 따라서, **AS1의 inter-domain 라우팅은 다음을 수행해야 함**:
  1. 어떤 목적지가 AS2 또는 AS3를 통해 도달 가능한지 학습
  2. 해당 도달 가능 정보를 AS1의 모든 라우터에 전파

---

## Intra-AS Routing: Routing Within an AS
- 대표 intra-AS 라우팅 프로토콜:
  - **RIP** (Distance Vector)
    - 30초마다 주기적으로 DV 교환
    - 현재는 거의 사용되지 않음
  - **EIGRP** (Cisco의 DV 기반 프로토콜)
    - 2013년 이후 공개됨
  - **OSPF** (Link-State 기반, RFC 2328)
    - 공개 표준이며, 실제 많이 사용
    - ISO 버전: IS-IS도 구조 동일

---

## OSPF (Open Shortest Path First) Routing
- 링크 상태 기반 라우팅
- 주요 특징:
  - 각 라우터가 **OSPF 링크 상태 광고**를 **IP 직접 전송**으로 전파 (TCP/UDP 미사용)
  - 다양한 링크 비용 메트릭 사용 가능 (예: 대역폭, 지연)
  - 전체 네트워크 토폴로지를 유지하고 Dijkstra 알고리즘으로 경로 계산
  - **보안 강화**: 모든 OSPF 메시지는 인증됨

---

## Hierarchical OSPF
- **2단계 계층 구조**로 동작
  - 로컬 영역(area)
  - 백본 영역(backbone)
- 구조:
  - **local router**: 자신의 영역 내에서만 링크 상태 전파 및 경로 계산
  - **area border router**: 영역 간 경로 요약 후 백본에 광고
  - **backbone router**: 영역 간 경로 연결을 담당
  - **boundary router**: 외부 AS와 연결된 라우터

> 계층 구조는 전체 라우팅 부하를 줄이고 확장성을 확보하기 위한 핵심 전략임
```
