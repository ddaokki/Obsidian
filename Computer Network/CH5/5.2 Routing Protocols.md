## Routing protocols
- `Routing protocol goal`: 출발지 호스트에서 목적지 호스트까지 패킷을 전달하기 위해 **좋은 경로(good path)** 를 결정하는 것
- `path`: 패킷이 거치는 라우터들의 연속적인 경로
- `good`: 비용이 적거나(least cost), 빠르거나(fastest), 혼잡하지 않은(least congested) 경로
- 라우팅은 네트워킹에서 매우 중요한 이슈 중 하나임 ("top-10" challenge)

→ **라우팅 프로토콜은 네트워크 전체의 효율성과 안정성에 직접적인 영향을 미침**  
→ 좋은 라우팅은 네트워크 지연, 패킷 손실, 과부하 등을 최소화할 수 있음

---

## Graph abstraction: link costs
- 실제 네트워크를 그래프로 추상화하여 분석
- `G = (N, E)`  
  - `N`: 라우터 집합 (예: {u, v, w, x, y, z})  
  - `E`: 링크 집합 (예: (u,v), (v,x), ... )

- 각 링크에는 **link cost**가 존재:  
  - `c_{a,b}`: 노드 a와 b 사이의 직접 연결 비용
  - 예시: `c_{w,z} = 5`, `c_{u,z} = ∞` (연결 안 됨)

→ 비용은 네트워크 운영자가 정의하며,  
`대역폭에 반비례`하거나 `혼잡도에 비례`하는 등 다양한 방식으로 설정 가능

→ **이 추상화는 알고리즘 설계 및 최적 경로 계산에 필수적**

---

## Routing algorithm classification

라우팅 알고리즘은 두 가지 기준으로 분류됨:

### 1. 정보 공유 방식 (y축)
- `global`: 모든 라우터가 전체 topology와 link cost 정보를 알고 있음  
  → **link state 알고리즘**
- `decentralized`: 라우터는 이웃과 정보 교환을 통해 경로를 점진적으로 계산  
  → **distance vector 알고리즘**

### 2. 경로 변경 속도 (x축)
- `static`: 경로가 거의 변하지 않음
- `dynamic`: 경로가 자주 바뀜 (링크 비용 변화에 반응하여 업데이트)

→ 현실적인 환경에서는 `dynamic + decentralized` 방식이 많이 사용되며,  
그 예가 RIP(distance vector)와 OSPF(link state)임

→ **Link State**는 계산량이 크지만 전체적인 최적 경로 보장이 가능  
**Distance Vector**는 상대적으로 단순하지만 loop 문제가 발생할 수 있음

## Dijkstra’s Link-State Routing Algorithm

### • 개요
- `centralized`: 모든 라우터가 전체 네트워크 토폴로지와 링크 비용 정보를 공유함 (`link state broadcast` 통해 전달됨)
- 하나의 출발지 노드에서 모든 노드로의 최소 비용 경로를 계산
- 각 노드는 이 정보를 기반으로 `forwarding table`을 구성함
- `iterative`: 매 반복마다 한 개 노드의 최단 경로가 확정됨

### • 표기법 (notation)
- `c_{x,y}`: 노드 x에서 y로 가는 직접 링크 비용 (연결 안 되어 있으면 ∞)
- `D(v)`: 출발 노드로부터 노드 v까지의 최소 비용 경로에 대한 현재 추정값
- `p(v)`: 노드 v까지 경로 상에서 v의 직전 노드
- `N'`: 최소 경로가 확정된 노드 집합

---

## 알고리즘 절차

`1. 초기화 (Initialization)`  
`N' = {u}`  
`모든 노드 v에 대해:`  
`- (u,v)가 직접 연결되어 있으면 D(v) = c_{u,v}`  
`- 아니면 D(v) = ∞`

`2. 반복 (Loop)`  
`(1) N'에 포함되지 않은 노드 중 D(w)가 최소인 w 선택`  
`(2) N'에 w 추가`  
`(3) w와 인접한 노드 v에 대해:`  
`    D(v) = min(D(v), D(w) + c_{w,v})`

→ 모든 노드가 N'에 포함될 때까지 반복

---

## 예제: 그래프에서 u → 모든 노드

### • 초기 상태 (Step 0)
- `N' = {u}`
- `D(v)=2`, `D(w)=5`, `D(x)=1`, `D(y)=∞`, `D(z)=∞`

### • Step 1
- `x` 선택 (D(x)=1)
- `D(y) = min(∞, 1+1) = 2`

### • Step 2
- `y` 선택 (D(y)=2)
- `D(w) = min(5, 2+1) = 3`, `D(z) = min(∞, 2+2) = 4`

### • Step 3
- `v` 선택 (D(v)=2, 이미 최소임 → 경로 확정)

### • Step 4
- `w` 선택 (D(w)=3)

### • Step 5
- `z` 선택 (D(z)=4)

→ `N' = {u, x, y, v, w, z}` 로 모든 노드 확정 완료

---

## 결과
### • 최소 비용 경로 트리 (from u)
- u → x → y → z  
- u → v  
- u → x → w

### • Forwarding Table in u

| Destination | Outgoing Link |
|-------------|----------------|
| v           | (u,v)          |
| x           | (u,x)          |
| y           | (u,x)          |
| w           | (u,x)          |
| z           | (u,x)          |

→ 대부분의 목적지 경로가 `x`를 통해 시작됨 → x는 u의 주요 중계 노드 역할을 수행함

---

## 참고 사항
- 알고리즘의 시간복잡도: O(N²) (heap이나 priority queue 적용 시 O(N log N))
- 다익스트라 알고리즘은 음의 가중치를 허용하지 않음 (음의 cost가 존재하면 Bellman-Ford 사용)
- `Dijkstra`는 `link state 알고리즘`의 대표 사례임 (vs. Distance Vector)

## Dijkstra’s Algorithm: Oscillations Possible

### • 경로 진동(Route Oscillation) 발생 조건
- 링크 비용이 **트래픽 양(volume)** 에 따라 변할 경우 발생할 수 있음
- 즉, 라우팅 결정이 링크 비용을 바꾸고, 변경된 링크 비용이 다시 라우팅 결정을 바꿈
→ **라우팅 결과와 링크 비용이 서로 영향을 주며 반복적으로 변화**

### • 시나리오 예시
- 목적지: `a`
- 트래픽이 `d`, `c`, `e`에서 각각 진입 (rate = 1, e, 1)
  - 단, `0 < e < 1`  
- 링크는 방향성이 있으며, 링크 비용은 유량에 따라 달라짐

### • 변화 과정
1. **초기 상태**  
   - 각 링크 비용은 초기 설정 (e.g., 0, 1, e 등)  
   - 이에 따라 라우팅 경로 결정됨

2. **새로운 경로 선택에 따라 트래픽 분포가 달라짐**  
   - 링크 사용량 변경 → 비용 변화 발생  
   - 예: `1 + e` → `2 + e` 등

3. **변경된 비용을 기준으로 다시 경로 계산**  
   - 새로운 경로 선택 → 다시 링크 사용량과 비용 변화

4. **이러한 과정이 반복되며 경로가 계속해서 진동**  
   - 수렴하지 않고 **루프에 빠질 수 있음**

---

### • 정리
- Dijkstra 알고리즘은 고정된 링크 비용을 가정함
- 그러나 **링크 비용이 트래픽 의존적**이면 알고리즘은 **불안정**해질 수 있음
- 실시간 트래픽 기반 링크 비용을 사용하는 경우에는 **안정화**

## Distance Vector Algorithm

### • 개요
- Bellman-Ford(BF) 방정식을 기반으로 동작하는 라우팅 알고리즘
- 각 노드는 이웃 노드들로부터 거리 벡터(Distance Vector)를 주기적으로 받아 갱신함
- 경로 정보는 각 노드가 목적지까지의 최소 비용을 추정한 값의 집합으로 구성됨

---

## Bellman-Ford Equation

`Dₓ(y) = minᵥ { cₓᵥ + Dᵥ(y) }`

- `Dₓ(y)`: 노드 x에서 y까지의 최소 비용 추정값  
- `cₓᵥ`: x에서 인접 노드 v까지의 직접 비용  
- `Dᵥ(y)`: v에서 목적지 y까지의 최소 경로 비용 추정  
- 최소값은 x의 모든 인접 노드 v에 대해 계산함

---

## Bellman-Ford 예시

노드 u의 이웃 노드: x, v, w  
각 노드는 목적지 z까지의 추정 비용을 알고 있음

- `Dₓ(z) = 3`, `Dᵥ(z) = 5`, `D_w(z) = 3`  
- `c_{u,x} = 1`, `c_{u,v} = 2`, `c_{u,w} = 5`

→ `Dᵤ(z) = min { 1+3, 2+5, 5+3 } = min{4, 7, 8} = 4`  
→ 최단 경로는 `u → x → z`

---

## Distance Vector Algorithm - 작동 원리

### • 핵심 개념
- 일정 시간 간격마다 각 노드는 자신의 거리 벡터를 **이웃 노드**에게 전송함
- 노드 x는 이웃으로부터 받은 정보로 자신의 거리 벡터를 Bellman-Ford 방정식으로 갱신함

`Dₓ(y) ← minᵥ{ cₓᵥ + Dᵥ(y) }` for each y ∈ N

- 수렴 조건이 충족되면, 각 노드의 추정치는 실제 최소 비용으로 수렴함

---

## Distance Vector Algorithm - 실행 흐름

각 노드는 다음과 같은 방식으로 작동함:

1. `(wait)`  
   로컬 링크 비용 변경 또는 이웃 노드로부터 메시지를 기다림

2. `(recompute)`  
   받은 정보 기반으로 자신의 거리 벡터를 재계산함

3. `(notify)`  
   만약 거리 벡터가 변경되었으면 이웃에게 알림

---

## 알고리즘 특성

- `iterative, asynchronous`  
  - 각 노드는 독립적으로 작동하며, 로컬 이벤트(링크 변화, 메시지 수신)에 의해 갱신됨

- `distributed, self-stopping`  
  - 거리 벡터가 변경된 경우에만 이웃에게 알림  
  - 이웃도 동일하게 전달받아 필요 시 재전파  
  - 변경이 없으면 어떤 동작도 수행되지 않음

→ 불필요한 통신을 줄이면서도 전체 네트워크에 점진적으로 정보가 전파됨

---

## 정리
- Distance Vector 알고리즘은 간단하고 분산적이나, 다음과 같은 한계가 존재함:
  - 수렴 속도가 느림 (count-to-infinity 문제)
  - 루프 발생 가능성 존재
- RIP, IGRP 등의 라우팅 프로토콜이 이를 기반으로 동작하며, 안정성을 위해 추가적 완화 기법 사용

