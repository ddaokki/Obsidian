## 5.2.1 Goals of the I/O Software

### I/O 소프트웨어 설계의 핵심 목표

- **Device independence**: 장치 종류에 상관없이 동일한 방식으로 접근 가능해야 함.
- **Uniform naming**: 파일이나 장치 이름은 문자열 또는 정수 하나로 표현되어야 함.
- **Error handling**: 오류는 하드웨어에 가까운 위치에서 처리하는 것이 바람직함.
- **Synchronous vs. Asynchronous**: 동기(차단) 전송과 비동기(인터럽트 기반) 전송의 차이 고려 필요.
- **Buffering**: 네트워크 패킷 수신 등에서 내용 파악 전 데이터를 임시 저장해야 함.
- **Sharable vs. Dedicated**: 디스크처럼 공유 가능한 장치와 프린터처럼 전용 장치 구분

---

## 5.2.2 Programmed I/O

### 프로그램된 I/O 방식
- 모든 I/O를 CPU가 직접 수행함.
- 예시: 사용자 문자열을 프린터에 출력
  - 사용자 공간에 문자열 저장
  - 시스템 콜로 커널에 진입하여 장치 접근 시도
  - 장치 준비 상태 확인 → 준비되면 한 글자씩 출력 버퍼에 복사
  - CPU는 다음 문자를 보내기 전까지 바쁘게 대기 (busy waiting)

> 단점: CPU가 계속 대기하므로 비효율적임

---

## 5.2.3 Interrupt-Driven I/O

### 인터럽트를 활용한 I/O
- 프린터는 각 문자를 순차적으로 출력하며, 출력 준비가 되면 인터럽트를 발생시킴.
- 시스템 콜로 출력 요청 → 커널 공간으로 복사 → 첫 문자 전송
- 이후 CPU는 다른 프로세스를 실행하고, 출력 완료 시 인터럽트가 발생함.
- 인터럽트 핸들러가 다음 문자를 전송하거나, 완료 시 사용자 프로세스를 다시 활성화함.

> 장점: CPU가 대기하지 않음  
> 단점: 문자마다 인터럽트가 발생하므로 부하가 큼

---

## 5.2.4 I/O Using DMA
### DMA를 이용한 효율적 I/O
- 문자마다 인터럽트를 발생시키는 단점을 보완하기 위해 DMA 사용
- DMA 컨트롤러가 CPU 개입 없이 문자들을 장치로 전송
- CPU는 전송 설정만 하고 나머지는 DMA가 처리
- 전송 완료 후 **한 번의 인터럽트만** 발생

> 장점: CPU 자원을 절약하고 인터럽트 빈도를 줄임
