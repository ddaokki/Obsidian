## Ch 5. Input/Output

### 운영체제는 I/O 장치도 제어함
- I/O 장치에 명령을 내리고(command),
- 인터럽트를 수신하며,
- 오류를 처리함.

### 본 장에서는 I/O 관리 방식을 다룸
- I/O 하드웨어 원리
- I/O 소프트웨어 원리
- 디스크, 클럭, 키보드, 디스플레이, 전원관리 등의 장치 포함

---

## 5.1 Principles of I/O Hardware

### 목표
- I/O 장치를 설계·구축·유지보수하는 것이 아닌, **프로그래밍** 관점에서 다룸.
- HW 명령어와 기능, 오류 반환 등에 중점.

### 5.1.1 I/O Devices

#### 장치 유형
- **Block device**: 고정된 블록 단위로 데이터를 전송
  - 디스크, USB, 블루레이 등
  - 블록 크기: 일반적으로 512~64KB
- **Character device**: 스트림 형태로 데이터 전송
  - 주소 지정 불가, seek 불가
  - 프린터, 키보드, 네트워크 카드 등

#### 다양한 장치의 속도 차이
- 키보드: 10 B/s, 마우스: 100 B/s
- SATA 디스크: 600 MB/s, USB 3.0: 625 MB/s
- SONET OC-768: 5 GB/s

---

## 5.1.2 Device Controller (1.3.4)

### I/O 장치는 일반적으로 두 부분으로 구성됨
1. **Device controller** (제어 칩)
   - OS 명령 수신 및 처리
   - 보통 메인보드 또는 카드에 존재
2. **Device** (실제 장치)

### 각 장치는 별도의 소프트웨어(driver)가 필요
- 디바이스 드라이버는 제어 명령을 해석하고, 장치와 통신함

### 디바이스 컨트롤러 구성
- **Register**: 상태 또는 명령어 저장용
- **Buffer**: 데이터 저장용
- 전체 레지스터들의 집합 = I/O 포트 공간

---

## 5.1.3 Memory-Mapped I/O

### 컨트롤러는 CPU와 통신하기 위한 레지스터를 가짐
- OS가 레지스터에 값을 쓰면 → 장치 동작
- OS가 값을 읽으면 → 장치 상태 확인

### 데이터 버퍼 존재
- 읽기/쓰기용 임시 데이터 공간
- 예: 디스플레이 출력 시 비디오 RAM이 데이터 버퍼로 사용

### CPU는 어떻게 통신하는가?

#### 1. Port mapped I/O (I/O 포트 방식)
- 각 레지스터는 고유한 포트 번호를 가짐 (8/16bit)
- 특수한 I/O 명령어(IN, OUT 등)로만 접근 가능
- 주소 공간은 메모리 주소 공간과 다름

예:
IN REG, PORT   ; 포트에서 읽기
OUT PORT, REG  ; 포트로 쓰기

## 5.1.3 Memory-Mapped I/O (계속)

### 메모리 매핑 I/O 방식 (2)
- 제어 레지스터들을 **메모리 공간의 고유 주소**에 매핑함.
- 이 방식이 `memory-mapped I/O`라 불림.
- 일반적으로 주소 공간 상단에 위치함.

### 하이브리드 방식 (3)
- **데이터 버퍼는 메모리 매핑** 방식으로,
- **제어 레지스터는 포트 I/O** 방식으로 처리함.
- x86 아키텍처에서 사용됨.

---

### 동작 방식
- CPU가 데이터를 읽을 때, 버스에 주소를 내보내고 `READ` 신호를 보냄.
- 주소 공간이 **메모리인지 I/O인지**는 별도 신호로 구분됨.
- 메모리 공간이면 메모리가 응답, I/O 공간이면 장치가 응답함.

### 메모리 매핑 I/O의 장점
- 별도 I/O 명령 없이 일반 메모리 접근처럼 처리 가능.
- 모든 명령어가 메모리와 제어 레지스터를 동일하게 참조할 수 있음.
- 예: C 언어에서 제어 레지스터를 변수처럼 사용 가능
#define DEVICE_CONTROL_REGISTER (*(volatile unsigned int*) 0xFFFF0000)
DEVICE_CONTROL_REGISTER = 1; // 장치 on

### 메모리 매핑 I/O의 단점
1. **캐시 문제**
    - 레지스터를 캐시할 경우, 실제 장치 상태와 어긋나게 됨.
    - 예: 루프에서 캐시된 값만 참조하면 장치 변화 감지 불가.
    - 해결: 일부 페이지에 대해 캐시를 비활성화할 수 있어야 함.
        
2. **모든 메모리 참조 검사 필요**
    - 모든 모듈과 I/O 장치는 모든 메모리 참조를 검사해야 함.
    - 복잡성 증가 및 snooping 또는 필터링 기법 필요
        
---

## 1.3.4 I/O can be done in three different ways
### 1. Busy waiting
- 드라이버가 장치를 폴링하며 계속 대기함.
- CPU 자원을 계속 점유하여 비효율적임.
    
### 2. Interrupt
- 장치가 작업 완료 시 인터럽트 발생시켜 CPU에게 알림.
- OS는 다른 작업 수행 가능.
- 인터럽트 발생 시 인터럽트 핸들러가 실행되고, 작업 복귀.

### 3. DMA (Direct Memory Access)
- CPU 개입 없이 메모리와 장치 간 데이터 전송 수행.
- CPU는 DMA 설정만 하고, 전송 완료 시 인터럽트 받음.

## 5.1.5 Interrupts

### 1. 장치 작업 완료 시 인터럽트 발생
- 장치가 완료 신호(interrupt line)를 버스로 보냄.
- 메인보드의 인터럽트 컨트롤러가 이를 감지함.
- 다른 인터럽트가 없으면 즉시 처리됨.
- 더 높은 우선순위 인터럽트가 있거나 다른 작업 중이면 대기 상태로 유지됨.

### 2. 인터럽트 처리 과정
- 인터럽트 컨트롤러가 인터럽트 번호를 주소선에 넣고 CPU에 신호를 전달.
- CPU는 현재 작업 중지 후 상태(PC, 레지스터 등)를 저장.
- 인터럽트 벡터 테이블을 참조해 해당 서비스 루틴 주소로 점프함.
- 서비스 루틴이 시작되면 인터럽트 컨트롤러에 응답을 보냄(다음 인터럽트 수락 가능).

### 3. 서비스 루틴 실행
- 인터럽트 세부 정보를 요청 및 처리함.

### 4. 작업 완료 후 원래 프로세스로 복귀함.

---

## 5.1.4 Direct Memory Access (DMA)

### DMA 개요
- CPU가 매번 1바이트씩 장치와 직접 통신하는 것은 비효율적임.
- **DMA 컨트롤러**가 CPU 대신 데이터를 주고받음.
- DMA는 자체 레지스터 보유 (주소, 카운트, 제어 레지스터 등).

### DMA가 아닌 경우 (Interrupt 기반)
1. 디스크 컨트롤러가 내부 버퍼에 데이터를 순차적으로 수신.
2. 체크섬 계산으로 오류 확인.
3. 완료되면 인터럽트 발생.
4. OS가 루프를 통해 데이터를 한 바이트/워드씩 메모리에 저장.

---
## When DMA is used, the procedure is different
1. CPU가 DMA 컨트롤러를 설정하여 전송 대상, 크기 등 지정.
2. DMA 컨트롤러가 디스크 컨트롤러에 읽기 요청을 전송함.
3. 데이터가 버스 통해 메모리로 전송됨.
4. 디스크 컨트롤러가 완료 시 DMA에 확인 신호를 보냄.
5. 모든 전송 완료되면, **DMA 컨트롤러가 CPU에 인터럽트를 발생**시켜 완료를 알림.

### 요약
- OS는 DMA 설정만 하고, 데이터 전송과정에 개입하지 않음.
- CPU는 다른 작업을 수행할 수 있으며, 완료 후 인터럽트로 통지받음.
