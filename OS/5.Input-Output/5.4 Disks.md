## 5.4 Disks (1.3.3)

### 디스크와 메모리 비교
- 디스크는 RAM보다 비트당 저장 비용이 수백 배 저렴하지만, 접근 속도는 수천 배 느림.
- 메모리는 랜덤 액세스가 빠르나 디스크는 물리적 회전 및 이동이 필요하므로 느림.

### 디스크 구조
- 디스크는 하나 이상의 금속 플래터(platters)로 구성되고, 5400~10800RPM으로 회전함.
- 각 플래터에는 동심원 모양의 트랙(track)에 데이터가 저장됨.
- 동일한 위치의 트랙들이 모여 실린더(cylinder)를 형성함.
- 트랙은 다시 일정 크기(보통 512B)의 섹터(sector)로 나뉨.

## 5.4.1 Disk Hardware

### 논리적/물리적 구조 차이
- 과거 디스크는 모든 트랙에 동일한 섹터 수를 가졌으나,
- 현대 디스크는 외곽 트랙에 더 많은 섹터를 배치해 저장 효율을 높임.
- 이를 **zone bit recording**이라 하며, 외측 트랙의 저장 용량이 더 큼.

## 5.4.2 Disk Formatting

### 디스크 포맷 절차
- 사용 전 각 플래터는 소프트웨어로 low-level format을 받아야 함.
- 포맷된 각 섹터는 다음으로 구성됨:
  - **Preamble**: 시작 패턴 및 트랙/섹터 번호 등
  - **Data**: 사용자 데이터 (보통 512B)
  - **ECC**: 에러 정정 코드로 읽기 오류 복구 가능

### Cylinder Skew
- 연속된 트랙 간 섹터 0의 위치를 일부러 어긋나게 함.
- 이유: 한 트랙 읽고 다음 트랙 접근 시 회전 지연을 보상하기 위함.

### Interleaving Sectors
- 섹터가 연속된 번호로 배치되면 버퍼가 가득 차 있을 때 다음 섹터를 놓칠 수 있음.
- 해결 방법: 섹터 번호를 **interleaved** 방식으로 재배열하여 버퍼가 비워질 시간 확보
- 느린 시스템일수록 **double interleaving**이 필요할 수 있음

## 5.4.1 RAID (Redundant Array of Inexpensive Disks)

### 배경
- CPU 성능은 빠르게 증가했으나 디스크 접근 속도(특히 탐색 시간)는 느리게 개선됨.
- 1970년대 평균 탐색 시간은 50~100ms였으며, 현재도 수 ms 수준임.

### Parallel I/O
- Patterson 등의 제안으로 RAID 등장: 병렬 디스크 접근으로 성능 및 신뢰성 향상

### 기본 개념
- 여러 개의 디스크를 RAID 컨트롤러로 묶고, 이를 하나의 대형 디스크처럼 OS에 제공
- **장점**:
  - 성능: 병렬 접근 가능
  - 신뢰성: 디스크 손상 대비 redundancy 구현 가능

### RAID 종류
- RAID 0~6까지 다양한 구성 방식이 존재하며, 각기 다른 성능/신뢰성 특성을 가짐

## RAID (Redundant Array of Inexpensive Disks)

### Level 0
- `k`개의 섹터로 구성된 스트립(strip)을 여러 디스크에 분산 저장함.
- RAID 0은 스트립들을 라운드로빈 방식으로 분산 기록하며, 병렬 읽기/쓰기가 가능함.
- 큰 요청일수록 효율이 좋음(병렬성 극대화).
- **단점**: 신뢰성 없음. 디스크 하나만 고장 나도 모든 데이터가 손실됨.

### Level 1
- 모든 디스크를 복제(미러링)하여 기본 디스크(primary)와 백업 디스크(backup)로 구성됨.
- 쓰기 시 모든 디스크에 동일 데이터 기록, 읽기 시 어느 쪽이든 사용 가능.
- **장점**: 높은 내결함성(fault tolerance). 하나의 디스크가 고장 나도 복제본으로 복구 가능.
- **단점**: 저장 공간이 절반으로 줄어듦 (중복 저장 때문).

### Level 2~6 개요
- RAID 2~6은 ECC, 패리티, 스트라이핑 등 다양한 기술 조합으로 구성됨.
- RAID 3~6은 패리티 기반으로 일부 디스크에 패리티 정보 저장하여 복구 가능.
- RAID 5는 병렬성과 내결함성을 동시에 제공하여 실무에서 많이 사용됨.
- RAID 6은 이중 패리티로 RAID 5보다 더 높은 신뢰성을 제공함.

---

## 5.4.3 Disk Arm Scheduling Algorithms

### 디스크 접근 시간 구성 요소
- `seek time` + `rotational delay` + `actual data transfer time`
- 이 중 **seek time**(암 이동 시간)이 가장 큰 비중을 차지함

### FCFS (First-Come, First-Served)
- 요청 순서대로 처리함.
- 단순하지만 최적화되지 않음.
- 예: 요청 순서가 1, 36, 16, 34, 9, 12이고 시작 위치가 11이라면 전체 이동 거리 111.

### SSF (Shortest Seek First)
- 가장 가까운 요청부터 처리하여 seek time을 최소화함.
- 전체 암 이동 거리 61로 FCFS보다 효율적임.
- **단점**: 중앙에 가까운 요청이 계속 선택되어, 외곽 요청이 무시되는 starvation 발생 가능.
- 응답 시간 최소화와 공정성 간의 균형이 필요함.

### Elevator (LOOK) Algorithm
- 엘리베이터처럼 한 방향으로만 이동하다가 끝에 도달하면 반대 방향으로 전환함.
- SSF보다 공정성과 응답 시간 편차 측면에서 유리함.
- 전체 암 이동 거리 58.
- **C-LOOK**: 한 방향으로만 스캔하여 편차를 더 줄임.

## 5.5 Clocks

### 시계(타이머)의 중요성
- 멀티 프로그래밍 시스템에서 클럭은 **시간 관리와 CPU 독점 방지**에 필수적임.
- 예: 시간 간격마다 인터럽트를 발생시켜 **CPU 사용 시간 제한**, **스케줄링** 등 지원

## 5.5.1 Clock Hardware

### 구성 요소
- `Crystal Oscillator`: 고정밀 주기 신호 생성 (수백 MHz ~ GHz)
- `Counter`: 주기마다 감소하며 0이 되면 인터럽트를 발생시킴
- `Holding Register`: 초기 카운터 값 로드용

### 동작 원리
1. 결정 발진기(crystal oscillator)가 일정한 주기 신호를 발생
2. 이 신호가 counter에 공급되어 일정 간격마다 감소
3. counter가 0이 되면 인터럽트를 발생시켜 OS에게 알림
4. 이후 holding register의 값으로 다시 초기화

## 5.5.2 Clock Software

### 하드웨어의 역할
- 단순히 일정 주기마다 **인터럽트 생성**

### 소프트웨어(clock driver)의 역할
1. 현재 시간 유지
2. 프로세스가 너무 오래 실행되지 않도록 제한
3. CPU 사용량 추적
4. 사용자 알람 호출 처리
5. 시스템 구성요소용 감시 타이머 제공
6. 프로파일링, 모니터링, 통계 수집 등

### 프로세스 실행 시
- 스케줄러는 해당 프로세스의 **타임 퀀텀** 값을 카운터에 설정함
- 클럭 인터럽트가 발생할 때마다 타이머 값이 1씩 감소
- 0이 되면 clock driver가 다음 프로세스를 준비하도록 스케줄러 호출

