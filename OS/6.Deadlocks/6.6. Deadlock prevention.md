## 6.6 Deadlock Prevention

### Deadlock Avoidance의 한계
- Dijkstra의 Banker’s Algorithm은 이론적으로는 우수하나,
  - 실제로는 프로세스가 **사전에 자원 최대 요구량을 알기 어려움**
  - 프로세스 수는 **동적으로 변함**
- 따라서 실질적으로는 사용이 어려우며, 대신 **Deadlock Prevention** 기법을 사용함

### Coffman의 4가지 교착 조건
1. Mutual Exclusion (상호 배제)
2. Hold and Wait (보유 및 대기)
3. No Preemption (비선점)
4. Circular Wait (순환 대기)

→ 이들 중 **하나라도 성립하지 않도록** 만들면 교착 상태는 구조적으로 발생할 수 없음

---

## 6.6.1 Mutual Exclusion 조건 제거

- 모든 자원을 공유한다면 deadlock은 절대 발생하지 않음
- 하지만 프린터 등은 동시에 여러 프로세스가 쓰면 문제가 됨
- **해결**: Virtualization (예: 스풀링)
  - 여러 프로세스가 프린터 출력을 디스크에 저장하고, **프린터 데몬**이 실제 프린터로 출력
  - 데몬만이 실제 자원을 요청하므로 교착 상태 발생 방지

---

## 6.6.2 Hold and Wait 조건 제거

- 모든 프로세스가 **실행 전에 필요한 모든 자원을 한 번에 요청**하게 강제
  - 가능하면 자원 할당 후 실행
  - 자원 부족 시 아예 아무것도 할당하지 않고 대기시킴
- 단점
  - 대부분의 프로세스는 필요한 자원을 실행 중간에 파악함 → 사전 요청 불가
  - 자원의 **비효율적 사용** 발생 (긴 시간 자원 점유)

---

## 6.6.3 No Preemption 조건 제거

- 일부 자원을 **강제로 회수**하면 deadlock 회피 가능
- 예: 프린터를 쓰던 중, 플로터가 필요하여 프린터 회수 → 현실적으로 매우 어렵거나 불가능
- **가상화로 해결 가능**: 프린터 데몬만이 프린터를 점유하게 하면 회수 불필요
- 모든 자원에 적용 가능한 방식은 아님

---

## 6.6.4 Circular Wait 조건 제거

### 방법 1: 하나의 자원만 요청 가능
- 자원 1개 이상 필요하면 기존 자원 반납 후 다시 요청
- 비현실적: 예를 들어 디스크 → 프린터로 이어지는 출력은 중간 반납 불가

### 방법 2: 자원에 **전역 순서(숫자)** 지정
- 프로세스는 자원을 항상 **오름차순 번호** 순서로만 요청 가능
- 예: 프린터(2) → 테이프(4)는 가능, 반대 순서는 불가능
- 이 규칙을 따르면 **자원 그래프에 cycle이 생길 수 없음**
