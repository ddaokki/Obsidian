## 6.5 Deadlock Avoidance

### 교착 상태를 피할 수 있는 스케줄링 알고리즘이 존재하는가?
- 조건이 **사전에 알려진다면**, 교착 상태를 피할 수 있음

## 6.5.2 Safe and Unsafe States

### Safe 상태
- 모든 프로세스가 **최대 자원을 요청하더라도**, 순서를 조절하여 모두 종료시킬 수 있는 상태
- 시스템이 deadlock 없이 종료될 수 있다는 보장 존재

### Unsafe 상태
- 특정 순서에 따라 deadlock이 발생할 수 있음
- 즉시 deadlock이 일어나지는 않지만, **보장이 없음**

### 예시 분석 (3개의 프로세스, 하나의 자원)
- (a) 상태는 safe:
  - B → C → A 순서로 실행되면 모두 종료 가능
- (b) 상태는 unsafe:
  - A가 요청을 받았기 때문에 더 이상 safe sequence 존재하지 않음

## 6.5.3 Banker’s Algorithm for a Single Resource

### 개요
- **Dijkstra**가 제안한 deadlock 회피 알고리즘
- 고객에게 신용 한도를 주고, 실제 자원은 부족한 은행 모델을 기반으로 함
- **요청 수락 시 시스템이 unsafe 상태가 되는지 확인**

### 작동 방식
- 요청이 safe 상태를 유지하면 → **허용**
- unsafe 상태가 되면 → **거부**
- 고객은 최대 자원을 동시에 요청하지 않을 것으로 가정

### 예시
- 상태 (b)는 safe: 남은 자원으로 C가 종료 가능 → 자원 회수
- 상태 (c)는 unsafe: 자원이 부족하여 어떤 고객도 종료 불가 → deadlock 발생

> Banker 알고리즘은 **자원의 최대 요구량을 사전에 알고 있고**, 자원의 할당과 회수를 반복하는 시스템에서 효과적임
