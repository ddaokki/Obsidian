이제 사용자 관점에서 구현자 관점으로 바꿔보자.
사용자 관점: 파일 이름(name), 연산(operatrions), 디렉토리(directory)
구현자 관점:
- 파일과 디렉토리가 어떻게 저장되는지
- 디스크 공간이 어떻게 관리되는지
- 효율적이고 신뢰성 있게 동작하기 위한 방법 등을 고려


## 4.3.1 File System Layout
파일 시스템은 **디스크(disk)** 위에 저장된다.
또한 대부분의 디스크는 **하나 이상의 파티션(partition)** 으로 나뉠 수 있다.

#### (1) 디스크의 섹터 0은 MBR(Master Boot Record)이다
- **MBR**은 디스크의 첫 번째 섹터로, **컴퓨터 부팅에 사용**된다
- **MBR**에는 **파티션 테이블(partition table)** 이 포함되어 있다
- 아래 그림에서:
	- 디스크 전체 구조를 볼 수 있고
	- 왼쪽의 MBR은 파티션 정보를 가지고 있고
	- 나머지 영역은 각각의 디스크 파티션을 나타낸다
![[Pasted image 20250516054042.png]]

#### (2) Partition table(파티션 테이블)
각 **파티션의 시작과 끝 주소**를 지정함

#### (3) Active Partition(활성 파티션)
- 여러 개의 파티션 중 하나가 **활성(active) 상태**로 설정 됨
- 컴퓨터 부팅 시, **BIOS가 MBR을 읽고 실행**함
- MBR 프로그램의 첫 작업은:
	- 활성 파티션을 찾음
	- 해당 파티션의 **첫 블록(boot block)** 을 읽어 실행함
	- **boot block 내의 프로그램이 OS를 로드**함
	

#### (4) DIsk Partition Layout
- Boot block: 부트 시 실행되는 초기 코드가 위치함
- Super block: 파일 시스템(FS)에 대한 주요 정보 (크기, 블록 수 등)
- Free space management: 빈 블록(할당되지 않은 공간)에 대한 정보
- I-nodes: 각 파일에 대한 메타데이터(위치, 소유자, 크기 등)를 담음
- Root directory: 파일 시스템의 루트 디렉토리
- Files and directions: 실제 파일과 하위 디렉토리들
- ![[Pasted image 20250516054552.png]]


## 4.3.2 Implementing Files
### 가장 중요한 문제
어떤 **디스크 블록**이 **어느 파일에 속하는지를 추적**하는 것

### 가장 단순한 할당 방식
#### Contiguous Allocation(연속 할당)
각 파일을 **디스크 블록의 연속된 구간**에 저장함
예시: 
- 디스크가 비어 있는 상태에서
	-> FIle A(4 블록)가 블록 0부터 저장됨
	->이어서 File B(3 블록)느는 FIle A 다음 블록부터 저장됨.

**장점 및 구현 방법**:
- 기억해야할 정보는 **단 2가지**:
	-  **첫 번째 블록의 주소
	- **블록의 수(파일의 길이)
- 읽기 성능이 우수함:
	- 모든 블록이 연속되어 있으므로 **한번의 seek**만으로 전체 파일을 읽을 수 있음

![[Pasted image 20250516055023.png]]


**단점
- **디스크 단편화(fragmentation) 발생**
	- 예: File D와 File F가 삭제됨
	- 디스크 공간에 **빈 틈(hole)** 이 생김
	- 이 틈을 메우려면 뒤쪽 블록들을 모두 복사해야 하므로 **매우 비효율적**임 (수백만 블록 이동 필요 가능성)
- **파일 크기가 동적으로 변경될 경우 문제 발생
	- 예: 워드 프로세서로 문서를 작성 중일 때, 파일 크기가 점점 커질 수 있음
	- 연속된 블록을 미리 충분히 확보하지 않으면 **재할당**이 필요하고,
	- 이는 **복잡한 작업**과 **낮은 성능**으로 이어짐

**예외적으로 연속할당이 유용한경우
- **CD-ROM, DVD** 같은 **읽기 전용 미디어**:
	- 모든 파일 크기가 **사전에 고정됨
	- 사용 중에는 **변경되지 않음
	- 이로인해 연속 할당 방식이 **효율적이고 적절함

#### Linked List Allocation
- 파일은 **디스크 블록들의 연결 리스트**로 저장
- **각 블록의 첫 단어**는 **다음 블록을 가리키는 포인터**로 사용
- 나머지 공간은 데이터 저장에 사용

**장점
- 모든 디스크 블록을 사용할 수 있어, **디스크 단편화(fragmentation)** 문제가 없음
- 디렉토리 항목에는 **첫 번째 블록의 주소만 저장하면 충분**
- 그 이후 블록은 포인터를 따라 순차적으로 탐색 가능

**단점
- **순차 접근**도 느리긴 하나, **임의 접근(random access)** 은 **매우 느림**
- 블록의 일부가 포인터 저장에 사용되므로, **데이터 저장 공간의 2의 거듭제곱이 아닐 수 있음**
	->운영 체제는 효율적인 주소계산, 정렬, 버퍼처리를 위해 일반적으로 **2의 거듭제곱 크기**로 블록의 크기를 정하는데
	->Linked List Allocation 방식에서는 첫 번째 워드는 **다음 블록을 가리키는 포인터**로 사용되기 때문에, 해당 **포인터 크기만큼을 제외한 나머지**만 실제 데이터 저장에 사용됨
	->따라서 **효율적인 측면에서 불리**할 수 있음


![[Pasted image 20250516101428.png]]


#### Linked List Allocation Using a Table in Memory
연결 리스트 방식의 단점(랜덤 접근 느림, 데이터 공간 감소)을 해결하기 위해, **디스크 블록의 포인터를 메모리 내 테이블(FAT)** 에 저장함

**File Allocation Table의 장점
- 디스크 블록 전체를 **포인터 공간의 차지 없이** 데이터 저장에 활용할 수 있음
- 연결 리스트를 메모리 내 테이블에서 탐색하므로, **랜덤 접근이 매우 빨라짐**
- 디렉토리 항목은 **시작 블록 번호**만 알고 있으면 됨
- 체인을 따라가야 하긴 하나, **체인이 메모리에 있으므로 빠름**
	->처음 소개한 방식은 디스크에서 읽는 방식이라 매우 느림

**단점
- FAT 테이블은 **항상 메모리에 상주**해야 함
- 예를 들어 200GB 디스크, 1KB 블록일 경우 200GB/1KB = 200M의 엔트리가 필요
- 포인터 하나당 4바이트이면 총 800MB의 메모리가 FAT 테이블에 필요
- 