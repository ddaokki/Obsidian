## **4.Intro 파일 시스템의 필요성**

 2장, 3장에서 우리는 각각 프로세스와 메모리에 대해서 배웠다. OS는 CPU가 명령들을 빠르게 처리할 수 있도록 스케줄링을 통하여 효율적으로 프로세스를 관리하였고, 프로세스만으로 부족한 용량은 메모리로 해결하였다. 하지만, 프로세스는 자신의 주소 공간 내에서만 제한된 정보를 저장할 수 있어 여러 한계가 존재한다.

  -주소 공간이 작아서 은행 시스템등 일부 응용에 적합하지 않음

  -프로세스 종료시 정보도 함께 사라짐(Persistence X)

  -여러 프로세스가 동시에 동일한 정보를 접근할 필요가 있음

이러한 한계점들은 프로세스만으로 "모든 컴퓨터 응용프로그램들은 정보를 저장하고 검색해야 함" 을 성립시키기 어렵다는 것을 의미한다.



### **장기 정보 저장을 위한 3가지 필수 조건**

결론적으로, 데이터를 장기적으로 저장할 별도의 하드웨어가 필요하다는 것인데, 이를 위해선 3가지 조건이 필요하다.

1.매우 큰 양의 정보를 저장할 수 있어야 한다.

2.**지속성**(Persistence) - 프로세스 종료 이후에도 정보가 남아있어야 한다.

3.**동시성**(Concurrency) - 여러 프로세스가 동시에 접근 가능해야 한다.

  

###  **장기 저장 수단으로서의 자기 디스크**

디스크는 고정 크기의 블록들로 이루어진 선형 시퀸스(linear sequence)로 볼 수 있고 

Read block k, Write block k라는 두 가지 기본 연산을 제공한다.

그러나 여전히 문제들이 존재한다.

1.정보는 **어떻게** 찾을 것인가?

2.**다른 사용자가 데이터에 접근**하는 것을 어떻게 제한할 것인가?

3.어떤 블록이 **사용 가능**한지 어떻게 알 수 있는가?

  

  

## **4.1.1 File Naming**

파일은 추상화 메커니즘으로 정보 저장 및 검색 수단을 제공한다.

파일은 생성 시 이름이 지정되며, 프로세스가 종료되어도 이름으로 접근 가능하다. 

초기에는 8자로 제한되었지만 현대에는 최대 255자까지 허용하며 파일 이름 규칙은 운영체제 또는 파일 시스템에 따라 다르다.

일부 파일 시스템은 대소문자를 구분하며 대부분의 운영체제는 이름.확장자(foo.txt) 형식을 사용한다.


## **4.1.2 File Structure**

파일은 여러 방식으로 구조화 될 수 있다.

**운영체제는 파일의 내용에 관심이 없다**
->운영체제는 단지 바이트의 나열로만 파일을 인식할 뿐이다.

파일의 의미 부여는 사용자 수준 프로그램의 책임이고
이러한 방식은 최대한의 유연성을 제공한다.
->사용자 프로그램이 자유롭게 원하는 내용을 넣고 원하는 방식으로
이름 지정 가능

UNIX 및 WINDOW 모두 이 방식을 채택하고 있다.

![[File Structure.png]]

(a) **Byte Sequence**: 연속된 바이트들의 단순한 나열이다. (OS 입장에서의 기본 구조)

(b) **Record Sequence**: 파일은 내부 구조를 가진 고정 길이 레코드들의 시퀸스로 구성된다. 읽기(read) 연산은 레코드 하나를 반환하며,
쓰기(write) 연산은 레코드 하나를 덮어쓰거나 추가한다.
역사적으로, 80자 열의 천공카드(punched card) 기반 운영체제에서 널리 사용되었다.

(c) **Tree**: 파일은 **트리(tree)** 형태로 구성된 레코드들로 이루어진다.
각 레코드는 고정위치에 **키 필드(key field)** 를 가지고 트리는 이를 기준으로 정렬되어 있어 **빠른 탐색** 이 가능하다.
주된 연산은 순차 접근이 아니라 **특정 키를 가진 레코드를 탐색** 하는 것이다.
이 구조는 UNIX 및 Windows의 비구조적 바이트 스트림과는 다르다.-> 상업용 메인프레임 컴퓨터에서 여전히 사용되는 구조이다.


## **4.1.3 File Types**

OS들은 여러 타입들의 파일을 지원한다.

1.**Regular Files**
-일반적으로 ASCII 파일 또는 Binary 파일로 분류된다

**ASCII 파일**
	텍스트 줄로 구성된다
	텍스트 편집기로 직접 열고 편집 가능
	줄 끝 문자 체계는 운영체제 별로 다르다
	-LF(Line Feed): Unix
	-CR + LF (Carriage Return + Line Feed): MS-DOS, Windows
	-CR (Carriage Return): 옛날 Mac OS
	파이프 등을 통해 한 프로그램의 출력을 다른 프로그램의 입력으로 연결하기 쉽다.

**Binary 파일**
	ASCII가 아닌 데이터로 구성된다
	해당 파일을 사용하는 프로그램만 구조를 이해할 수 있다
	ex)UNIX의 초기 실행파일 형식
	헤더/본문으로 나뉘어져 있음![[File Types.png]]
		
2.**Directories**
-파일 시스템의 구조를 유지하기 위한 시스템 파일
-여러 파일들을 묶어서 경로를 지정하기 위해 있는 것으로,
결국 이 또한 파일에 해당한다.

3.**Character Special Files(문자 특수 파일)**
-직렬 I/O 장치 모델링 (ex: 키보드, 터미널)

4.**Block Special Fiels(블록 특수 파일)**
-디스크 모델링


## **4.1.4 File Access**

**과거 운영체제는 순차 접근(Sequential Access)만 제공하였다.**
-파일의 처음부터 끝까지 순서대로만 읽기 가능, 중간 건너뛰기 불가
-이러한 방식은 저장매체가 자기 테이프(magnetic tapes)일 때는 적합했다
	-테이프는 물리적으로 순차적인 접근만 가능하기 때문

**하지만 디스크 기반 저장 장치가 등장한 이후 임의 접근(Random Access)이 가능해 졌다.**
-데이터베이스 시스템 등 많은 응용 프로그램에서 필수적인 기능
-임의 접근을 위한 위치 지정 방식은 2가지:
	1.읽기 연산(read) 시마다 위치를 지정하여 해당 위치부터 읽기 시작
	2.seek 연산을 통해 현재 위치를 설정한 후, 이후부터 순차적으로 읽기
	-UNIX, Windows 모두 지원



## **4.1.5 File Attributes**

운영체제는 파일 이름과 데이터 뿐만 아니라 **추가정보(속성 또는 메타데이터)를**  각  파일에 연관시킨다.

![[Pasted image 20250513094516.png]]

