### 4.4.1 Disk Space Management
- 파일은 보통 디스크에 저장되므로 디스크 공간 관리는 파일 시스템 설계에서 주요한 고려 사항임.
- `n` 바이트 파일을 저장하기 위한 두 가지 전략:
  - `n` 바이트의 연속적인 디스크 공간을 할당함.
  - 파일을 여러 블록으로 분할함.

- 파일을 연속된 바이트 시퀀스로 저장하는 경우:
  - 파일 크기가 증가하면 디스크 내 다른 위치로 이동시켜야 하므로 비효율적일 수 있음.
  - 대부분의 파일 시스템은 파일을 고정된 크기의 블록으로 나누어 저장함. 이 블록들은 인접할 필요는 없음.

#### Block size
- 블록 크기를 어떻게 설정할 것인가? (디스크 섹터, 트랙, 실린더, 페이지 크기 등 기준)
- 큰 블록을 사용하는 경우:
  - 작은 파일은 많은 공간을 낭비함 (예: 1바이트 파일을 4KB 블록에 저장하면 거의 전체 공간이 낭비됨).
- 작은 블록을 사용하는 경우:
  - 대부분의 파일이 여러 블록에 걸쳐 저장되므로, 블록 읽기에 다중 탐색(seek) 및 회전 지연(rotational delay)이 발생하여 성능 저하됨.

## 4.4.1 Disk Space Management (continued)

- 할당 단위가 너무 크면 공간 낭비가 발생함.
- 할당 단위가 너무 작으면 시간 낭비가 발생함.

- `Tanenbaum et al. (2006)`의 파일 크기 분포 연구:
  - 2005년 기준, VU의 모든 파일 중 59%가 4KB 이하였음.
  - 90%의 파일이 64KB 이하.
  - 중앙값 파일 크기는 2475바이트였음.
  - 이 수치는 많은 사람들에게 작게 느껴질 수 있음.

- 위 데이터로부터 도출할 수 있는 결론:
  - 블록 크기가 1KB이면 전체 파일 중 약 30~50%만이 한 블록에 저장됨.
  - 블록 크기가 4KB이면 60~70%가 한 블록에 저장됨.

- **디스크 블록의 93%는 가장 큰 10%의 파일이 사용 중**:
  - 작은 파일의 마지막 블록에서 낭비되는 공간은 큰 영향 없음.
  - 전체 공간의 대부분은 일부 큰 파일이 차지하므로, 작은 파일에서 발생하는 낭비는 무시할 수 있음.

## Percentage of files smaller than a given size

### 표 설명
- 다양한 연도(VU 1984, VU 2005, Web)에 대해 특정 크기보다 작은 파일이 차지하는 비율을 나타냄.
- 예: 4KB보다 작은 파일이 VU 2005에서는 전체 파일의 약 59.13%, 웹에서는 약 70.64%에 해당함.
- 대부분의 파일은 크기가 작으며, 64KB를 넘는 파일은 적음.
- 이는 작은 블록 크기를 고려할 수 있는 근거를 제공함.

## 4.4.1 Disk Space Management

### 블록 크기, 데이터 속도, 디스크 공간 활용도 관계
- `Block size ↑ → data rate ↑`
  - 블록마다 탐색(seek), 회전 지연(rotational delay), 전송 시간 발생.
  - 블록 수가 줄어들면 읽기 효율이 증가함.
- `Block size ↑ → disk space utilization ↓`
  - 파일의 마지막 블록 일부가 낭비되어 전체 공간 활용도 저하.

### Figure 4-21 설명
- 그래프의 점선: 데이터 속도 (data rate)
- 그래프의 실선: 공간 효율 (space utilization)
- 교재에서는 실선과 점선이 바뀌었다고 설명함.

---

## Keeping Track of Free Blocks

### 블록 크기 선택 이후, 자유 블록 관리 필요
- **Linked List**
  - 각 블록에 여러 개의 자유 블록 번호 저장 가능.
  - 예: 1KB 블록, 32비트 블록 번호 → 블록당 255개 번호 저장 가능.
  - 500GB 디스크 → 1.9M 블록 → 약 1.9GB 필요

- **Bitmap**
  - 블록 하나당 1비트로 상태 관리.
  - 예: 500GB 디스크, 1KB 블록 → 5억 비트 → 약 62.5MB 필요

- **디스크가 거의 찼을 때**는 linked list가 유리함.

## Keeping Track of Free Blocks (continued)

### 연속된 자유 블록(run)이 자주 발생할 경우
- free-list를 run 단위로 변경하여 관리 가능.
- 각 블록에 연속 블록 수를 나타내는 카운트를 부여 (8, 16, 32비트 등).
- 이상적인 경우: 디스크 상태를 두 개의 숫자로 표현 가능 (첫 블록 주소 + 블록 수)

### 디스크가 심각하게 조각화될 경우
- run 단위 관리가 비효율적이며, 개별 블록 관리가 더 유리함.

### 운영체제 설계에서의 시사점
- 해결책은 다양하나, 시스템 배포 후 실사용 전까지는 최적의 방식 판단이 어려움.
- 설계자는 여러 대안을 고려하여 신중히 결정해야 함.

## 4.4.4 File-System Performance
### 디스크 접근 속도는 메모리 접근보다 훨씬 느림
- 32비트 메모리 단어를 읽는 데 약 10ns 소요.
- 디스크는 100MB/s로 읽지만, 트랙 탐색(seek) 및 회전 대기(rotational delay)로 5~10ms 추가됨.
- 단일 워드만 필요할 경우, 메모리 접근이 디스크보다 백만 배 정도 빠름.
- 이처럼 속도 차이가 크기 때문에 파일 시스템 성능 향상을 위한 다양한 최적화가 설계됨.

### 최적화 기법
- `Caching`
- `Block Read Ahead`

## Caching
### 디스크 접근을 줄이기 위한 대표적 기법: 블록 캐시(block cache), 버퍼 캐시(buffer cache)
- 캐시는 디스크에 있어야 할 블록을 메모리에 저장한 것.
- 읽기 요청 시 캐시에서 먼저 확인함.
  - 있으면 디스크 접근 없이 처리.
  - 없으면 디스크에서 읽은 뒤 캐시에 저장.

### 많은 블록 중 필요한 블록 존재 여부 판단
- 보통 해시 테이블을 사용하여 블록 번호와 디바이스 주소를 해싱함.
- 같은 해시값을 가진 블록들은 연결 리스트로 체이닝하여 탐색.

### 캐시가 가득 찼을 때
- 새로운 블록을 로드하면 기존 블록을 제거해야 함.
- 수정된 블록은 디스크에 다시 써야 함.
- FIFO, Second Chance, LRU 등의 페이지 교체 알고리즘 적용 가능.
- 캐시는 참조 빈도가 낮아 LRU 순서를 연결 리스트로 관리하기 용이함.

## Block Read Ahead
### 캐시에 필요한 블록을 미리 로드하여 성능 향상
- 많은 파일이 순차적으로 읽히므로 활용 가능성 높음.
- 예: 블록 `k`를 요청하면, 완료 후 `k+1`이 이미 있는지 확인.
  - 없다면 `k+1` 블록을 미리 읽어둠.

### 단, 순차 접근 파일에만 효과적
- 랜덤 접근에는 오히려 낭비.
- 불필요한 블록을 읽어 캐시를 차지함.
- 파일 시스템은 각 열린 파일의 접근 패턴을 기록해 read ahead 여부 결정.

## Block Read Ahead (continued)
### sequential-access mode vs. random-access mode
- 각 파일에 비트를 설정하여 접근 모드를 추적 가능.
- 기본적으로 sequential로 시작.
- seek이 발생하면 random으로 전환.
- 다시 순차 접근이 반복되면 비트를 초기화.
- 일부 예측 오류는 큰 문제가 아님 — 디스크 대역폭 소모만 발생.
